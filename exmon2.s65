oswrsc=$ffb3                   ; MasRef D.8-1
osrdrm=$ffb9
unk_FFCB=$ffcb
byte_FFCC=$ffcc
byte_FFCD=$ffcd
osrdch=$ffe0
osasci=$ffe3
osnewl=$ffe7
oswrch=$ffee
osword=$fff1
osbyte=$fff4
oscli=$fff7

timestamp='Sun,04 Mar 1990.14:15:47'


                .if ELECTRON==0
key_toggle_mode=9		; TAB
                .else
key_toggle_mode=';'		; no TAB on Electron
                .endif


basic_LOMEM=0	
					
basic_VARTOP=2
                
basic_stackptr=4	

basic_HIMEM=6	

byte_8=8;:		

byte_9=9;:		

byte_A=$A;:		

word_B=$B;:		

byte_D=$D;:		

byte_E=$E;		

byte_F=$F;		

byte_10=$10

byte_11=$11

basic_TOP=$12	

byte_14=$14

byte_15=$15

byte_16=$16

byte_17=$17
                
; (BASIC) MSB of PAGE
; (Exmon) flag indicating which	text window is active???
;	  bit 7	= printer on/off
basic_PAGE=$18

byte_19=$19

byte_1A=$1A

byte_1B=$1B

word_1C=$1C;	

mnemonic=$1f;:	

byte_20=$20

byte_21=$21

byte_22=$22

byte_23=$23

reg_s=$24;:		

byte_25=$25

byte_26=$26

byte_28=$28

basic_IWA=$2a ; (BASIC) IWA

unk_2B=$2b

S_or_F_data=$2c ; buffer for search/fill data

unk_2D=$2D

unk_2E=$2E

unk_30=$30

unk_32=$32

byte_35=$35

byte_36=$36

byte_37=$37

byte_38=$38

byte_39=$39

byte_3A=$3A

byte_3B=$3B

byte_3D=$3D ; copy of ESCAPE/BREAK bits???

sim_temp=$3e

cursor_x_2=$3f;:	

cursor_y_2=$40;:	

word_41=$41;	

unk_43=$43

S_or_F_wildcards=$44 ; list of indexes of wildcards in S_or_F_data

byte_45=$45

byte_46=$46

byte_47=$47

unk_49=$49

word_4A=$4A ; pointer to breakpoint	address	LSBs

word_4C=$4C; ; pointer to breakpoint	address	MSBs

word_4E=$4E

BASIC_version=$50 ; version number of BASIC, or 0	if unknown/not present

byte_51=$51 ; bit 6	= set when dual	screen mode?

byte_52=$52

reg_a=$53

reg_x=$54

reg_y=$55

reg_p=$56

byte_57=$57 ; panel	status,	hex/disassembly???

reg_pc=$58

num_breakpoints=$5a
                
; bit 7	set = shadow RAM on???
; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
; bits 0..3 = ROMSEL value
byte_5B=$5B
                
byte_5C=$5C

byte_5D=$5D

byte_5E=$5E

byte_5F=$5F

byte_60=$60

current_rom=$61;: ; if bit 6 set,	ROM has	been explicitly	set
                
byte_62=$62 ; height of panel???
                
cursor_x=$63
cursor_y=$64
                
S_or_F_num_wildcards=$65
                
workspace_code=$66 ; points to code region	in workspace, +$92
                
line_buffer=$68
                
byte_D0=$D0
byte_D6=$D6
byte_D7=$D7
byte_DF=$DF
                
word_F2=$F2;
                
workspace_pointer=$f6
                
byte_FD=$FD
byte_FE=$FE
                
BRKV=$202
WRCHV=$20e
                
byte_241=$241 ; input	source (OSBYTE 177, AUG	p186)
byte_24A=$24A ; ROM active at	last BRK (OSBYTE 186, AUG p194)
byte_24B=$24B ; ROM socket containing	BASIC (OSBYTE 187, AUG p195)
byte_254=$254 ; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
byte_258=$258 ; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
byte_26A=$26A ; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
byte_27A=$27A ; flag indicating Tube presence	($00=none, $ff=Tube) (OSBYTE 234, AUG p230)
byte_27C=$27C ; character destination	status (OSBYTE 236, AUG	p232)
byte_27D=$27D ; cursor editing status	(OSBYTE	237, AUG p233)
workspace_page_number=$280;: ; set by OSBYTE	240 (AUG p234)
byte_28C=$28C ; current language ROM number (OSBYTE 252, AUG p243; OSBYTE 142, AUG p166)
byte_290=$290 ; VDU vertical adjust, as set by *TV
byte_291=$291 ; VDU interlace	toggle,	as set by *TV
vduws=$300
vduws_CSPOSN=$34a ; address at which the 6845 is to display the text cursor (MasRef E.4-2)
vduws_TOPSCN=$350 ; address of byte in top left corner of	screen display (MasRef E.4-2)
byte_355=$355
vduws_MEMODE=$356; VDU variable:	memory mode (0=20K, 1=16K, 2=10K, 3=8K,	4=1K) (MasRef E.4-2)
basic_O=$43c;value of O%
basic_P=$440;value of P%
XWRCHV=$db4

;-------------------------------------------------------------------------

max_num_breakpoints=7
                
workspace: .block

                .virtual 0

unk_flag_1:
                .fill 1
vdu_queue_counter:
                .fill 1
old_0254:
                .fill 1
old_0258:
                .fill 1
old_027c:
                .fill 1
old_027d:
                .fill 1
old_0241:
                .fill 1
unk_flag_2:
                .fill 1
zp:
                .fill $8a
code:
                .fill workspace_code_end-workspace_code_begin

flag:
                .fill 1

breakpoint_lsbs:
                .fill max_num_breakpoints
breakpoint_msbs:
                .fill max_num_breakpoints
breakpoint_contents:
                .fill max_num_breakpoints
rest:
                .cerror *>=$f6,"workspace is too large"
                
                ; there is more stuff here, but I don't yet know what!
                ; At least a copy of $f6/$f7 at +$f6/+$f7, so those
                ; two spots have to be free.
                
                .endv
                
                .bend
                
;-------------------------------------------------------------------------

*=$8000
                
; ---------------------------------------------------------------------------
		JMP	language
; ---------------------------------------------------------------------------
		JMP	service
; ---------------------------------------------------------------------------
		.byte %11000010		; has service entry; has language entry; bit 1 set
		.byte rom_copyright - $8000		; expr:	rom_copyright&$ff
		.byte	0
rom_title:	.text 'EXMON II'        
rom_version:
		.byte 0
		.text '2.03'
		.if ELECTRON==1
		.text 'E'
		.endif
rom_copyright:
		.byte 0
		.text '(C)1990 Beebug'
		.byte 0
                
; ---------------------------------------------------------------------------

service:				
		PHA
		TXA
		PHA
		TYA
		PHA
		TSX
		LDA	$103,X		; get A
		CMP	#9
		BEQ	service_help	; taken	if *HELP
		CMP	#4
		BEQ	service_star	; taken	if * command
		CMP	#$FE 
		BEQ	service_tube_post_init ; taken if Tube post init
		CMP	#3

service_done:				
		PLA
		TAY
		PLA
		TAX
		PLA
		RTS
; ---------------------------------------------------------------------------

service_help:				
		LDA	(word_F2),Y
		CMP	#$D
		BNE	service_done	; taken	if any *HELP args
		JSR	print_newline_and_rom_title
		JSR	print_one_space	; print	one space
					;
					; preserves: X/Y
		JSR	print_rom_title
		JSR	osnewl
		JMP	service_done

; --------------- S U B	R O U T	I N E ---------------------------------------


print_newline_and_rom_title:		
		JSR	osnewl
		LDX	#$FF



; --------------- S U B	R O U T	I N E ---------------------------------------


print_rom_title:			
		INX
		LDA	rom_title,X	; "EXMON II"
		JSR	oswrch
		ORA	#0
		BNE	print_rom_title
		RTS


; ---------------------------------------------------------------------------

service_tube_post_init:			
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#7
		LDA	(workspace_pointer),Y
		CMP	#$DC 
		BNE	loc_8098
		LDY	#0
		LDA	(workspace_pointer),Y
		BNE	loc_808A
		JSR	swap_zp_and_workspaces

loc_808A:				
		LDY	#$51 
		LDA	(workspace_pointer),Y
		ASL	A
		ASL	A
		BCC	loc_8098
		LDA	#0
		LDY	#$5B 
		STA	(workspace_pointer),Y

loc_8098:				
		JMP	service_done
; ---------------------------------------------------------------------------

service_star:				
		LDX	#$FF
		DEY

loc_809E:				
		INX
		INY
		LDA	rom_title,X	; "EXMON II"
		BEQ	loc_80B5	; taken	if end of command reached
		LDA	($F2),Y		; fetch	command	line char
		AND	#$DF            ; toupper
		CMP	rom_title,X	; "EXMON II"
		BEQ	loc_809E	; taken	if char	matched
		TXA
		BEQ	service_done
		CPX	#2
		BEQ	service_done

loc_80B5:				
		LDA	($F2),Y
		CMP	#' '
		BEQ	match		; taken	if space - so it was a match
		CMP	#$D
		BNE	service_done	; taken	if neither CR nor space	- so not a match

match:
		BIT	byte_27A	; check	for Tube
		BMI	not_over_Tube_brk ; taken if Tube
		CMP	#' '
		BEQ	skip_spaces	; taken	if char	was space - so maybe some args?
                
loc_80C8:				
		LDA	workspace_page_number ;	get workspace page
		JSR	check_workspace_page ; check workspace page is valid.
					;
					; entry: A=workspace page
					; exit:	C=0 if valid, C=1 if invalid
		BCC	loc_8106	; taken	if workspace page valid
		LDA	#5
		STA	workspace_page_number ;	reset workspace	page to	5 if it	was invalid
		BNE	loc_8106	; JMP, in effect

skip_spaces:				
		INY
		LDA	(word_F2),Y
		CMP	#' '
		BEQ	skip_spaces
		CMP	#$D
		BEQ	loc_80C8	; taken	if command line	tail all spaces	- so no	args
		LDA	word_1C
		PHA
		LDA	word_1C+1
		PHA
		LDA	word_F2
		STA	workspace_pointer
		LDA	word_F2+1
		STA	workspace_pointer+1
		JSR	parse_hex
		TAX			; X = workspace	page
		PLA
		STA	word_1C+1
		PLA
		STA	word_1C
		TXA
		JSR	check_workspace_page ; check workspace page is valid.
					;
					; entry: A=workspace page
					; exit:	C=0 if valid, C=1 if invalid
		BCS	loc_8098	; bail if specified workspace page not valid - will probably end up with a Bad command error
		STA	workspace_page_number ;	store new workspace page
		JSR	workspace_setup_qqq

loc_8106:				
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDA	#1
		STA	(workspace_pointer),Y
		TYA
		LDY	#workspace.flag 
		STA	(workspace_pointer),Y
		PLA
		PLA
		TAX
		PLA
		LDA	#142		; enter	language ROM
					; AUG p166, MasRef D.2-44
		JMP	osbyte
; ---------------------------------------------------------------------------
not_over_Tube_brk_data:.text 0,0,'Not over tube',0 
; ---------------------------------------------------------------------------

not_over_Tube_brk:			
		LDX	#$F

loc_812D:				
		LDA	not_over_Tube_brk_data,X ; "Not	over tube"
		STA	$100,X
		DEX
		BPL	loc_812D
		JMP	$100

; --------------- S U B	R O U T	I N E ---------------------------------------

; check	workspace page is valid.
;
; entry: A=workspace page
; exit:	C=0 if valid, C=1 if invalid

check_workspace_page:			
		JSR	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		CMP	#$D9 
		BCS	invalid		; taken	if >=$d9 - never valid
		CMP	#$CE 
		BCC	loc_814F	; taken	if <$ce	- never	valid
		CPX	#$FD       ; Master 128
		BEQ	valid		; taken	if $cf-$d8 inclusive and Master-type hardware
		CPX	#$F5       ; Master Compact
		BEQ	valid		; taken	if $cf-$d8 inclusive and Master-type hardware
		JMP	invalid		; taken	if $cf-$d8 inclusive but not Master - so not valid
; ---------------------------------------------------------------------------

loc_814F:				
		CMP	#$80 
		BCS	invalid		; taken	if >=$80 - never valid
		CMP	#$7C 
		BCC	loc_8163	; taken	if <$7c	- probably valid
		CPX	#$FF
		BEQ	invalid		; taken	if $7c-$7f inclusive, and OS 1.20 - never valid
		JSR	is_shadow_mode	; test if current mode is a shadow mode
					;
					; exit:	C=1 if shadow
					; preserves: A/X/Y
		BCC	invalid		; taken	if $7c...$7f inclusive,	and not	a shadow mode -	not valid
		JMP	valid
; ---------------------------------------------------------------------------

loc_8163:				
		CMP	#$D
		BEQ	invalid		; taken	if workspace is	in NMI area - never valid
		CMP	#8
		BEQ	invalid		; taken	if workspace is	in MOS sound workspace - never valid
		CMP	#4
		BCC	invalid		; taken	if workspace is	in MOS workspace region	- never	valid

valid:					
					
		CLC
		RTS
; ---------------------------------------------------------------------------

invalid:				
					
		SEC
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; test if current mode is a shadow mode
;
; exit:	C=1 if shadow
; preserves: A/X/Y

is_shadow_mode:				
		PHA
		LDA	byte_D0		; VDU status byte
		AND	#$10		; bit 4	= shadow status
		CMP	#$10		; set C	if in shadow mode
		PLA
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; Read machine type, as	per OSBYTE $81
;
; exit:	X=machine type
; preserves: A/Y

get_machine_type:			
					
		PHA
		TYA
		PHA
		LDA	#129
		LDX	#0
		LDY	#255
		JSR	osbyte		; read machine type, AUG 152
		PLA
		TAY
		PLA
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


workspace_setup_qqq:			
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		TYA			; A=0
		LDY	#workspace.flag 
		STA	(workspace_pointer),Y
		LDA	#$dc
		LDY	#workspace.unk_flag_2
		STA	(workspace_pointer),Y
		LDY	#$51    ;TODO - should be #byte_51???
		LDA	#0

loc_819E:				
		STA	(workspace_pointer),Y
		INY
		CPY	#$61 
		BCC	loc_819E
		LDA	byte_24B	; ROM socket containing	BASIC (OSBYTE 187, AUG p195)
		STA	(workspace_pointer),Y
		LDA	#$E
		INY
		STA	(workspace_pointer),Y
		RTS


; ---------------------------------------------------------------------------

language:				
		LDX	#$FF
		TXS
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDA	(workspace_pointer),Y
		BEQ	workspace_ready
		JSR	swap_zp_and_workspaces
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		TYA			; A=0
		STA	(workspace_pointer),Y ;	indicate workspace ready

workspace_ready:			
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#workspace.unk_flag_2
		LDA	(workspace_pointer),Y
		CMP	#$DC 
		BEQ	loc_81D7
		JSR	swap_zp_and_workspaces
		JSR	workspace_setup_qqq
		JSR	swap_zp_and_workspaces

loc_81D7:				
		LDA	workspace_pointer+1
		STA	workspace_code+1 ; points to code region in workspace, +$92
		STA	word_4A+1	; pointer to breakpoint	address	LSBs
		STA	word_4C+1	; pointer to breakpoint	address	MSBs
		STA	word_4E+1
		LDA	#workspace.code
		STA	workspace_code	; points to code region	in workspace, +$92
		LDA	#workspace.breakpoint_lsbs
		STA	word_4A		; pointer to breakpoint	address	LSBs
		LDA	#workspace.breakpoint_msbs
		STA	word_4C		; pointer to breakpoint	address	MSBs
		LDA	#workspace.breakpoint_contents
		STA	word_4E
		LDY	#workspace_code_end-1-workspace_code_begin

loc_81F3:				
		LDA	workspace_code_begin,Y
		STA	(workspace_code),Y ; points to code region in workspace, +$92
		DEY
		BPL	loc_81F3
                ; fix up operands - ROM socket of Exmon
		LDA	$f4
		LDY	#loc_8569+1-loc_8563
		STA	(workspace_code),Y ; fix up 8569: ldx #$ff
		LDY	#loc_859D+1-loc_8563
		STA	(workspace_code),Y ; fix up 859d: lda #$ff
                ; fix up operands - MSB of workspace page
		LDA	workspace_code+1 ; get workspace page
		LDY	#loc_8563+2-loc_8563
		STA	(workspace_code),Y ; fix up 8563: jsr $059c
		LDY	#loc_8584+2-loc_8563
		STA	(workspace_code),Y ; fix up 8584: jsr $05ca
		LDY	#loc_8595+2-loc_8563
		STA	(workspace_code),Y ; fix up 8595: jsr $05ca
		LDY	#loc_85A7+2-loc_8563
		STA	(workspace_code),Y ; fix up 85a7: jsr $059f
		LDY	#loc_85AC+2-loc_8563
		STA	(workspace_code),Y ; fix up 85ac: jmp $0598
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		AND	#$81 
		STA	byte_51		; bit 6	= set when dual	screen mode?
		LDY	#0
		STY	byte_52
		STY	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		DEY
		STY	byte_23
		LDX	reg_x
		LDY	reg_y
		CLC
		LDA	reg_pc
		ADC	#2
		STA	reg_pc
		LDA	reg_pc+1
		ADC	#0
		PHA
		LDA	reg_pc
		PHA
		LDA	reg_p
		PHA
		LDA	reg_a
		JSR	swap_zp_and_workspaces

BRK_handler_8245:
		JSR	swap_zp_and_workspaces
		PLP
		JSR	sub_8CA7
		PLA
		SEC
		SBC	#2
		STA	reg_pc
		PLA
		SBC	#0
		STA	reg_pc+1
		TSX
		STX	reg_s
		JSR	sub_8331
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#workspace.flag
		LDA	(workspace_pointer),Y
		BEQ	loc_8269
		JSR	loc_9BA4

loc_8269:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVC	loc_8273
		JSR	sub_9CBA
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_8273:				
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 22
		.byte 7
; ---------------------------------------------------------------------------
		NOP


command_line_loop_1:			
		JSR	print_cr
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y

command_line_loop_2:			
		JSR	print_cr	; redraw panel,	print ?, do command line input loop
		JSR	draw_panel
		JSR	sub_A35C

command_line_loop_3:			
		LDX	reg_s
		TXS
		LDA	#15
		JSR	oswrch		; disable paged	mode
		JSR	command_line_window_osnewl
		LDA	#'?'
		JSR	oswrch		; print	prompt

command_line_input_loop:		
		LDA	#0		; also handler for U command
		STA	byte_258	; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		JSR	flush_input_buffer_and_readch

loc_82A2:				
		LDX	#0
		STX	byte_21
		CMP	#key_toggle_mode
		BEQ	handle_toggle_hex_mcode
		CMP	#'*'
		BNE	check_exclamation
		JMP	handle_star
; ---------------------------------------------------------------------------

check_exclamation:			
		CMP	#'!'
		BNE	check_cr
		JMP	handle_exclamation
; ---------------------------------------------------------------------------

check_cr:				
		CMP	#$D
		BNE	check_space

handle_cr:
		JSR	print_cr
		JSR	sub_8331

loc_82C2:				
		JSR	sub_8910
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

check_space:				
		CMP	#' '
		BNE	check_ctrl_z

handle_space:				; copy of ESCAPE/BREAK bits???
		STA	byte_3D
		LDA	#$D
		JSR	oswrch
		JMP	loc_96DD
; ---------------------------------------------------------------------------

check_ctrl_z:				
		CMP	#26
		BNE	check_alpha
		JMP	handle_ctrl_z
; ---------------------------------------------------------------------------

check_alpha:				
		PHA
		SEC
		SBC	#'?'            ; ?=0, @=1, A=2, etc.
		BMI	command_line_input_loop	; taken	if not an alpha	char
		CMP	#28
		BCS	command_line_input_loop	; taken	if >Z
		ASL	A
		TAX
		PLA
		TAY
		LDA	command_addrs_BE,X ; big-endian
		PHA			; push MSB
		LDA	command_addrs_BE+1,X ; big-endian
		PHA			; push LSB
		TYA
		RTS
; ---------------------------------------------------------------------------

handle_toggle_hex_mcode:
		LDA	#118		; update keyboard LEDs and retrieve CTRL status	(AUG p140)
		JSR	osbyte
		TXA			; A=CTRL status
		ASL	A		; get CTRL status in C
		BCC	loc_8321	; taken	if CTRL	not pressed
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_8324
		JSR	sub_9CC3

loc_8308:				
		JSR	osrdch
		CMP	#27
		BEQ	loc_8315
		JSR	osasci
		JMP	loc_8308
; ---------------------------------------------------------------------------

loc_8315:				
		JSR	sub_9CC3
		JSR	acknowledge_ESCAPE
		JSR	sub_8910
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_8321:				
		JSR	sub_832A

loc_8324:				
		JSR	sub_8910
		JMP	command_line_loop_1


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_832A:				
		LDA	byte_57		; panel	status,	hex/disassembly???
		EOR	#$FF
		STA	byte_57		; panel	status,	hex/disassembly???
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8331:				
		LDA	byte_5C
		STA	byte_5E
		LDA	byte_5D
		STA	byte_5F
		LDA	byte_60
		BNE	locret_8345
		LDA	reg_pc
		STA	byte_5E
		LDA	reg_pc+1
		STA	byte_5F

locret_8345:				
		RTS


; ---------------------------------------------------------------------------

command_addr: .macro addr
                .byte >(\addr-1)
                .byte <(\addr-1)
                .endm

command_addrs_BE:
                .command_addr cmd_help
		.command_addr cmd_at
		.command_addr cmd_A
		.command_addr cmd_B
		.command_addr cmd_C
		.command_addr cmd_D_or_L
		.command_addr cmd_E
		.command_addr cmd_F
		.command_addr cmd_G
		.command_addr cmd_H
		.command_addr cmd_I
		.command_addr cmd_J
		.command_addr cmd_K
		.command_addr cmd_D_or_L
		.command_addr cmd_M
		.command_addr cmd_N
		.command_addr cmd_O
		.command_addr cmd_P
		.command_addr cmd_Q
		.command_addr cmd_R
		.command_addr cmd_S
		.command_addr cmd_T
		.command_addr command_line_input_loop ;U = unused
		.command_addr cmd_V
		.command_addr cmd_W
		.command_addr cmd_X
		.command_addr cmd_Y
		.command_addr cmd_Z
                
; ---------------------------------------------------------------------------

cmd_help:
		JSR	oswrch
		JSR	set_output_text_window_and_cls
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.text '      SUMMARY OF MAIN COMMANDS',$D
		.text '@=set PC            A=set accumulator',$D
		.text 'BS/BC=brk set/clear C=calculate',$D
		.text 'D=disassemble       E=edit or assemble',$D
		.text 'FB/FS=fill          G=go',$D
		.text 'I=invert flag       J=JSR',$D
		.text 'L=list memory       M=move block',$D
		.text 'P=set panel start   Q=quit',$D
		.text 'R=relocate          SB/SS=search',$D
		.text 'V=verify blocks     WI=set window size',$D
		.text 'X=set X register    Y=set Y register',$D
		.text '!=change ROM        <cr>=reset panel',$D
		.text '<space>=simulate    /=one level trace',$D
		.if key_toggle_mode==9
		.text '<TAB>'
		.else
		.text key_toggle_mode
		.endif
		.text '=toggle format (hex/disassembly)'
; ---------------------------------------------------------------------------
		NOP
		JMP	command_line_loop_3
; ---------------------------------------------------------------------------

workspace_code_begin:
                .logical $500+workspace.code
loc_8563:				
		JSR	select_BASIC_ROM ;ww9c
loc_8566:
		JSR	0
loc_8569:
		LDX	#$FF
		BPL	loc_8570
select_BASIC_ROM:
		LDX	byte_24B	; ROM socket containing	BASIC (OSBYTE 187, AUG p195)

loc_8570:				
		STX	$f4
		STX	$FE30
		RTS
; ---------------------------------------------------------------------------
;change ROM and call routine
loc_8576:
		PHP
		PHA
loc_8578:
		LDA	#$FF
		STA	$f4
		STA	$FE30
		PLA
		PLP
loc_8581:
		JMP	basic_LOMEM
; ---------------------------------------------------------------------------
loc_8584:
		JSR	select_exmon2_rom ;wwca
		JMP	loc_9904
; ---------------------------------------------------------------------------
loc_858A:
		BEQ	loc_858F
		JMP	simulated_branch_not_taken
; ---------------------------------------------------------------------------

loc_858F:				
		JMP	simulated_branch_taken
; ---------------------------------------------------------------------------
loc_8592:
		JSR	sub_9A43
loc_8595:
		JSR	select_exmon2_rom ;wwca
		JMP	loc_9A78
; ---------------------------------------------------------------------------
select_exmon2_rom:
		PHP
		PHA
loc_859D:
		LDA	#$FF
		STA	$f4
		STA	$FE30
		PLA
		PLP
		RTS
; ---------------------------------------------------------------------------
loc_85A7:
		JSR	loc_8570
		STA	(workspace_pointer),Y
loc_85AC:
		JMP	loc_8569
                .here
workspace_code_end:

; --------------- S U B	R O U T	I N E ---------------------------------------

determine_BASIC_version:
		LDY	byte_24B	; ROM socket containing	BASIC (OSBYTE 187, AUG p195)
		BPL	loc_85B9
		LDY	#0
		JMP	loc_85CE
; ---------------------------------------------------------------------------

loc_85B9:				
		LDA	#8
		STA	workspace_pointer
		LDA	#$80 
		STA	workspace_pointer+1
		JSR	osrdrm		; read $8008 from BASIC	ROM - version number
		LDY	#5

loc_85C6:				
		CMP	BASIC_versions-1,Y
		BEQ	loc_85CE
		DEY
		BNE	loc_85C6

loc_85CE:				
					; determine_BASIC_version+1Aj
		TYA
		STA	BASIC_version	; version number of BASIC, or 0	if unknown/not present
		RTS

BASIC_versions:	.byte	0		; 0
					; type 1: ver $00=BASIC	I
		.byte	1		; type 2: ver $01=BASIC	II
		.byte	4		; type 3: ver $04=BASIC	4
		.byte $40 ; @		; type 4: ver $40=BASIC	4 from Master Compact
		.byte	7		; type 5: ver $07=BASIC	4r32

; ---------------------------------------------------------------------------

; BASIC ROM entry points
;
; 0 = assemble instruction
; 1 = get integer result of expression
; 2 = print line number on screen
; 3 = prompt for command line and execute the entered command(s) without reinitialising

num_basic_versions=5
                
basic_entry_points: .macro b1,b2,b4,b480,b4r32
                .byte <\b1
                .byte <\b2
                .byte <\b4
                .byte <\b480
                .byte <\b4r32
                .byte >\b1
                .byte >\b2
                .byte >\b4
                .byte >\b480
                .byte >\b4r32
                .endm
                
; http://8bs.com/basic/basic4-a085.htm
                
unk_85D7: .block

assemble=*-unk_85D7
                ; assemble instruction
                ; http://8bs.com/basic/basic4-89eb.htm
                .basic_entry_points $85a1,$85ba,$89eb,$89c4,$8aa8

eval_expr=*-unk_85D7
                ; get integer result of expression
                ; http://8bs.com/basic/basic4-96af.htm
                .basic_entry_points $928c,$92dd,$96af,$9690,$9774

print_line_number=*-unk_85D7
                ; print line number on screen
		; http://8bs.com/basic/basic4-a085.htm
                .basic_entry_points $98f1,$991f,$a081,$a004,$a0e8

prompt_and_execute=*-unk_85D7
                ; prompt for command line and execute the entered
                ; command(s) without reinitialising
                ; http://8bs.com/basic/basic4-8f83.htm
                .basic_entry_points $8a99,$8af6,$8f86,$8f67,$904b
                
                .bend
                
                ; BRK vectors
unk_85FF:
                .basic_entry_points $b433,$b402,$b278,$b1ce,$b2b2                
; unk_85FF:
; 		.byte $33 
; 		.byte	2
; 		.byte $78 
; 		.byte $CE 
; unk_8603:	.byte $B2 
; 		.byte $B4 
; 		.byte $B4 
; 		.byte $B2 
; 		.byte $B1 
; 		.byte $B2 

; --------------- S U B	R O U T	I N E ---------------------------------------

; prepare for a	call to	a routine in BASIC.
;
; entry: X = index of routine to call

prepare_BASIC_routine_call:		
		PHA
		TYA
		PHA
		TXA
		CLC
		ADC	#<(unk_85d7-1)
		STA	word_41
		LDA	#>(unk_85d7-1)
		ADC	#0
		STA	word_41+1
		LDY	BASIC_version	; version number of BASIC, or 0	if unknown/not present
		LDA	(word_41),Y
		LDY	#loc_8566+1-loc_8563
		STA	(workspace_code),Y ; fix up routine address LSB
		LDA	BASIC_version	; version number of BASIC, or 0	if unknown/not present
		CLC
		ADC	#num_basic_versions
		TAY
		LDA	(word_41),Y
		LDY	#loc_8566+2-loc_8563
		STA	(workspace_code),Y ; fix up routine address MSB
		PLA
		TAY
		PLA
		RTS


; ---------------------------------------------------------------------------

cmd_C:					; print	char in	A then print one space
		JSR	print_char_then_one_space ;
					; preserves: X/Y
		JSR	read_and_evaluate_expression
		CMP	#21
		BCC	loc_863D
		JSR	osnewl

loc_863D:				
		LDX	#0
		LDY	#3

loc_8641:				
		LDA	basic_IWA,Y	; (BASIC) IWA
		JSR	store_hex_byte_in_line_buffer
		DEY
		BPL	loc_8641
		JSR	print_one_space	; print	one space
					;
					; preserves: X/Y
		JSR	print_one_space	; print	one space
					;
					; preserves: X/Y
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print
		JSR	print_one_space	; print	one space
					;
					; preserves: X/Y
		JSR	print_one_space	; print	one space
					;
					; preserves: X/Y

loc_8659:				; print	line number on screen
		LDX	#unk_85D7.print_line_number
		JSR	call_BASIC_routine ; entry: X =	index of routine to call
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

read_and_evaluate_expression:		
		JSR	determine_BASIC_version
		CMP	#0
		BEQ	loc_8682
		JSR	read_line_buffer ; read	input into line	buffer.	Max 40 chars
					;
					; exit:	Y = # chars read
		TYA
		PHA
		LDA	#$FF
		STA	byte_28
		LDA	#line_buffer
		STA	byte_19
		LDA	#0
		STA	byte_1A
		STA	byte_1B
		LDX	#unk_85D7.eval_expr
					
		JSR	call_BASIC_routine ; entry: X =	index of routine to call
		PLA
		RTS
; ---------------------------------------------------------------------------


loc_8682:				
		JSR	print_following_string_in_red

; ---------------------------------------------------------------------------
                .text 'BASIC?'
; ---------------------------------------------------------------------------
		NOP
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_Q:
		JSR	oswrch
		JSR	determine_BASIC_version
		CMP	#0
		BEQ	loc_8682
		LDX	#$FF
		TXS
		LDA	byte_24B	; ROM socket containing	BASIC (OSBYTE 187, AUG p195)
		STA	byte_28C	; current language ROM number (OSBYTE 252, AUG p243; OSBYTE 142, AUG p166)
		JSR	print_following_string
; ---------------------------------------------------------------------------
aBasic:		.text $16,7,'BASIC',$D,$D
; ---------------------------------------------------------------------------
		NOP
		LDY	BASIC_version	; version number of BASIC, or 0	if unknown/not present
		LDA	unk_85FF-1,Y
		STA	BRKV
		LDA	unk_85FF-1+num_basic_versions,Y
		STA	BRKV+1
		JSR	reset_WRCHV	; reset	WRCHV to default value
		LDX	#unk_85D7.prompt_and_execute
		JSR	prepare_BASIC_routine_call ; prepare for a call	to a routine in	BASIC.
					;
					; entry: X = index of routine to call
		LDA	workspace_code	; points to code region	in workspace, +$92
		STA	word_F2
		LDA	workspace_code+1 ; points to code region in workspace, +$92
		STA	word_F2+1
		JSR	swap_zp_and_workspaces
		LDY	#loc_8566-loc_8563
		LDA	#$4C 
		STA	(word_F2),Y
		JMP	(word_F2)
; ---------------------------------------------------------------------------

cmd_N:
		PHA
		LDA	#7
		JSR	oswrch
		PLA
		JSR	echo_and_readch	; print	char in	A, then	read character
					;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#$D
		BEQ	loc_86EA
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

loc_86EA:				
		JSR	init_basic
		JSR	swap_zp_and_workspaces
		JSR	workspace_setup_qqq
		JSR	swap_zp_and_workspaces
		JSR	reset_WRCHV	; reset	WRCHV to default value
		JMP	language

; --------------- S U B	R O U T	I N E ---------------------------------------


init_basic:				
		LDX	#$80 
		LDA	#0

loc_8700:				
		STA	$47F,X		; clear	BASIC varptrs
		DEX
		BNE	loc_8700
		JSR	swap_zp_and_workspaces
		LDA	#$83       ; read OSHWM - on exit, YX=OSHWM
		JSR	osbyte
		STY	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		STY	basic_LOMEM+1
		STY	basic_VARTOP+1
		STY	basic_TOP+1
		LDY	#0
		STY	basic_LOMEM
		LDA	#$D
		STA	(basic_LOMEM),Y
		INY
		LDA	#$FF
		STA	(basic_LOMEM),Y
		STA	byte_23
		INY
		STY	basic_LOMEM
		STY	basic_VARTOP
		STY	basic_TOP
		LDA	#$84       ; read HIMEM - on exit, YX=HIMEM
		JSR	osbyte
		STX	basic_stackptr
		STX	basic_HIMEM
		STY	basic_stackptr+1
		STY	basic_HIMEM+1
		JMP	swap_zp_and_workspaces



; --------------- S U B	R O U T	I N E ---------------------------------------

; initialize workspace pointer in ($f6)
;
; exit:	($f6) points to	workspace
;	Y=0
; preserves: A/X

init_workspace_pointer:			
					
		LDY	workspace_page_number ;	read OSBYTE $f0	flag
		BNE	loc_8746	; taken	if non-zero
		LDY	#5
		STY	workspace_page_number ;	initialize to $05 if not previously set

loc_8746:				
		STY	workspace_pointer+1
		LDY	#0
		STY	workspace_pointer
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; reset	WRCHV to default value

reset_WRCHV:				
		LDA	byte_FFCC	; read default entry point from	NVWRCH+1 and NVWRCH+2.
					; (Since NVWRCH	is jmp $xxxx...)
		STA	WRCHV
		LDA	byte_FFCD
		STA	WRCHV+1
		RTS


; ---------------------------------------------------------------------------

dec_word_B:				
		PHA			; decrement word_B
					;
					; preserves: A/X/Y
		LDA	word_B
		BNE	loc_8761
		DEC	word_B+1

loc_8761:				
		DEC	word_B
		PLA
		RTS

; --------------- S U B	R O U T	I N E ---------------------------------------

; read input into line buffer. Max 40 chars
;
; exit:	Y = # chars read

read_line_buffer:			
		LDY	#39

read_line_buffer_n:			
		STY	byte_8		; read input into line buffer.
					;
					; entry: Y = max chars
		LDY	#0

loc_876B:				
					
		JSR	getch

loc_876E:				
		CMP	#127
		BNE	loc_877C	; branch taken if not DELETE
		CPY	#0
		BEQ	loc_876B	; branch taken if at start of string - nothing to delete
		JSR	oswrch		; print	delete
		DEY			; move 1 char back
		BPL	loc_876B	; JMP, in effect

loc_877C:				
		BCS	loc_876B	; branch taken if input	char >=128
		CMP	#14
		BEQ	loc_8786	; branch taken if CTRL+N
		CMP	#15
		BNE	loc_8789	; branch taken if neither CTRL+O nor CTRL+N

loc_8786:				
		JSR	oswrch		; print	CTRL+O/CTRL+N char verbatim

loc_8789:				
		STA	line_buffer,Y
		CMP	#13
		BEQ	locret_879E	; branch taken if done
		CPY	byte_8
		BEQ	loc_876B	; branch taken if max line length hit -	no more	room
		CMP	#32
		BCC	loc_876B	; branch taken if control char - don't print these
		JSR	oswrch
		INY
		BPL	loc_876B	; JMP, in effect

locret_879E:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


disable_cursor_editing:			
		LDA	#4
		BNE	osbyte_x01



; --------------- S U B	R O U T	I N E ---------------------------------------


flush_input_buffer:			
					
		LDA	#15

osbyte_x01:				
		LDX	#1
		JMP	osbyte



; --------------- S U B	R O U T	I N E ---------------------------------------


flush_input_buffer_and_readch:		
		JSR	flush_input_buffer
		JMP	readch		; read character

					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y

; --------------- S U B	R O U T	I N E ---------------------------------------

; poll for SHIFT key status
;
; exit:	X>=$80 and C=1 if shift	was pressed
; preserves: A

poll_SHIFT:				
					
		PHA
		LDA	#121
		LDX	#128
		JSR	osbyte		; Keyboard scan	(AUG p144)
		PLA
		CPX	#$80 
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; check	if ESCAPE is pressed
;
; exit:	Z=1 if ESCAPE pressed

poll_ESCAPE:				
		LDX	#0
		LDY	#0
		LDA	#$81       ; read key within time limit (AUG p153)
		JSR	osbyte
		CPY	#$1B
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_87C8:				
		JSR	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		BNE	locret_8816	; branch taken if ESCAPE not pressed




acknowledge_ESCAPE_and_reset_cursor:	
		JSR	acknowledge_ESCAPE
		LDA	#0
		STA	byte_27D	; reset	cursor editing status
					; (OSBYTE 237, AUG p233; OSBYTE	4, AUG p120)
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop


; --------------- S U B	R O U T	I N E ---------------------------------------


acknowledge_ESCAPE:			
					
		LDA	#$7E 
		JMP	osbyte



; --------------- S U B	R O U T	I N E ---------------------------------------


getch:					

		JSR	osrdch
		CMP	#27
		BEQ	acknowledge_ESCAPE_and_reset_cursor ; branch taken if Escape pressed
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; print	char in	A, then	read character
;
; entry: A=char	to print
; exit:	A=char read, toupper
;	C=1 when symbol/digit
;	V=0 when symbol/digit/xdigit
; preserves: X/Y

echo_and_readch:			
		JSR	oswrch



; --------------- S U B	R O U T	I N E ---------------------------------------

; read character
;
; exit:	A=char,	toupper
;	C=1 when symbol/digit
;	V=0 when symbol/digit/xdigit
; preserves: X/Y

readch:					
					

; FUNCTION CHUNK AT 8815 SIZE 00000002 BYTES

		JSR	getch
		CMP	#127
		BEQ	locret_8816	; taken	if delete
		CLV
		CMP	#'0'
		BCC	loc_8807	; taken	if definitely not hex digit
		CMP	#':'
		BCC	is_digit	; taken	if digit
		CMP	#'@'
		BCC	loc_8807	; taken	if definitely not alpha	hex digit
		AND	#$DF       ; toupper
		CMP	#'A'
		BCC	loc_8807	; taken	if not alpha hex digit
		CMP	#'G'
		BCS	sub_880C	; taken	if not alpha hex digit
		RTS			; return with carry clear
; ---------------------------------------------------------------------------

loc_8807:				
		JSR	sub_880C
		SEC
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_880C:				
					; readch:loc_8807p
		PHA
		LDA	#$40 
		ADC	#$40 
		PLA
		CMP	#$5B ; '['
		RTS


; ---------------------------------------------------------------------------


is_digit:				
		SEC

locret_8816:				
		RTS


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8817:				
		JSR	read_address_qqq
		STA	word_B
		LDA	word_1C+1
		STA	word_B+1
		LDX	#0
		STX	basic_TOP+1
		ORA	word_B
		BEQ	loc_882A
		DEC	basic_TOP+1

loc_882A:				
		LDA	#']'
		JSR	echo_and_readch	; print	char in	A, then	read character
					;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'+'
		BNE	loc_8845
		JSR	oswrch
		JSR	sub_8870
		CLC
		ADC	word_B
		STA	byte_16
		LDA	word_1C+1
		ADC	word_B+1
		STA	byte_17
		RTS
; ---------------------------------------------------------------------------

loc_8845:				
		LDX	#3
		STX	byte_8
		LDX	#$FF
		JSR	loc_888E
		STA	byte_16
		LDA	word_1C+1
		STA	byte_17
		TXA
		BNE	locret_885D
		DEX
		STX	byte_16
		STX	byte_17
		INX

locret_885D:				
		RTS


; ---------------------------------------------------------------------------


loc_885E:				
		JSR	oswrch
		JSR	read_and_evaluate_expression
		LDA	unk_2B
		STA	word_1C+1
		LDA	basic_IWA	; (BASIC) IWA
		LDX	#1
		RTS


; --------------- S U B	R O U T	I N E ---------------------------------------


read_address_qqq:			
		JSR	print_char_then_one_space ; print char in A then print one space

					; preserves: X/Y

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8870:				
		LDX	#4
		JSR	loc_8885
		CPX	#0
		BNE	locret_8816
		LDA	reg_pc+1
		STA	word_1C+1
		LDA	reg_pc
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; read byte value??

sub_8880:				

; FUNCTION CHUNK AT 885E SIZE 0000000F BYTES

		JSR	print_char_then_one_space ; print char in A then print one space
					;
					; preserves: X/Y

loc_8883:				
		LDX	#2

loc_8885:				
		DEX
		STX	byte_8
		LDX	#0
		DEX

loc_888B:				
		JSR	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y

loc_888E:				
					
		CMP	#$D
		BEQ	loc_88B9
		CMP	#$7F 
		BEQ	loc_88AE
		BVC	loc_88A2
		CPX	#$FF
		BNE	loc_888B
		CMP	#$23 ; '#'
		BEQ	loc_885E
		BNE	loc_888B

loc_88A2:				
		INX
		STA	line_buffer,X
		JSR	oswrch
		CPX	byte_8
		BEQ	loc_88B9
		BNE	loc_888B

loc_88AE:				
		CPX	#$FF
		BEQ	loc_888B
		JSR	oswrch
		DEX
		JMP	loc_888B
; ---------------------------------------------------------------------------

loc_88B9:				
		INX
		BEQ	loc_88FA
		LDA	#$D
		STA	line_buffer,X
		LDA	#line_buffer
		STA	workspace_pointer
		LDA	#0
		STA	workspace_pointer+1
		LDY	#0

parse_hex:				
		LDA	#0
		STA	word_1C
		STA	word_1C+1

parse_hex_loop:				
		LDA	(workspace_pointer),Y
		CMP	#$D
		BEQ	loc_88F7	; taken	if end of input
		JSR	parse_xdigit	; parse	hex digit
					;
					; entry: A=(hopefully) hex digit
					; exit:	C=0, A=value if	A was valid
					;	C=1 if A invalid
		BCS	loc_88F7	; taken	if error
;shift word_1C left 4
		ASL	word_1C
		ROL	word_1C+1
		ASL	word_1C
		ROL	word_1C+1
		ASL	word_1C
		ROL	word_1C+1
		ASL	word_1C
		ROL	word_1C+1
		INY
;add in new digit
		CLC
		ADC	word_1C
		STA	word_1C
		BCC	parse_hex_loop
		INC	word_1C+1
		BNE	parse_hex_loop

loc_88F7:				
		LDA	word_1C
		RTS
; ---------------------------------------------------------------------------

loc_88FA:				
		LDA	#0
		STA	word_1C+1
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; print	char in	A then print one space
;
; preserves: X/Y

print_char_then_one_space:		
					
		JSR	oswrch

print_one_space:			
		LDA	#$20 ; ' '      ; print one space
					;
					; preserves: X/Y

loc_8904:				
		JMP	oswrch



; --------------- S U B	R O U T	I N E ---------------------------------------


print_backspace:			
					
		LDA	#$7F 
		BNE	loc_8904



; --------------- S U B	R O U T	I N E ---------------------------------------


print_cr:				
					
		LDA	#$D
		JMP	nvoswrch



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8910:				
					
		LDA	#$B
		BNE	loc_8904

print_39_spaces:			
		LDX	#38
		LDA	#$20 ; ' '

loc_8918:				
		JSR	nvoswrch
		DEX
		BPL	loc_8918
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_891F:				
					
		JSR	clear_line_buffer
		INX
		LDA	word_B+1
		JSR	store_hex_byte_in_line_buffer
		LDA	word_B



; --------------- S U B	R O U T	I N E ---------------------------------------


store_hex_byte_in_line_buffer:		
		STA	byte_8
		AND	#$F0 
		JSR	shr4_clc
		JSR	store_hex_nibble
		AND	#$F



; --------------- S U B	R O U T	I N E ---------------------------------------


store_hex_nibble:			
		ORA	#$30 
		CMP	#$3A 
		BCC	store
		ADC	#6

store:					
		STA	line_buffer,X
		INX
		LDA	byte_8
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


clear_line_buffer:			
					
		LDX	#39
		LDA	#32

loc_8948:				
		STA	line_buffer,X
		DEX
		BPL	loc_8948
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


shr5_clc:				
		LSR	A



; --------------- S U B	R O U T	I N E ---------------------------------------


shr4_clc:				
		LSR	A
		LSR	A
		LSR	A
		LSR	A
		CLC
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; get printable	version	of byte	- use '.' for unprintables
;
; entry: A = byte
; exit:	A = printable char

get_printable_char:			
					
		AND	#$7F 
		CMP	#32
		BCC	loc_895F
		CMP	#127
		BCC	locret_8961

loc_895F:				
		LDA	#'.'

locret_8961:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


swap_zp_and_workspaces:			
		PHP
		PHA
		TXA
		PHA
		TYA
		PHA
		LDA	word_F2
		PHA
		LDA	word_F2+1
		PHA
		LDX	#0
		STX	word_F2
		LDX	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		STX	word_F2+1	; (word_f2) = workspace	pointer
;swap $08-$8f ZP	with corresponding values in workspace
		LDY	#$8F 

loc_8979:				
		LDX	0,Y		; X=ZP value
		LDA	(word_F2),Y	; A=workspace value
		STA	0,Y		; store	workspace value	in ZP
		TXA
		STA	(word_F2),Y	; store	ZP value in workspace
		DEY
		CPY	#7
		BNE	loc_8979
		LDX	workspace_pointer
		LDY	#$F6 
		LDA	(word_F2),Y
		STA	workspace_pointer
		TXA
		STA	(word_F2),Y
		LDX	workspace_pointer+1
		INY
		LDA	(word_F2),Y
		STA	workspace_pointer+1
		TXA
		STA	(word_F2),Y
		LDY	#0
		LDA	(word_F2),Y
		EOR	#$FF
		STA	(word_F2),Y
		PLA
		STA	word_F2+1
		PLA
		STA	word_F2
		PLA
		TAY
		PLA
		TAX
		PLA
		PLP
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; write	memory
;
; entry: workspace_pointer?1 = address MSB
;	 Y = address LSB
;	 A = value to write

write_memory:				
		STY	workspace_pointer
		BIT	workspace_pointer+1 ; query workspace pointer MSB
		BPL	loc_89BE	; branch taken if <$8000 - in main RAM
		BVC	loc_89DC	; branch taken if <$C000 - in sideways RAM
		BIT	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		BVS	locret_89DB

loc_89BE:				
		CPY	#8
		BCC	write		; branch taken if address <$0008 - not in shadow ZP
		CPY	#$F6 
		BEQ	write_shadow_zp	; branch taken if address=$00f6	- in shadow ZP
		CPY	#$F7 
		BEQ	write_shadow_zp	; branch taken if address=$00f7	- in shadow ZP
		CPY	#$90 
		BCS	write		; branch taken if address>=$90 - not in	shadow ZP

write_shadow_zp:			
					; write_memory+16j
		LDY	workspace_pointer+1
		BNE	write		; branch taken if not ZP - existing address is fine
		LDY	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		STY	workspace_pointer+1 ; fix up address so	the write is to	shadow ZP

write:					
					
		LDY	#0
		STA	(workspace_pointer),Y

locret_89DB:				
		RTS
; ---------------------------------------------------------------------------

loc_89DC:				
		TAY
		TXA
		PHA
		LDA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		AND	#$F
		CMP	$f4
		BNE	loc_89EC
		PLA
		TAX
		LDY	#0
		RTS
; ---------------------------------------------------------------------------

loc_89EC:				
		LDX	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		LDA	workspace_code	; points to code region	in workspace, +$92
		PHA
		LDA	#loc_85A7-loc_8563+workspace.code
		STA	workspace_code	; points to code region	in workspace, +$92
		TYA
		LDY	#0
		JSR	sub_8A01
		PLA
		STA	workspace_code	; points to code region	in workspace, +$92
		PLA
		TAX
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8A01:				
		JMP	(workspace_code) ; points to code region in workspace, +$92



; --------------- S U B	R O U T	I N E ---------------------------------------

; read byte from memory
;
; entry: workspace_pointer=address
; exit:	A = byte read
; preserves: X

read_memory_workspace_pointer:		
					
		LDA	workspace_pointer



; --------------- S U B	R O U T	I N E ---------------------------------------

; read byte from memory
;
; entry: A=LSB
;	 workspace_pointer MSB=MSB
; exit:	A=byte read
; preserves: X

read_memory:				
					
		STA	workspace_pointer ; store address LSB
		LDY	workspace_pointer+1
		BNE	loc_8A29	; branch taken if not zero page
		CMP	#8
		BCC	loc_8A29	; branch taken if <$0008 - can read directly
		CMP	#workspace_pointer
		BEQ	loc_8A1C	; branch taken if workspace_pointer - must read	from workspace
		CMP	#workspace_pointer+1
		BEQ	loc_8A1C	; branch taken if workspace_pointer - must read	from workspace
		CMP	#$90 
		BCS	loc_8A29	; branch taken if >=$90	- can read directly

loc_8A1C:				
					; read_memory+10j
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		TAY
		LDA	(workspace_pointer),Y ;	fetch byte from	copy of	zero page
		STY	workspace_pointer ; update workspace_pointer with full address
		LDY	#0
		STY	workspace_pointer+1 ; MSB is 0 - it's zero page
		RTS
; ---------------------------------------------------------------------------

loc_8A29:				
					
		CPY	#$C0 
		BCS	loc_8A3B	; branch taken if MOS/IO
		CPY	#$80 
		BCC	loc_8A3F	; branch taken if paged	ROM

loc_8A31:				
		STX	byte_9
		LDY	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		JSR	osrdrm		; read byte from ROM/screen memory
					;
					; entry: ($f6) = address
					;	 Y = ROM number	(if address in ROM)
					; exit:	A = byte read
		LDX	byte_9
		RTS
; ---------------------------------------------------------------------------

loc_8A3B:				
		BIT	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		BVS	loc_8A31

loc_8A3F:				
		LDY	#0
		LDA	(workspace_pointer),Y
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; fetch	byte using read_memory with post-increment.
;
; entry: (word_B) - address to fetch from
; preserves: Y/C

fetch_memory:				
					
		STY	byte_8
		JSR	check_fetch_address
		PHP
		LDA	word_B+1
		STA	workspace_pointer+1
		LDA	word_B
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		INC	word_B
		BNE	loc_8A59
		INC	word_B+1

loc_8A59:				
		LDY	byte_8
		PLP
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; parse	hex digit
;
; entry: A=(hopefully) hex digit
; exit:	C=0, A=value if	A was valid
;	C=1 if A invalid

parse_xdigit:				
		CMP	#$47 ; 'G'
		BCS	done_with_carry_set ; taken if >'F'
		CMP	#$30 ; '0'
		BCC	done_with_carry_set ; taken if <'0'
		CMP	#$3A ; ':'
		BCC	is_xdigit	; taken	if <='9'
		CMP	#$41 ; 'A'
		BCC	done_with_carry_set ; taken if <'A'

is_xdigit:				
		SEC
		SBC	#$30 ; '0'      ; get value assuming digit
		CMP	#$A		; was it actually alpha?
		BCC	done		; branch taken if digit	- exit with C=0
		SBC	#7		; adjust

done_with_carry_clear:			
		CLC

done:					
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


check_fetch_address:			
		LDA	word_B
		ORA	word_B+1
		BNE	loc_8A84	; branch taken if address non-zero
		BIT	basic_TOP+1
		BMI	done_with_carry_set
		DEC	basic_TOP+1

loc_8A84:				
		LDA	word_B+1
		CMP	byte_17
		BCC	done_with_carry_clear
		BNE	done_with_carry_set
		LDA	byte_16
		CMP	word_B
		BCS	done_with_carry_clear

done_with_carry_set:			
					
		SEC
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; print	up to 40 chars from line buffer

print_entire_line_buffer:		
					
		LDX	#40



; --------------- S U B	R O U T	I N E ---------------------------------------

; print	CR-terminated line buffer contents.
;
; entry: X = max # chars to print

print_line_buffer:			
		STX	byte_8
		LDX	#0

loc_8A9A:				
		LDA	line_buffer,X
		JSR	oswrch
		INX
		CPX	byte_8
		BCS	locret_8AA8
		CMP	#$D
		BNE	loc_8A9A

locret_8AA8:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8AA9:				
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		ORA	#1
		STA	basic_PAGE	; (BASIC) MSB of PAGE

					;	  bit 7	= printer on/off

; --------------- S U B	R O U T	I N E ---------------------------------------


set_output_text_window_and_cls:		
		JSR	set_output_text_window
		LDA	#12		; CLS
		BNE	call_NVOSWRCH	; JMP, in effect



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8AB6:				
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		AND	#$80 
		STA	basic_PAGE
                ; (BASIC) MSB of PAGE
                ; (Exmon) flag indicating which	text window is active???
                ;	  bit 7	= printer on/off

; --------------- S U B	R O U T	I N E ---------------------------------------


set_output_text_window:			
		LDX	byte_62		; height of panel???
		INX
		INX
		INX
		LDY	#4
		JSR	set_text_window	; set text window from (0,y)-(39,x)



; --------------- S U B	R O U T	I N E ---------------------------------------


hide_cursor:				
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 23
		.byte 1
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0


; ---------------------------------------------------------------------------
		NOP
		RTS

; --------------- S U B	R O U T	I N E ---------------------------------------


set_command_line_text_window:		
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		ORA	#1
		STA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		LDX	#24
		LDA	num_breakpoints
		BEQ	loc_8AE7
;allocate space for breakpoints display
		DEX
		CMP	#6
		BCC	loc_8AE7
		DEX

loc_8AE7:				
					; set_command_line_text_window+Fj
		LDA	byte_62		; height of panel???
		PHA
		CLC
		ADC	#5
		TAY
		PLA
		BNE	set_text_window	; set text window from (0,y)-(39,x)
		DEY



; --------------- S U B	R O U T	I N E ---------------------------------------

; set text window from (0,y)-(39,x)

set_text_window:			
					
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte  28		; 0
		.byte 0
; ---------------------------------------------------------------------------
		NOP
		TXA
		JSR	nvoswrch
		LDA	#39
		JSR	nvoswrch
		TYA

call_NVOSWRCH:				
		JMP	nvoswrch



; --------------- S U B	R O U T	I N E ---------------------------------------


print_newline_then_following_string_in_red: 
					
		JSR	osnewl



; --------------- S U B	R O U T	I N E ---------------------------------------


print_following_string_in_red:		
					
		LDA	#129
		JSR	oswrch
		JMP	print_following_string


; ---------------------------------------------------------------------------
		JSR	osnewl

; --------------- S U B	R O U T	I N E ---------------------------------------


print_following_string:			
		PLA
		STA	word_1C
		PLA
		STA	word_1C+1
		TYA
		PHA
		LDY	#0
		TYA

loc_8B1E:				
		JSR	handle_OSWRCH
		CMP	#$D
		BNE	loc_8B29
		LDA	#$A
		BNE	loc_8B1E

loc_8B29:				
		INC	word_1C
		BNE	loc_8B2F
		INC	word_1C+1

loc_8B2F:				
		LDA	(word_1C),Y
		CMP	#$EA 
		BNE	loc_8B1E
		PLA
		TAY
		JMP	(word_1C)


; ---------------------------------------------------------------------------
		STX	byte_19
		STY	byte_1A
		LDA	#0
		STA	byte_1B
		LDX	#unk_85D7.eval_expr

; --------------- S U B	R O U T	I N E ---------------------------------------

; entry: X = index of routine to call

call_BASIC_routine:			
		JSR	prepare_BASIC_routine_call ; prepare for a call	to a routine in	BASIC.
					;
					; entry: X = index of routine to call
		JMP	(workspace_code) ; points to code region in workspace, +$92



; --------------- S U B	R O U T	I N E ---------------------------------------

; Print	char from BASIC	error message.
; Some info about BASIC	error message encoding:	http://8bs.com/basic/errormess.htm

sub_8B4A:				
		CMP	#141
		BNE	loc_8B65	; branch taken if not CHR$141
		LDX	byte_24A	; ROM active at	last BRK (OSBYTE 186, AUG p194)
		CPX	byte_24B	; ROM socket containing	BASIC (OSBYTE 187, AUG p195)
		BNE	loc_8B65	; branch taken if not BASIC
		LDX	#0

loc_8B58:				
		LDA	aMissing,X	; "Missing"
		JSR	oswrch
		INX
		CPX	#7
		BCC	loc_8B58
		LDA	#$20 

loc_8B65:				
		JMP	osasci


; ---------------------------------------------------------------------------
aMissing:	.text 'Missing'         
; ---------------------------------------------------------------------------

BRK_handler:
		LDA	byte_FD
		STA	workspace_pointer
		LDA	byte_FE
		STA	workspace_pointer+1
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
		.text ' '
; ---------------------------------------------------------------------------
		NOP

loc_8B7C:				
		INC	workspace_pointer
		BNE	loc_8B82
		INC	workspace_pointer+1

loc_8B82:				
		LDY	byte_24A	; ROM active at	last BRK (OSBYTE 186, AUG p194)
		JSR	osrdrm		; read byte following BRK
		ORA	#0
		BEQ	loc_8B92	; branch taken if end of message
		JSR	sub_8B4A	; Print	char from BASIC	error message.
					; Some info about BASIC	error message encoding:	http://8bs.com/basic/errormess.htm
		JMP	loc_8B7C
; ---------------------------------------------------------------------------

loc_8B92:				
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		LDA	#0
		STA	workspace_pointer
		TAY
		LDA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		STA	workspace_pointer+1
		LDA	(workspace_pointer),Y
		BEQ	loc_8BA6
		JSR	swap_zp_and_workspaces

loc_8BA6:				
		LDA	byte_21
		BEQ	loc_8BD9
		JMP	loc_906B
; ---------------------------------------------------------------------------


handle_star:				
		JSR	oswrch
		JSR	read_line_buffer ; read	input into line	buffer.	Max 40 chars
					;
					; exit:	Y = # chars read
		JSR	print_cr
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JSR	reset_WRCHV	; reset	WRCHV to default value
		JSR	set_output_text_window_and_cls
		JSR	show_cursor
		BIT	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		BPL	loc_8BCB
		LDA	#2
		JSR	oswrch

loc_8BCB:				
		JSR	swap_zp_and_workspaces
		LDX	#$68 
		LDY	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		JSR	oscli
		JSR	swap_zp_and_workspaces

loc_8BD9:				
		LDA	#3
		JSR	oswrch
		JSR	install_OSWRCH_handler
		JMP	loc_A3F4


; --------------- S U B	R O U T	I N E ---------------------------------------


handle_OSWRCH:				
		PHA
		TYA
		PHA
		TXA
		PHA
		TSX			; $101,x = X
					; $102,x = Y
					; $103,x = A
		LDA	$103,X
		PHA
		LDA	byte_52
		BEQ	loc_8BF6
		DEC	byte_52
		BPL	loc_8C32

loc_8BF6:				
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		CMP	#$81 
		BNE	loc_8C32
		PLA
		PHA
		CMP	#$7F 
		BEQ	loc_8C32
		CMP	#$D
		BEQ	loc_8C17
		CMP	#$11
		BCC	loc_8C32
		CMP	#$20 
		BCS	loc_8C17
		TAX
		LDA	num_vdu_parameters - $11,X ; # parameters for VDU commands, starting at	VDU 17
		STA	byte_52
		JMP	loc_8C32
; ---------------------------------------------------------------------------

loc_8C17:				
					; handle_OSWRCH+28j
		LDA	#3
		LDX	#$A
		JSR	osbyte
		PLA
		PHA
		CMP	#$80 
		BCC	loc_8C26
		LDA	#$20 

loc_8C26:				
		JSR	nvoswrch
		CMP	#$D
		BNE	loc_8C32
		LDA	#$A
		JSR	nvoswrch

loc_8C32:				
					
		LDA	#3
		LDX	#0
		JSR	osbyte
		PLA
		PLA
		TAX
		PLA
		TAY
		PLA



; --------------- S U B	R O U T	I N E ---------------------------------------

; Attributes: thunk

nvoswrch:				
					
		JMP	unk_FFCB


; ---------------------------------------------------------------------------

wrch_8c42:
		PHA
		TYA
		PHA
		TXA
		PHA
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#$20 
		LDA	(workspace_pointer),Y
		BNE	loc_8C57
		JSR	set_output_text_window_and_cls
		LDY	#$20 
		STA	(workspace_pointer),Y

loc_8C57:				
		LDY	#1
		LDA	(workspace_pointer),Y
		BEQ	loc_8C64	; taken	if not buffering in VDU	queue
		SEC
		SBC	#1
		STA	(workspace_pointer),Y
		BPL	loc_8C92

loc_8C64:				
		TSX
		LDA	$103,X		; fetch	char to	print
		CMP	#7
		BEQ	pass_on_to_OSWRCH
		CMP	#10
		BEQ	pass_on_to_OSWRCH
		CMP	#13
		BEQ	pass_on_to_OSWRCH
		CMP	#17
		BCC	loc_8C92	; taken	if <17 - these codes have 0 parameters
					; (except for VDU1! - a	bug?)
		CMP	#127
		BEQ	loc_8C92	; skip 127s
		CMP	#32
		BCS	pass_on_to_OSWRCH ; print >=32
		TAX
		LDA	num_vdu_parameters - $11,X ; # parameters for VDU commands, starting at	VDU 17
		LDY	#1

loc_8C86:
		STA	(workspace_pointer),Y
		BPL	loc_8C92

pass_on_to_OSWRCH:			
		PLA
		TAX
		PLA
		TAY
		PLA
		JMP	handle_OSWRCH
; ---------------------------------------------------------------------------

loc_8C92:				
		PLA
		TAX
		PLA
		TAY
		PLA
		RTS
; ---------------------------------------------------------------------------
num_vdu_parameters:.byte   1,  2,  5,  0,  0,  1,  9,  8; 0 
					; RAM:8C81r
		.byte	5,  0,	0,  4,	4,  0,	2; 8 ; # parameters for	VDU commands, starting at VDU 17

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8CA7:				
		STA	reg_a
		STX	reg_x
		STY	reg_y
		PHP
		PLA
		STA	reg_p
		CLI
		CLD
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#2
		LDA	byte_254	; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
		STA	(workspace_pointer),Y
		LDA	byte_258	; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
		INY
		STA	(workspace_pointer),Y
		LDA	byte_27C	; character destination	status (OSBYTE 236, AUG	p232)
		INY
		STA	(workspace_pointer),Y
		LDA	byte_27D	; cursor editing status	(OSBYTE	237, AUG p233)
		INY
		STA	(workspace_pointer),Y
		LDA	byte_241	; input	source (OSBYTE 177, AUG	p186)
		INY
		STA	(workspace_pointer),Y
		LDA	#0
		STA	byte_241	; input	source (OSBYTE 177, AUG	p186)
		STA	byte_258	; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
		STA	byte_27C	; character destination	status (OSBYTE 236, AUG	p232)
		LDA	#50
		STA	byte_254	; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
		JSR	install_OSWRCH_handler
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVS	loc_8CF2
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 6,3
; ---------------------------------------------------------------------------
		NOP

loc_8CF2:				
		LDA	#<BRK_handler
		STA	BRKV
		LDA	#>BRK_handler
		STA	BRKV+1
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


install_OSWRCH_handler:			
		LDA	#<handle_OSWRCH
		STA	XWRCHV
		LDA	#>handle_OSWRCH
		STA	XWRCHV+1
		LDA	$f4
		STA	XWRCHV+2
		LDA	#$15
		STA	WRCHV
		LDA	#$FF
		STA	WRCHV+1
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


print_register_values:			
		JSR	clear_line_buffer
		LDA	reg_a
		LDX	#0
		JSR	store_hex_byte_in_line_buffer ;	print A
		LDA	reg_x
		INX
		JSR	store_hex_byte_in_line_buffer ;	print X
		LDA	reg_y
		INX
		JSR	store_hex_byte_in_line_buffer ;	print Y
		LDA	reg_s
		INX
		JSR	store_hex_byte_in_line_buffer ;	print S
		LDA	reg_p
		INX
		JSR	store_hex_byte_in_line_buffer ;	print P	(as hex)
		LDX	#6
		STA	byte_8		; save temp copy of P

loc_8D3D:				
		CPX	#1
		BNE	loc_8D43
		LSR	byte_8

loc_8D43:				
		LSR	byte_8
		BCC	loc_8D4C
		LDA	p_bit_names,X	; "NVBDIZC"
		STA	line_buffer+$F,X

loc_8D4C:				
		DEX
		BPL	loc_8D3D
		LDA	reg_pc+1
		LDX	#23
		JSR	store_hex_byte_in_line_buffer ;	print PC MSB
		LDA	reg_pc
		JMP	store_hex_byte_in_line_buffer ;	print PC LSB


; ---------------------------------------------------------------------------
p_bit_names:	.text 'NVBDIZC'         
; ---------------------------------------------------------------------------

cmd_I:					; print	char in	A, then	read character
		JSR	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'S'
		BEQ	cmd_IS		; taken	if command is IS - set S
		CMP	#'P'
		BEQ	cmd_IP		; taken	if command is IP - set P
		LDX	#1
		STX	byte_9
		LDX	#6

loc_8D73:				
		CPX	#1
		BNE	loc_8D79
		ASL	byte_9

loc_8D79:				
		CMP	p_bit_names,X	; "NVBDIZC"
		BEQ	loc_8D89
		ASL	byte_9
		DEX
		BPL	loc_8D73


backspace_then_command_line_input_loop:	
		JSR	print_backspace
		JMP	command_line_input_loop	; also handler for U command

; ---------------------------------------------------------------------------

loc_8D89:				
		JSR	oswrch
		LDA	reg_p
		EOR	byte_9
		STA	reg_p
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_IS:					
		JSR	sub_8880	; read byte value??
		CPX	#0
		BNE	loc_8D9E
		LDA	#$FF

loc_8D9E:				
		CMP	#$6F 
		BCS	loc_8DA5
		JMP	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_8DA5:				
		STA	reg_s
		BCS	loc_8DAE

cmd_IP:					
		JSR	sub_8880	; read byte value??
		STA	reg_p

loc_8DAE:				
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop

; --------------- S U B	R O U T	I N E ---------------------------------------


command_line_window_osnewl:		
		JSR	set_command_line_text_window_and_restore_cursor
		JSR	osnewl



; --------------- S U B	R O U T	I N E ---------------------------------------

; update cursor	pos in cursor_x/cursor_y

update_cursor_pos:			
		LDA	#134
		JSR	osbyte
		STX	cursor_x
		STY	cursor_y
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; update cursor	pos in cursor_x_2/cursor_y_2

update_cursor_pos_2:			
		LDA	#134
		JSR	osbyte
		STX	cursor_x_2
		STY	cursor_y_2
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


show_cursor:				
					
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 23
		.byte 1			; cursor control
		.byte 1			; make cursor reappear
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 0


; ---------------------------------------------------------------------------
		NOP
		RTS

; --------------- S U B	R O U T	I N E ---------------------------------------


set_command_line_text_window_and_restore_cursor: ; CODE	XREF: command_line_window_osnewlp
					
		JSR	set_command_line_text_window
		JSR	show_cursor
		LDA	#31
		JSR	oswrch
		LDA	cursor_x
		JSR	oswrch
		LDA	cursor_y
		JMP	oswrch


; ---------------------------------------------------------------------------

cmd_H:
		JSR	oswrch
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		EOR	#$80 
		STA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

draw_panel:				
		JSR	sub_8AB6
		JSR	print_following_string
; ---------------------------------------------------------------------------
; window (0.0)-(39,3)
		.byte 28
		.byte 0
		.byte 3
		.byte 39
		.byte 0
; yellow
		.byte 131
; ---------------------------------------------------------------------------
		NOP
		JSR	hide_cursor
		JSR	clear_line_buffer
		LDX	#0
		LDA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		JSR	store_hex_byte_in_line_buffer
		INX
		INX
		LDA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		JSR	store_hex_byte_in_line_buffer
		LDA	#'!'
		STA	line_buffer+3
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print
		LDA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		AND	#$9E 
		STA	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		LDA	#' '
		BIT	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		BPL	loc_8E32
		LDA	#136		; flashing

loc_8E32:				
		JSR	oswrch
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 130		; green
		.text 'EXMON II by Beebugsoft '
		.byte 137		; flash	off
		.byte 131		; yellow
; ---------------------------------------------------------------------------
		NOP
		JSR	clear_line_buffer
		LDX	#1
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_8E72
		LDA	byte_25
		JSR	store_hex_byte_in_line_buffer
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		LSR	A
		BCS	loc_8E6A
		LDA	#'C'
		STA	line_buffer+4

loc_8E6A:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BMI	loc_8E72
		LDA	#'P'
		STA	line_buffer+5

loc_8E72:				
		LDX	#6
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print
		JSR	print_following_string
; ---------------------------------------------------------------------------
aAXYSPFlagsPc:	.text 'A  X  Y  S  P  flags   PC'
		.byte 31
		.byte 29
		.byte 1
aStack:		.text 'stack'
		.byte 13
; ---------------------------------------------------------------------------
		NOP
		JSR	print_register_values
		LDY	reg_s
		LDX	#$1D

loc_8EA4:				
		INY
		BEQ	loc_8EB2	; branch taken when out	of stack
		LDA	$100,Y		; fetch	stack byte
		JSR	store_hex_byte_in_line_buffer ;	print it
		INX
		CPX	#39		; 40 columns in	Mode 7...
		BCC	loc_8EA4	; branch taken if line width not exceeded

loc_8EB2:				
		JSR	print_entire_line_buffer ; print up to 40 chars	from line buffer
		LDX	num_breakpoints
		BEQ	locret_8F12
		LDY	#24
		CPX	#6
		BCC	loc_8EC0
		DEY

loc_8EC0:				
		LDX	#24
		JSR	set_text_window	; set text window from (0,y)-(39,x)
		JSR	print_following_string
; ---------------------------------------------------------------------------
aBrks:		.text 'BRKs :'
		.byte 134		; cyan
; ---------------------------------------------------------------------------
		NOP
		LDY	#0
		JSR	clear_line_buffer
		LDX	#0

loc_8ED7:				
		LDA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		JSR	store_hex_byte_in_line_buffer
		LDA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		JSR	store_hex_byte_in_line_buffer
		INX
		INY
		CPY	num_breakpoints
		BCS	loc_8F13
		CPY	#5
		BCC	loc_8ED7
		LDX	#25
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print
		JSR	clear_line_buffer
		LDX	#6

loc_8EF5:				
		LDA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		JSR	store_hex_byte_in_line_buffer
		LDA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		JSR	store_hex_byte_in_line_buffer
		INX
		INY
		CPY	num_breakpoints
		BCC	loc_8EF5
		JSR	osnewl
		LDX	#$1F
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 134		; cyan
; ---------------------------------------------------------------------------
		NOP

loc_8F0F:				
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print

locret_8F12:				
		RTS
; ---------------------------------------------------------------------------

loc_8F13:				
		LDX	#$19
		BNE	loc_8F0F


handle_exclamation:			
		JSR	sub_8880	; read byte value??
		STA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop


; --------------- S U B	R O U T	I N E ---------------------------------------


cmd_A:
		JSR	sub_8880	; read byte value??
		STA	reg_a
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop


; ---------------------------------------------------------------------------

cmd_X:					; read byte value??
		JSR	sub_8880
		STA	reg_x
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_Y:					; read byte value??
		JSR	sub_8880
		STA	reg_y
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_at:					; set PC
		JSR	sub_8F49
		CPX	#0
		BNE	loc_8F46
		LDA	byte_5E
		STA	reg_pc
		LDA	byte_5F
		STA	reg_pc+1

loc_8F46:				
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8F49:				
		JSR	read_address_qqq
		STA	reg_pc
		LDA	word_1C+1
		STA	reg_pc+1
		RTS


; ---------------------------------------------------------------------------

cmd_P:
		JSR	read_address_qqq
		STX	byte_60
		STA	byte_5C
		STA	byte_5E
		LDA	word_1C+1
		STA	byte_5D
		STA	byte_5F
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_W:					; print	char in	A, then	read character
		JSR	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'I'
		BEQ	cmd_WI
		CMP	#'S'
		BEQ	cmd_WS		; undocumented?
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_WI:					
		JSR	sub_8880	; read byte value??
		CPX	#0
		BEQ	loc_8F8A
		CMP	#2

loc_8F7C:
		BCC	loc_8F82
		CMP	#18
		BCC	loc_8F85

loc_8F82:				
		JMP	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_8F85:				
		STA	byte_62		; height of panel???

loc_8F87:				
		JMP	loc_8269
; ---------------------------------------------------------------------------

loc_8F8A:				
		LDA	#14
		STA	byte_62		; height of panel???
		BNE	loc_8F87

cmd_WS:					
		JSR	sub_8880	; read byte value??
		JSR	check_workspace_page ; check workspace page is valid.
					;
					; entry: A=workspace page
					; exit:	C=0 if valid, C=1 if invalid
		BCC	loc_8F9E

error_then_command_line_loop:		
		JSR	loc_A019
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

loc_8F9E:				
		STA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		STA	workspace_pointer+1
		LDA	workspace_code	; points to code region	in workspace, +$92
		PHA
		LDA	#0
		STA	workspace_pointer
		STA	workspace_code	; points to code region	in workspace, +$92
		LDY	#$FF

loc_8FAE:				
		LDA	(workspace_code),Y ; points to code region in workspace, +$92
		STA	(workspace_pointer),Y
		DEY
		CPY	#$FF
		BNE	loc_8FAE
		LDA	workspace_pointer+1
		LDY	#loc_8563+2-loc_8563+workspace.code
		STA	(workspace_pointer),Y ;	update jsr $ww9c
		LDY	#loc_8584+2-loc_8563+workspace.code
		STA	(workspace_pointer),Y ;	update jsr $wwca
		LDY	#loc_8595+2-loc_8563+workspace.code
		STA	(workspace_pointer),Y ;	update jsr $wwca
		LDY	#loc_85a7+2-loc_8563+workspace.code
		STA	(workspace_pointer),Y ;	update jsr $ww9f
		LDY	#loc_85AC+2-loc_8563+workspace.code
		STA	(workspace_pointer),Y ;	update jmp $ww98
		STA	workspace_code+1 ; points to code region in workspace, +$92
		STA	word_4A+1	; pointer to breakpoint	address	LSBs
		STA	word_4C+1	; pointer to breakpoint	address	MSBs
		STA	word_4E+1
		PLA
		STA	workspace_code	; points to code region	in workspace, +$92

loc_8FD8:				; redraw panel,	print ?, do command line input loop
		JMP	command_line_loop_2
; ---------------------------------------------------------------------------

cmd_O:					; print	char in	A, then	read character
		JSR	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'B'
		BEQ	CMD_OB_or_OW
		CMP	#'W'
		BEQ	CMD_OB_or_OW
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

CMD_OB_or_OW:				
		JSR	oswrch
		JSR	sub_8FF2
		JMP	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_8FF2:				
		STA	byte_9		; save command type
		LDA	#0
		JSR	sub_8880	; read byte value??
		PHA
		LDA	#0
		JSR	sub_8880	; read byte value??
		PHA
		LDA	#0
		JSR	sub_8880	; read byte value??
		TAY
		LDA	#$20 
		JSR	print_char_then_one_space ; print char in A then print one space
					;
					; preserves: X/Y
		JSR	clear_line_buffer
		PLA
		TAX
		LDA	byte_9
		CMP	#'B'
		BEQ	OB_or_OW

cmd_OW:
		PLA
		JSR	osword
		JMP	loc_9021
; ---------------------------------------------------------------------------

OB_or_OW:				
		PLA
		JSR	osbyte

loc_9021:				
		PHA
		TXA
		LDX	#3
		JSR	store_hex_byte_in_line_buffer
		INX
		TYA
		JSR	store_hex_byte_in_line_buffer
		LDX	#0
		PLA
		JSR	store_hex_byte_in_line_buffer
		LDX	#8
		JMP	print_line_buffer ; print CR-terminated	line buffer contents.

					; entry: X = max # chars to print

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9038:				

; FUNCTION CHUNK AT 8682 SIZE 00000003 BYTES

		STA	byte_21
		JSR	set_command_line_text_window_and_restore_cursor
		JSR	determine_BASIC_version
		CMP	#0
		BNE	locret_9047
		JMP	loc_8682
; ---------------------------------------------------------------------------

locret_9047:				
		RTS


; ---------------------------------------------------------------------------

loc_9048:				
		JSR	sub_9038
		LDA	byte_5E
		STA	basic_P		; value	of P%
		LDA	byte_5F
		STA	basic_P+1	; value	of P%


loc_9055:				
		LDA	#$FF
		STA	byte_57		; panel	status,	hex/disassembly???
		LDA	byte_5E
		STA	byte_14
		LDA	byte_5F
		STA	byte_15
		LDA	basic_P		; value	of P%
		STA	byte_5E
		LDA	basic_P+1	; value	of P%
		STA	byte_5F

loc_906B:				
		JSR	sub_A35C
		JSR	command_line_window_osnewl
		LDA	basic_P		; value	of P%
		STA	word_B
		LDA	basic_P+1	; value	of P%
		STA	word_B+1
		JSR	sub_891F
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print
		LDA	#$3A ; ':'
		JSR	print_char_then_one_space ; print char in A then print one space
					;
					; preserves: X/Y
		JSR	flush_input_buffer
		JSR	getch
		CMP	#key_toggle_mode
		BNE	loc_9093
		JMP	loc_A442
; ---------------------------------------------------------------------------

loc_9093:				
		CMP	#$87 
		BNE	loc_909A
		JMP	loc_9175
; ---------------------------------------------------------------------------

loc_909A:				
		CMP	#$8A 
		BNE	loc_90A1
		JMP	loc_9144
; ---------------------------------------------------------------------------

loc_90A1:				
		CMP	#$8B 
		BNE	loc_90A8
		JMP	loc_9120
; ---------------------------------------------------------------------------

loc_90A8:				
		LDY	#$27 
		STY	byte_8
		LDY	#0
		JSR	loc_876E
		LDA	#$F
		JSR	oswrch
		CPY	#0
		BEQ	loc_9112
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		LDA	#line_buffer
		STA	word_B
		LDA	#0
		STA	word_B+1
		LDA	#0
		STA	byte_A
		LDA	#6
		STA	byte_28
		BIT	basic_P+1	; value	of P%
		BPL	loc_90D8
		BVC	loc_90D8
		BIT	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		BVS	loc_910C

loc_90D8:				
					; sub_A4C8-13F6j
		LDA	basic_O		; value	of O%
		PHA
		LDA	basic_O+1	; value	of O%
		PHA
		LDA	basic_P		; value	of P%
		STA	basic_O		; value	of O%
		LDA	basic_P+1	; value	of P%
		STA	basic_O+1	; value	of O%
		BNE	loc_90FF
		LDA	basic_P		; value	of P%
		CMP	#8
		BCC	loc_90FF
		CMP	#$90 
		BCS	loc_90FF
		LDA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		STA	basic_O+1	; value	of O%

loc_90FF:				
					
		LDX	#unk_85D7.assemble
		JSR	call_BASIC_routine ; entry: X =	index of routine to call
		PLA
		STA	basic_O+1	; value	of O%
		PLA
		STA	basic_O		; value	of O%

loc_910C:				
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	loc_906B
; ---------------------------------------------------------------------------

loc_9112:				
		INC	basic_P		; value	of P%
		BNE	loc_911A
		INC	basic_P+1	; value	of P%

loc_911A:				
		JSR	sub_8910
		JMP	loc_910C
; ---------------------------------------------------------------------------

loc_9120:				
		JSR	poll_SHIFT	; poll for SHIFT key status
					;
					; exit:	X>=$80 and C=1 if shift	was pressed
					; preserves: A
		BCS	loc_9133
		LDA	basic_P		; value	of P%
		BNE	loc_912D
		DEC	basic_P+1	; value	of P%

loc_912D:				
		DEC	basic_P		; value	of P%
		JMP	loc_9175
; ---------------------------------------------------------------------------

loc_9133:				
		SEC
		LDA	basic_P		; value	of P%
		SBC	#$10
		STA	basic_P		; value	of P%
		BCS	loc_9141
		DEC	basic_P+1	; value	of P%

loc_9141:				
		JMP	loc_9175
; ---------------------------------------------------------------------------

loc_9144:				
		JSR	poll_SHIFT	; poll for SHIFT key status
					;
					; exit:	X>=$80 and C=1 if shift	was pressed
					; preserves: A
		BCS	loc_916B
		LDA	byte_5F
		STA	workspace_pointer+1
		LDA	byte_5E
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		JSR	get_instruction_operand_size ; get size	of instruction operand bytes
					;
					; entry: A = opcode
					; exit:	C=0 if valid, then A = # bytes
					;	C=1 if invalid
		TAY
		INY			; increment to include opcode
		TYA
		BCC	loc_915C	; branch taken if instruction was valid
		LDA	#1		; 1 byte for invalid instructions

loc_915C:				
		CLC
		ADC	basic_P		; value	of P%
		STA	basic_P		; value	of P%
		BCC	loc_9168
		INC	basic_P+1	; value	of P%

loc_9168:				
		JMP	loc_9175
; ---------------------------------------------------------------------------

loc_916B:				
		LDA	byte_16
		STA	basic_P		; value	of P%
		LDA	byte_17
		STA	basic_P+1	; value	of P%

loc_9175:				
					
		JSR	sub_8910
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	loc_9055


; --------------- S U B	R O U T	I N E ---------------------------------------


disassemble_instruction_and_print:	
		JSR	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		JMP	print_entire_line_buffer ; print up to 40 chars	from line buffer



; --------------- S U B	R O U T	I N E ---------------------------------------

; fill line buffer with	disassembly of instruction at (word_B)

disassemble_instruction:		
					

; FUNCTION CHUNK AT 91FF SIZE 00000059 BYTES

		JSR	sub_891F
		LDX	#5
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		JSR	store_hex_byte_in_line_buffer
		PHA
		JSR	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		STA	line_buffer+$E
		PLA
		JSR	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		LDX	#$17
		BCC	loc_91A7	; branch taken if instruction invalid?
;disassemble invalid instruction	as "???"
		LDA	#'?'
		STA	line_buffer+$14
		STA	line_buffer+$15
		STA	line_buffer+$16
		BNE	loc_91D5	; JMP, in effect

loc_91A7:				
		TAY
		LDA	mnemonics,Y	; "BVSTYADCLDANDECLCLINXRTSBCSECLVJSROROLD"...
		STA	line_buffer+$14
		LDA	mnemonics+1,Y
		STA	line_buffer+$15
		LDA	mnemonics+2,Y
		STA	line_buffer+$16
		LDX	#$18
		LDA	byte_D		; get addressing mode info
		AND	#$3F       ; mask out addrmode_strings offset
		TAY			; Y=addrmode_strings offset

loc_91BE:				
					
		LDA	addrmode_strings,Y ; "A"
		BEQ	loc_91D5	; branch taken if addrmode string done
		INY
		CMP	#' '
		BEQ	do_byte		; print	hex byte
		CMP	#'!'
		BEQ	do_word		; print	hex word
		CMP	#'?'
		BEQ	loc_9230
		STA	line_buffer,X
		INX
		BPL	loc_91BE

loc_91D5:				
					; disassemble_instruction+3Dj
		LDA	#$D
		STA	line_buffer+$27
		LDA	#134
		STA	line_buffer+4
		LDA	#131
		STA	line_buffer+$D
		LDA	#130
		STA	line_buffer+$13
		RTS
; ---------------------------------------------------------------------------

do_byte:				
		LDA	#'&'
		STA	line_buffer,X
		INX
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		JSR	store_hex_byte_in_line_buffer
		JSR	store_instruction_char_1
		JMP	store_hex_dump_byte_1



; --------------- S U B	R O U T	I N E ---------------------------------------


store_instruction_char_1:		
		PHA
		JSR	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		STA	line_buffer+$F
		PLA
		RTS


; ---------------------------------------------------------------------------


do_word:				
		JSR	fetch_memory	; fetch	LSB
		JSR	store_instruction_char_1
		PHA			; save LSB
		LDA	#'&'
		STA	line_buffer,X
		INX
		JSR	fetch_memory	; fetch	MSB
		JSR	store_hex_byte_in_line_buffer ;	print MSB hex as part of instruction
		PHA			; save MSB
		JSR	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		STA	line_buffer+$10	; store	MSB char
		PLA			; restore MSB
		STX	byte_9
		LDX	#11
		JSR	store_hex_byte_in_line_buffer ;	print MSB hex as part of hex dump
		LDX	byte_9
		PLA			; restore LSB
		JSR	store_hex_byte_in_line_buffer ;	print LSB hex as part of instruction

store_hex_dump_byte_1:			
		STX	byte_9
		LDX	#8
		JSR	store_hex_byte_in_line_buffer ;	print LSB hex as part of hex dump
		LDX	byte_9
		BPL	loc_91BE	; JMP, in effect

loc_9230:				
		LDA	#'&'
		STA	line_buffer,X
		INX
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		STA	byte_8
		JSR	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		STA	line_buffer+$F
		LDA	byte_8
		STX	byte_9
		LDX	#8
		JSR	store_hex_byte_in_line_buffer
		LDX	byte_9
		JSR	add8s		; add 8-bit sign-extended value
					;
					; entry: ?byte_8, A = 8-bit signed value (seems	these must be the same???)
					;	 word_B	= 16-bit value
					; exit:	?byte_9	= LSB of result
					;	A = MSB	of result
					; preserves: X/Y
		JSR	store_hex_byte_in_line_buffer
		LDA	byte_9
		JSR	store_hex_byte_in_line_buffer
		JMP	loc_91BE


; --------------- S U B	R O U T	I N E ---------------------------------------

; add 8-bit sign-extended value
;
; entry: ?byte_8, A = 8-bit signed value (seems	these must be the same???)
;	 word_B	= 16-bit value
; exit:	?byte_9	= LSB of result
;	A = MSB	of result
; preserves: X/Y

add8s:					
					
		CLC
		ADC	word_B		; add LSB
		STA	byte_9		; store	LSB
		LDA	byte_8		; get MSB
		BPL	loc_9265	; branch taken if +ve
		LDA	#$FF		; decrement MSB
		BMI	loc_9267	; JMP, in effect

loc_9265:				
		LDA	#0

loc_9267:				
		ADC	word_B+1
		CLC
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; get size of instruction operand bytes
;
; entry: A = opcode
; exit:	C=0 if valid, then A = # bytes
;	C=1 if invalid

get_instruction_operand_size:		
		JSR	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		BCS	locret_9284	; branch taken if instruction invalid
		LDA	byte_D		; get addrmode info - %abcdefgh
		LSR	A		; %0abcdefg
		JMP	shr5_clc	; %000000ab



; --------------- S U B	R O U T	I N E ---------------------------------------

; entry: A = opcode
; exit:	C=1 if invalid;
;	C=0 if valid
;	A = offset into	mnemonics table
;	?byte_D	= instruction addressing mode info

get_instruction_info:			
					
		JSR	get_instruction_info_2
		TAY
		LDA	addrmode_info_table,Y ;	addrmode_info_table[i] is info about addrmode i
					;
					; bits 0-5 are offset into addrmode_strings
		STA	byte_D		; store	instruction addressing mode info
		LDY	mnemonic
		LDA	mnemonic_offsets,Y ; mnemonic_offsets[i] is offset into	mnemonics for mnemonic i

locret_9284:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


get_instruction_info_2:			
		TAY			; Y = opcode
		LDA	instruction_mnemonics,Y	; instruction_mnemonics[i] holds the mnemonic index for	opcode i.
					; if $ff, this opcode is invalid.
					; if bit 7 set otherwise, CMOS opcode.
					; bits 0-6 are the mnemonic index.

		BPL	loc_92A5	; taken	if bit 7 clear - instruction is	valid
		CMP	#$FF
		BNE	maybe_cmos	; taken	if bit 7 set, but not $ff - instruction	is maybe CMOS

not_valid:				
		SEC
		RTS
; ---------------------------------------------------------------------------

maybe_cmos:				
		JSR	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		CPX	#$FD       ; Master 128 MOS 3.20/3.50
		BEQ	is_master
		CPX	#$F5       ; Master Compact MOS 5.10
		BEQ	is_master
                
		LDX	#$FF
                .cpu '65c02'
                phx             ;$da - a NOP on NMOS 6502
                inx
                plx             ;$fa - a NOP on NMOS 6502
                .cpu 'default'
		BEQ	not_valid	; JMP, in effect

is_master:
					; get_instruction_info_2+15j
		AND	#$7F       ; clear cmos/invalid flag

loc_92A5:				
		STA	mnemonic
		LDA	instruction_addrmodes,Y	; instruction_addrmodes[i] is addressing mode index for	opcode i
		CLC
		RTS


; ---------------------------------------------------------------------------

cmd_K:
		JSR	sub_8817
		JSR	print_following_string
; ---------------------------------------------------------------------------
                .text ' File?'
; ---------------------------------------------------------------------------
		NOP
		LDY	#$A		; Bug? - Y was max input length	at some	point?
		JSR	read_line_buffer ; read	input into line	buffer.	Max 40 chars
					;
					; exit:	Y = # chars read
		JSR	osnewl
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		LDX	#9

loc_92C6:				
		LDA	line_buffer,X
		STA	line_buffer+3,X
		DEX
		BPL	loc_92C6
		JSR	star_spool	; does *SPOOL with file	name at	line_buffer+3 onwards
		JSR	print_following_string
; ---------------------------------------------------------------------------
aAu_P:		.text 'AU.',$D,'P%=&'
; ---------------------------------------------------------------------------
		NOP
		JSR	sub_891F
		LDA	#$D
		STA	line_buffer+4
		JSR	print_entire_line_buffer ; print up to 40 chars	from line buffer
		LDA	#'['
		JSR	oswrch
		JSR	osnewl

loc_92EE:				
		JSR	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		BNE	loc_92F9
		JSR	acknowledge_ESCAPE
		JMP	loc_9357
; ---------------------------------------------------------------------------

loc_92F9:				
		LDA	word_B+1
		STA	workspace_pointer+1
		LDA	word_B
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		AND	#$1F
		CMP	#$10
		PHP
		INC	workspace_pointer
		BNE	loc_930D
		INC	workspace_pointer+1

loc_930D:				
		LDA	workspace_pointer
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		STA	byte_E
		JSR	check_fetch_address
		BCS	loc_9357
		JSR	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		PLP
		BNE	loc_9348
		LDA	#'P'
		STA	line_buffer+$18
		LDA	#'%'
		STA	line_buffer+$19
		LDA	#'+'
		STA	line_buffer+$1A
		LDA	#'&'
		STA	line_buffer+$1B
		LDA	byte_E
		BPL	loc_9340
		EOR	#$FF
		SEC
		SBC	#1
		PHA
		LDA	#'-'
		STA	line_buffer+$1A
		PLA
		BPL	loc_9343

loc_9340:				
		CLC
		ADC	#2

loc_9343:				
		LDX	#$1C
		JSR	store_hex_byte_in_line_buffer

loc_9348:				
		LDX	#$1F
		STX	byte_8
		LDX	#$14
		JSR	loc_8A9A
		JSR	osnewl
		JMP	loc_92EE
; ---------------------------------------------------------------------------

loc_9357:				
		LDA	#']'
		JSR	oswrch
		JSR	osnewl
		LDA	#$D
		STA	line_buffer+3	; store	empty file name	for *SPOOL
		JSR	star_spool	; does *SPOOL with file	name at	line_buffer+3 onwards
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop

; --------------- S U B	R O U T	I N E ---------------------------------------

; does *SPOOL with file	name at	line_buffer+3 onwards

star_spool:				
		LDA	#'s'
		STA	line_buffer
		LDA	#'p'
		STA	line_buffer+1
		LDA	#'.'
		STA	line_buffer+2
		LDX	#line_buffer
		LDY	#0
		JMP	oscli


; ---------------------------------------------------------------------------
mnemonics: .block
bvs:
                .text 'BV'
sty:
                .text 'S'
tya:
                .text 'TY'
adc:
                .text 'AD'
cld:
                .text 'C'
lda:
                .text 'LD'
and:
                .text 'AN'
dec:
                .text 'DE'
clc:
                .text 'CL'
cli:
                .text 'CL'
inx:
                .text 'INX'
rts:
                .text 'R'
tsb:
                .text 'T'
sbc:
                .text 'S'
bcs:
                .text 'BC'
sec:
                .text 'SE'
clv:
                .text 'CLV'
jsr:
                .text 'JS'
ror:
                .text 'RO'
rol:
                .text 'RO'
ldx:
                .text 'LDX'
sta:
                .text 'S'
tax:
                .text 'TAX'
bit:
                .text 'BI'
txs:
                .text 'TX'
sei:
                .text 'SE'
iny:
                .text 'INY'
bpl:
                .text 'B'
pla:
                .text 'PLA'
bne:					
		.text 'BN'
eor:
                .text 'E'
ora:
                .text 'ORA'
lsr:
                .text 'LS'
rti:
                .text 'RT'
inc:
                .text 'IN'
cmp:
                .text 'CM'
php:
                .text 'PH'
plp:
                .text 'PL'
pha:
                .text 'PH'
asl:
                .text 'AS'
ldy:
                .text 'LDY'
bcc:
                .text 'BC'
cpx:
                .text 'CPX'
stx:
                .text 'S'
txa:
                .text 'TXA'
sed:
                .text 'SE'
dex:
                .text 'DEX'
bvc:
                .text 'BV'
cpy:
                .text 'CPY'
beq:
                .text 'BEQ'
bmi:
                .text 'BMI'
brk:
                .text 'BRK'
dey:
                .text 'DEY'
jmp:
                .text 'JMP'
nop:
                .text 'NOP'
tay:
                .text 'TAY'
tsx:
                .text 'TSX'
trb:
                .text 'TR'
bra:
                .text 'BRA'
stz:
                .text 'STZ'
phx:
                .text 'PHX'
phy:
                .text 'PHY'
plx:
                .text 'PLX'
ply:
                .text 'PLY'
                .bend
                
addrmode_strings: .block
a_offset=*-addrmode_strings
                .text 'A'
imp_offset=*-addrmode_strings
                .text 0
imm_offset=*-addrmode_strings
		.text '#'
zp_offset=*-addrmode_strings
               .text ' ',0
zpx_offset=*-addrmode_strings
		.text ' ,X',0
zpy_offset=*-addrmode_strings
		.text ' ,Y',0
zxi_offset=*-addrmode_strings
		.text '( ,X)',0
ziy_offset=*-addrmode_strings             
		.text '( ),Y',0
abs_offset=*-addrmode_strings
		.text '!',0
abx_offset=*-addrmode_strings
		.text '!,X',0
aby_offset=*-addrmode_strings
		.text '!,Y',0
ain_offset=*-addrmode_strings
		.text '(!)',0
unk_offset=*-addrmode_strings
		.text '?',0
zin_offset=*-addrmode_strings
		.text '( )',0
axi_offset=*-addrmode_strings
		.text '(!,X)',0
                .bend
                
mnemonic_offsets:
; mnemonic_offsets[i] is offset	into mnemonics for mnemonic i
mnemonic_ORA=*-mnemonic_offsets
                .byte mnemonics.ORA-mnemonics
mnemonic_AND=*-mnemonic_offsets
                .byte mnemonics.AND-mnemonics
mnemonic_EOR=*-mnemonic_offsets
                .byte mnemonics.EOR-mnemonics
mnemonic_ADC=*-mnemonic_offsets
                .byte mnemonics.ADC-mnemonics
mnemonic_STA=*-mnemonic_offsets
                .byte mnemonics.STA-mnemonics
mnemonic_LDA=*-mnemonic_offsets
                .byte mnemonics.LDA-mnemonics
mnemonic_CMP=*-mnemonic_offsets
                .byte mnemonics.CMP-mnemonics
mnemonic_SBC=*-mnemonic_offsets
                .byte mnemonics.SBC-mnemonics
mnemonic_ASL=*-mnemonic_offsets
                .byte mnemonics.ASL-mnemonics
mnemonic_ROL=*-mnemonic_offsets
                .byte mnemonics.ROL-mnemonics
mnemonic_LSR=*-mnemonic_offsets
                .byte mnemonics.LSR-mnemonics
mnemonic_ROR=*-mnemonic_offsets
                .byte mnemonics.ROR-mnemonics
mnemonic_STX=*-mnemonic_offsets
                .byte mnemonics.STX-mnemonics
mnemonic_LDX=*-mnemonic_offsets
                .byte mnemonics.LDX-mnemonics
mnemonic_DEC=*-mnemonic_offsets
                .byte mnemonics.DEC-mnemonics
mnemonic_INC=*-mnemonic_offsets
                .byte mnemonics.INC-mnemonics
mnemonic_TXA=*-mnemonic_offsets
                .byte mnemonics.TXA-mnemonics
mnemonic_TXS=*-mnemonic_offsets
                .byte mnemonics.TXS-mnemonics
mnemonic_TAX=*-mnemonic_offsets
                .byte mnemonics.TAX-mnemonics
mnemonic_TSX=*-mnemonic_offsets
                .byte mnemonics.TSX-mnemonics
mnemonic_DEX=*-mnemonic_offsets
                .byte mnemonics.DEX-mnemonics
mnemonic_BIT=*-mnemonic_offsets
                .byte mnemonics.BIT-mnemonics
mnemonic_NOP=*-mnemonic_offsets
                .byte mnemonics.NOP-mnemonics
mnemonic_JMP=*-mnemonic_offsets
                .byte mnemonics.JMP-mnemonics
mnemonic_STY=*-mnemonic_offsets
                .byte mnemonics.STY-mnemonics
mnemonic_LDY=*-mnemonic_offsets
                .byte mnemonics.LDY-mnemonics
mnemonic_CPY=*-mnemonic_offsets
                .byte mnemonics.CPY-mnemonics
mnemonic_CPX=*-mnemonic_offsets
                .byte mnemonics.CPX-mnemonics
mnemonic_BPL=*-mnemonic_offsets
                .byte mnemonics.BPL-mnemonics
mnemonic_BMI=*-mnemonic_offsets
                .byte mnemonics.BMI-mnemonics
mnemonic_BVC=*-mnemonic_offsets
                .byte mnemonics.BVC-mnemonics
mnemonic_BVS=*-mnemonic_offsets
                .byte mnemonics.BVS-mnemonics
mnemonic_BCC=*-mnemonic_offsets
                .byte mnemonics.BCC-mnemonics
mnemonic_BCS=*-mnemonic_offsets
                .byte mnemonics.BCS-mnemonics
mnemonic_BNE=*-mnemonic_offsets
                .byte mnemonics.BNE-mnemonics
mnemonic_BEQ=*-mnemonic_offsets
                .byte mnemonics.BEQ-mnemonics
mnemonic_BRK=*-mnemonic_offsets
                .byte mnemonics.BRK-mnemonics
mnemonic_JSR=*-mnemonic_offsets
                .byte mnemonics.JSR-mnemonics
mnemonic_RTI=*-mnemonic_offsets
                .byte mnemonics.RTI-mnemonics
mnemonic_RTS=*-mnemonic_offsets
                .byte mnemonics.RTS-mnemonics
mnemonic_PHP=*-mnemonic_offsets
                .byte mnemonics.PHP-mnemonics
mnemonic_CLC=*-mnemonic_offsets
                .byte mnemonics.CLC-mnemonics
mnemonic_PLP=*-mnemonic_offsets
                .byte mnemonics.PLP-mnemonics
mnemonic_SEC=*-mnemonic_offsets
                .byte mnemonics.SEC-mnemonics
mnemonic_PHA=*-mnemonic_offsets
                .byte mnemonics.PHA-mnemonics
mnemonic_CLI=*-mnemonic_offsets
                .byte mnemonics.CLI-mnemonics
mnemonic_PLA=*-mnemonic_offsets
                .byte mnemonics.PLA-mnemonics
mnemonic_SEI=*-mnemonic_offsets
                .byte mnemonics.SEI-mnemonics
mnemonic_DEY=*-mnemonic_offsets
                .byte mnemonics.DEY-mnemonics
mnemonic_TYA=*-mnemonic_offsets
                .byte mnemonics.TYA-mnemonics
mnemonic_TAY=*-mnemonic_offsets
                .byte mnemonics.TAY-mnemonics
mnemonic_CLV=*-mnemonic_offsets
                .byte mnemonics.CLV-mnemonics
mnemonic_INY=*-mnemonic_offsets
                .byte mnemonics.INY-mnemonics
mnemonic_CLD=*-mnemonic_offsets
                .byte mnemonics.CLD-mnemonics
mnemonic_INX=*-mnemonic_offsets
                .byte mnemonics.INX-mnemonics
mnemonic_SED=*-mnemonic_offsets
                .byte mnemonics.SED-mnemonics
mnemonic_TSB=*-mnemonic_offsets
                .byte mnemonics.TSB-mnemonics
mnemonic_TRB=*-mnemonic_offsets
                .byte mnemonics.TRB-mnemonics
mnemonic_BRA=*-mnemonic_offsets
                .byte mnemonics.BRA-mnemonics
mnemonic_STZ=*-mnemonic_offsets
                .byte mnemonics.STZ-mnemonics
mnemonic_PHX=*-mnemonic_offsets
                .byte mnemonics.PHX-mnemonics
mnemonic_PHY=*-mnemonic_offsets
                .byte mnemonics.PHY-mnemonics
mnemonic_PLX=*-mnemonic_offsets
                .byte mnemonics.PLX-mnemonics
mnemonic_PLY=*-mnemonic_offsets
                .byte mnemonics.PLY-mnemonics
mnemonic_INVALID=$ff
                
addrmode_info_table:
                ; addrmode_info_table[i] is info about addrmode	i
                ;
                ; bits 0-5 are offset into addrmode_strings
                ; bits 6-7 are count of operand bytes
addrmode_zxi=*-addrmode_info_table ;0
                .byte 1<<6|addrmode_strings.zxi_offset
addrmode_ziy=*-addrmode_info_table ;1
		.byte 1<<6|addrmode_strings.ziy_offset
addrmode_zp=*-addrmode_info_table ;2
		.byte 1<<6|addrmode_strings.zp_offset
addrmode_zpx=*-addrmode_info_table ;3
		.byte 1<<6|addrmode_strings.zpx_offset
addrmode_imm=*-addrmode_info_table ;4
		.byte 1<<6|addrmode_strings.imm_offset
addrmode_aby=*-addrmode_info_table ;5
		.byte 2<<6|addrmode_strings.aby_offset
addrmode_abs=*-addrmode_info_table ;6
		.byte 2<<6|addrmode_strings.abs_offset
addrmode_abx=*-addrmode_info_table ;7
		.byte 2<<6|addrmode_strings.abx_offset
addrmode_a=*-addrmode_info_table ;8
		.byte 0<<6|addrmode_strings.a_offset
addrmode_imp=*-addrmode_info_table ;9
		.byte 0<<6|addrmode_strings.imp_offset
addrmode_ain=*-addrmode_info_table ;10
		.byte 2<<6|addrmode_strings.ain_offset
addrmode_zpy=*-addrmode_info_table ;11
		.byte 1<<6|addrmode_strings.zpy_offset
addrmode_unk=*-addrmode_info_table ;12
		.byte 1<<6|addrmode_strings.unk_offset
addrmode_zin=*-addrmode_info_table ;13
		.byte 1<<6|addrmode_strings.zin_offset
addrmode_axi=*-addrmode_info_table ;14
		.byte 2<<6|addrmode_strings.axi_offset
addrmode_invalid=$ff
                
instruction_addrmodes:
                ; instruction_addrmodes[i] is addressing mode index
                ; for opcode i
                .byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_ain
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_axi
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpy
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_imm
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpy
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_aby
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
                
instruction_mnemonics:
		; instruction_mnemonics[i] holds the mnemonic index	for opcode i.
		; if $ff, this opcode is invalid.
		; if bit 7 set otherwise, CMOS opcode.
		; bits 0-6 are the mnemonic index.
                .byte mnemonic_BRK       ;	0 
		.byte mnemonic_ORA		; 1
		.byte mnemonic_INVALID		; 2
		.byte mnemonic_INVALID		; 3
		.byte $80|mnemonic_TSB		; 4
		.byte mnemonic_ORA		; 5
		.byte mnemonic_ASL		; 6
		.byte mnemonic_INVALID		; 7
		.byte mnemonic_PHP		; 8
		.byte mnemonic_ORA		; 9
		.byte mnemonic_ASL		; 10
		.byte mnemonic_INVALID		; 11
		.byte $80|mnemonic_TSB		; 12
		.byte mnemonic_ORA		; 13
		.byte mnemonic_ASL		; 14
		.byte mnemonic_INVALID		; 15
		.byte mnemonic_BPL		; 16
		.byte mnemonic_ORA		; 17
		.byte $80|mnemonic_ORA		; 18
		.byte mnemonic_INVALID		; 19
		.byte $80|mnemonic_TRB		; 20
		.byte mnemonic_ORA		; 21
		.byte mnemonic_ASL		; 22
		.byte mnemonic_INVALID		; 23
		.byte mnemonic_CLC		; 24
		.byte mnemonic_ORA		; 25
		.byte $80|mnemonic_INC		; 26
		.byte mnemonic_INVALID		; 27
		.byte $80|mnemonic_TRB		; 28
		.byte mnemonic_ORA		; 29
		.byte mnemonic_ASL		; 30
		.byte mnemonic_INVALID		; 31
		.byte mnemonic_JSR		; 32
		.byte mnemonic_AND		; 33
		.byte mnemonic_INVALID		; 34
		.byte mnemonic_INVALID		; 35
		.byte mnemonic_BIT		; 36
		.byte mnemonic_AND		; 37
		.byte mnemonic_ROL		; 38
		.byte mnemonic_INVALID		; 39
		.byte mnemonic_PLP		; 40
		.byte mnemonic_AND		; 41
		.byte mnemonic_ROL		; 42
		.byte mnemonic_INVALID		; 43
		.byte mnemonic_BIT		; 44
		.byte mnemonic_AND		; 45
		.byte mnemonic_ROL		; 46
		.byte mnemonic_INVALID		; 47
		.byte mnemonic_BMI		; 48
		.byte mnemonic_AND		; 49
		.byte $80|mnemonic_AND		; 50
		.byte mnemonic_INVALID		; 51
		.byte $80|mnemonic_BIT		; 52
		.byte mnemonic_AND		; 53
		.byte mnemonic_ROL		; 54
		.byte mnemonic_INVALID		; 55
		.byte mnemonic_SEC		; 56
		.byte mnemonic_AND		; 57
		.byte $80|mnemonic_DEC		; 58
		.byte mnemonic_INVALID		; 59
		.byte $80|mnemonic_BIT		; 60
		.byte mnemonic_AND		; 61
		.byte mnemonic_ROL		; 62
		.byte mnemonic_INVALID		; 63
		.byte mnemonic_RTI		; 64
		.byte mnemonic_EOR		; 65
		.byte mnemonic_INVALID		; 66
		.byte mnemonic_INVALID		; 67
		.byte mnemonic_INVALID		; 68
		.byte mnemonic_EOR		; 69
		.byte mnemonic_LSR		; 70
		.byte mnemonic_INVALID		; 71
		.byte mnemonic_PHA		; 72
		.byte mnemonic_EOR		; 73
		.byte mnemonic_LSR		; 74
		.byte mnemonic_INVALID		; 75
		.byte mnemonic_JMP		; 76
		.byte mnemonic_EOR		; 77
		.byte mnemonic_LSR		; 78
		.byte mnemonic_INVALID		; 79
		.byte mnemonic_BVC		; 80
		.byte mnemonic_EOR		; 81
		.byte $80|mnemonic_EOR		; 82
		.byte mnemonic_INVALID		; 83
		.byte mnemonic_INVALID		; 84
		.byte mnemonic_EOR		; 85
		.byte mnemonic_LSR		; 86
		.byte mnemonic_INVALID		; 87
		.byte mnemonic_CLI		; 88
		.byte mnemonic_EOR		; 89
		.byte $80|mnemonic_PHY		; 90
		.byte mnemonic_INVALID		; 91
		.byte mnemonic_INVALID		; 92
		.byte mnemonic_EOR		; 93
		.byte mnemonic_LSR		; 94
		.byte mnemonic_INVALID		; 95
		.byte mnemonic_RTS		; 96
		.byte mnemonic_ADC		; 97
		.byte mnemonic_INVALID		; 98
		.byte mnemonic_INVALID		; 99
		.byte $80|mnemonic_STZ		; 100
		.byte mnemonic_ADC		; 101
		.byte mnemonic_ROR		; 102
		.byte mnemonic_INVALID		; 103
		.byte mnemonic_PLA		; 104
		.byte mnemonic_ADC		; 105
		.byte mnemonic_ROR		; 106
		.byte mnemonic_INVALID		; 107
		.byte mnemonic_JMP		; 108
		.byte mnemonic_ADC		; 109
		.byte mnemonic_ROR		; 110
		.byte mnemonic_INVALID		; 111
		.byte mnemonic_BVS		; 112
		.byte mnemonic_ADC		; 113
		.byte $80|mnemonic_ADC		; 114
		.byte mnemonic_INVALID		; 115
		.byte $80|mnemonic_STZ		; 116
		.byte mnemonic_ADC		; 117
		.byte mnemonic_ROR		; 118
		.byte mnemonic_INVALID		; 119
		.byte mnemonic_SEI		; 120
		.byte mnemonic_ADC		; 121
		.byte $80|mnemonic_PLY		; 122
		.byte mnemonic_INVALID		; 123
		.byte $80|mnemonic_JMP		; 124
		.byte mnemonic_ADC		; 125
		.byte mnemonic_ROR		; 126
		.byte mnemonic_INVALID		; 127
		.byte $80|mnemonic_BRA		; 128
		.byte mnemonic_STA		; 129
		.byte mnemonic_INVALID		; 130
		.byte mnemonic_INVALID		; 131
		.byte mnemonic_STY		; 132
		.byte mnemonic_STA		; 133
		.byte mnemonic_STX		; 134
		.byte mnemonic_INVALID		; 135
		.byte mnemonic_DEY		; 136
		.byte $80|mnemonic_BIT		; 137
		.byte mnemonic_TXA		; 138
		.byte mnemonic_INVALID		; 139
		.byte mnemonic_STY		; 140
		.byte mnemonic_STA		; 141
		.byte mnemonic_STX		; 142
		.byte mnemonic_INVALID		; 143
		.byte mnemonic_BCC		; 144
		.byte mnemonic_STA		; 145
		.byte $80|mnemonic_STA		; 146
		.byte mnemonic_INVALID		; 147
		.byte mnemonic_STY		; 148
		.byte mnemonic_STA		; 149
		.byte mnemonic_STX		; 150
		.byte mnemonic_INVALID		; 151
		.byte mnemonic_TYA		; 152
		.byte mnemonic_STA		; 153
		.byte mnemonic_TXS		; 154
		.byte mnemonic_INVALID		; 155
		.byte $80|mnemonic_STZ		; 156
		.byte mnemonic_STA		; 157
		.byte $80|mnemonic_STZ		; 158
		.byte mnemonic_INVALID		; 159
		.byte mnemonic_LDY		; 160
		.byte mnemonic_LDA		; 161
		.byte mnemonic_LDX		; 162
		.byte mnemonic_INVALID		; 163
		.byte mnemonic_LDY		; 164
		.byte mnemonic_LDA		; 165
		.byte mnemonic_LDX		; 166
		.byte mnemonic_INVALID		; 167
		.byte mnemonic_TAY		; 168
		.byte mnemonic_LDA		; 169
		.byte mnemonic_TAX		; 170
		.byte mnemonic_INVALID		; 171
		.byte mnemonic_LDY		; 172
		.byte mnemonic_LDA		; 173
		.byte mnemonic_LDX		; 174
		.byte mnemonic_INVALID		; 175
		.byte mnemonic_BCS		; 176
		.byte mnemonic_LDA		; 177
		.byte $80|mnemonic_LDA		; 178
		.byte mnemonic_INVALID		; 179
		.byte mnemonic_LDY		; 180
		.byte mnemonic_LDA		; 181
		.byte mnemonic_LDX		; 182
		.byte mnemonic_INVALID		; 183
		.byte mnemonic_CLV		; 184
		.byte mnemonic_LDA		; 185
		.byte mnemonic_TSX		; 186
		.byte mnemonic_INVALID		; 187
		.byte mnemonic_LDY		; 188
		.byte mnemonic_LDA		; 189
		.byte mnemonic_LDX		; 190
		.byte mnemonic_INVALID		; 191
		.byte mnemonic_CPY		; 192
		.byte mnemonic_CMP		; 193
		.byte mnemonic_INVALID		; 194
		.byte mnemonic_INVALID		; 195
		.byte mnemonic_CPY		; 196
		.byte mnemonic_CMP		; 197
		.byte mnemonic_DEC		; 198
		.byte mnemonic_INVALID		; 199
		.byte mnemonic_INY		; 200
		.byte mnemonic_CMP		; 201
		.byte mnemonic_DEX		; 202
		.byte mnemonic_INVALID		; 203
		.byte mnemonic_CPY		; 204
		.byte mnemonic_CMP		; 205
		.byte mnemonic_DEC		; 206
		.byte mnemonic_INVALID		; 207
		.byte mnemonic_BNE              ; 208
		.byte mnemonic_CMP		; 209
		.byte $80|mnemonic_CMP		; 210
		.byte mnemonic_INVALID		; 211
		.byte mnemonic_INVALID		; 212
		.byte mnemonic_CMP		; 213
		.byte mnemonic_DEC		; 214
		.byte mnemonic_INVALID		; 215
		.byte mnemonic_CLD              ; 216
		.byte mnemonic_CMP		; 217
		.byte $80|mnemonic_PHX		; 218
		.byte mnemonic_INVALID		; 219
		.byte mnemonic_INVALID		; 220
		.byte mnemonic_CMP		; 221
		.byte mnemonic_DEC		; 222
		.byte mnemonic_INVALID		; 223
		.byte mnemonic_CPX		; 224
		.byte mnemonic_SBC		; 225
		.byte mnemonic_INVALID		; 226
		.byte mnemonic_INVALID		; 227
		.byte mnemonic_CPX		; 228
		.byte mnemonic_SBC		; 229
		.byte mnemonic_INC		; 230
		.byte mnemonic_INVALID		; 231
		.byte mnemonic_INX		; 232
		.byte mnemonic_SBC		; 233
		.byte mnemonic_NOP		; 234
		.byte mnemonic_INVALID		; 235
		.byte mnemonic_CPX		; 236
		.byte mnemonic_SBC		; 237
		.byte mnemonic_INC		; 238
		.byte mnemonic_INVALID		; 239
		.byte mnemonic_BEQ		; 240
		.byte mnemonic_SBC		; 241
		.byte $80|mnemonic_SBC		; 242
		.byte mnemonic_INVALID		; 243
		.byte mnemonic_INVALID		; 244
		.byte mnemonic_SBC		; 245
		.byte mnemonic_INC		; 246
		.byte mnemonic_INVALID		; 247
		.byte mnemonic_SED		; 248
		.byte mnemonic_SBC		; 249
		.byte $80|mnemonic_PLX		; 250
		.byte mnemonic_INVALID		; 251
		.byte mnemonic_INVALID		; 252
		.byte mnemonic_SBC		; 253
		.byte mnemonic_INC		; 254
		.byte mnemonic_INVALID		; 255
; ---------------------------------------------------------------------------


loc_9692:				
		JMP	loc_9A30

; ---------------------------------------------------------------------------

cmd_T:
		JSR	oswrch
		LDA	#$80 
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		STA	byte_20
		JSR	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#$53 
		BNE	loc_96B1
		JSR	oswrch
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		ORA	#$40 
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		JSR	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y

loc_96B1:				
		STA	byte_E
		CMP	#'B'
		BEQ	cmd_TB
		CMP	#'A'
		BEQ	cmd_TA_or_TX_or_TY
		CMP	#'X'
		BEQ	cmd_TA_or_TX_or_TY
		CMP	#'Y'
		BEQ	cmd_TA_or_TX_or_TY
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVC	loc_96CA
		JSR	print_backspace

loc_96CA:				
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_TA_or_TX_or_TY:			
		JSR	sub_8880	; read byte value??
		STA	byte_F
		LDA	#0

cmd_TB:					
		JSR	sub_8F49
		JSR	osnewl
		JSR	update_cursor_pos_2 ; update cursor pos	in cursor_x_2/cursor_y_2


loc_96DD:				
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		TYA
		LDY	#1
		STA	(workspace_pointer),Y
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVS	loc_96FA
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BMI	loc_9700
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9700
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BMI	loc_96FA
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		LSR	A
		BCC	loc_9708

loc_96FA:				
		JSR	sub_9CBA
		JMP	loc_9708
; ---------------------------------------------------------------------------

loc_9700:				
		LDA	#0
		STA	cursor_x_2
		STA	cursor_y_2
		STA	byte_20

loc_9708:				
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		BEQ	loc_9692
		JSR	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		BEQ	loc_977A
		JSR	sub_99B3
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BMI	loc_9762
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVC	loc_9729

loc_971C:				
		JSR	osrdch
		CMP	#$1B
		BEQ	loc_977A
		CMP	#$20 
		BNE	loc_971C
		BEQ	loc_9762

loc_9729:				
		LDA	byte_20
		BNE	loc_973F
		LDA	word_B
		PHA
		LDA	word_B+1
		PHA
		JSR	sub_8331
		JSR	sub_A35C
		PLA
		STA	word_B+1
		PLA
		STA	word_B

loc_973F:				
		JSR	set_command_line_text_window_and_restore_cursor
		JSR	flush_input_buffer_and_readch
		CMP	#$7F 
		BNE	loc_9758
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
aSkip:		.text 'SKIP',$D
; ---------------------------------------------------------------------------
		NOP
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	simulated_branch_not_taken
; ---------------------------------------------------------------------------

loc_9758:				
		CMP	#$2F 
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		BEQ	loc_9762
		CMP	#$20 
		BNE	loc_9787

loc_9762:				
		LDA	#$EA       ; NOP
		LDY	#loc_8581+1-loc_8563
		STA	(workspace_code),Y ; $wwb0 = EQUB ???:NOP:???
		INY
		STA	(workspace_code),Y ; $wwb0 = EQUB ???:NOP:NOP
		LDA	reg_pc+1
		STA	workspace_pointer+1
		LDA	reg_pc
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		PHA			; save opcode
		JSR	get_instruction_operand_size ; get size	of instruction operand bytes
					;
					; entry: A = opcode
					; exit:	C=0 if valid, then A = # bytes
					;	C=1 if invalid
		BCC	copy_instruction ; branch taken	if instruction valid

loc_977A:				
		JSR	sub_8331
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVS	loc_9784
		JMP	acknowledge_ESCAPE_and_reset_cursor
; ---------------------------------------------------------------------------

loc_9784:				
		JMP	loc_8315
; ---------------------------------------------------------------------------

loc_9787:				
		PHA
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		PLA
		JMP	loc_82A2
; ---------------------------------------------------------------------------

copy_instruction:			
		TAX			; X = instruction operand size
		LDY	#loc_8581-loc_8563

copy_instruction_loop:			
		STY	sim_temp	; save offset
		JSR	read_memory_workspace_pointer ;	read opcode/operand byte
		LDY	sim_temp	; restore offset
		INC	workspace_pointer
		BNE	loc_979F
		INC	workspace_pointer+1

loc_979F:				
		STA	(workspace_code),Y ; copy to $wwb0
		STA	basic_TOP	; store	copy of	last byte fetched
		INY
		DEX
		BPL	copy_instruction_loop
		PLA			; restore opcode
		TAY			; Y=opcode
		STY	sim_temp	; ?sim_temp=opcode
		CPY	#0
		BEQ	simulate_BRK
		CPY	#$20 
		BEQ	simulate_JSR_abs
		CPY	#$4C 
		BEQ	simulate_JMP_abs
		CPY	#$60 
		BEQ	simulate_RTS
		CPY	#$40 
		BEQ	simulate_RTI
		CPY	#$6C 
		BEQ	simulate_JMP_ind
		CPY	#$7C 
		BEQ	simulate_JMP_indX
		JMP	simulate_branch_or_ordinary
; ---------------------------------------------------------------------------

simulate_BRK:				
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BPL	loc_97D1
		JMP	loc_9969
; ---------------------------------------------------------------------------

loc_97D1:				
		LDA	#$EA 
		LDY	#loc_8581-loc_8563
		STA	(workspace_code),Y ; $wwb0 = NOP:NOP:NOP
		JMP	simulate_ordinary
; ---------------------------------------------------------------------------

simulate_RTI:				
		PLA
		STA	reg_p
		PLA
		STA	reg_pc
		CLC			; no increment - RTI pops exact	address
		BCC	loc_97E9	; JMP, in effect

simulate_RTS:				
		PLA
		CLC
		ADC	#1		; increment PC,	usual RTS thing
		STA	reg_pc

loc_97E9:				
		PLA
		ADC	#0
		STA	reg_pc+1
		JMP	simulate_execute
; ---------------------------------------------------------------------------

simulate_JSR_abs:			
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		CMP	#47
		BNE	loc_97FA
		JMP	simulate_ordinary
; ---------------------------------------------------------------------------

loc_97FA:				
		LDX	basic_TOP	; X = last byte	fetched	- MSB of dest address
		INX			; X=$00	if target is $FFxx
		BEQ	simulate_JMP_abs ; taken if target is $FFxx
		CLC
		LDA	reg_pc
		ADC	#2
		STA	byte_D
		LDA	reg_pc+1
		ADC	#0
		PHA
		LDA	byte_D
		PHA

simulate_JMP_abs:			
		LDY	#loc_8581-loc_8563
		LDA	#$20 
		STA	(workspace_code),Y ; $wwb0 = jsr $xxxx
		LDA	basic_TOP
		CMP	#$FF
		BEQ	simulate_ordinary ; taken if jump target is $FFxx
		STA	reg_pc+1
		INY
		LDA	(workspace_code),Y ; points to code region in workspace, +$92
		STA	reg_pc
		JMP	simulate_execute
; ---------------------------------------------------------------------------

simulate_JMP_ind:			
		JSR	reset_WRCHV	; reset	WRCHV to default value
		LDY	#loc_8581+1-loc_8563
		LDA	basic_TOP	; last byte fetched - MSB of indirect address
		STA	workspace_pointer+1
		LDA	(workspace_code),Y ; fetch LSB of indirect address
		JSR	read_memory	; read LSB of jump target
		STA	reg_pc		; update PC
		INC	workspace_pointer
		BNE	loc_983A
		INC	workspace_pointer+1

loc_983A:				
		JSR	read_memory_workspace_pointer ;	read MSB of jump target
		STA	reg_pc+1
		JSR	install_OSWRCH_handler
		JMP	simulate_execute
; ---------------------------------------------------------------------------

simulate_JMP_indX:			
		JSR	reset_WRCHV	; reset	WRCHV to default value
		LDY	#loc_8581+1-loc_8563
		LDA	(workspace_code),Y ; last byte fetched - MSB of	indirect address
		CLC
		ADC	reg_x
		PHA
		LDA	basic_TOP
		ADC	#0
		STA	workspace_pointer+1
		PLA
		JSR	read_memory	; read LSB of jump target
		STA	reg_pc
		INC	workspace_pointer
		BNE	loc_9862
		INC	workspace_pointer+1

loc_9862:				
		JSR	read_memory_workspace_pointer ;	read MSB of jump target
		STA	reg_pc+1
		JSR	install_OSWRCH_handler
		JMP	simulate_execute
; ---------------------------------------------------------------------------

simulate_branch_or_ordinary:		
		TYA
		CMP	#$80       ; $80 = BRA (CMOS)
		BEQ	loc_9878
		AND	#$1F
		CMP	#$10		; $00 =	BRK/JSR	abs/RTI/RTS/BRA	(CMOS) (handled	above)/LDY imm/CPY imm/CPX imm
					; $10 =	BPL/BMI/BVC/BVS/BCC/BCS/BNE/BEQ
		BNE	simulate_ordinary

loc_9878:				
		JMP	simulate_branch
; ---------------------------------------------------------------------------

simulate_ordinary:			
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		AND	#$3F 
		BEQ	loc_988D
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BMI	loc_988D
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		LSR	A
		BCS	loc_988D
		JSR	sub_9CBA

loc_988D:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVC	loc_9896
		JSR	reset_WRCHV	; reset	WRCHV to default value
		BVS	loc_98BF

loc_9896:				
		BPL	loc_989B
		JSR	nvoswrch

loc_989B:				
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		BEQ	loc_98A6
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVS	loc_98A6
		JSR	set_output_text_window

loc_98A6:				
		LDA	#$1F
		JSR	nvoswrch
		LDA	cursor_x_2
		JSR	nvoswrch
		LDA	cursor_y_2
		JSR	nvoswrch
		LDA	#<wrch_8c42
		STA	XWRCHV
		LDA	#>wrch_8c42
		STA	XWRCHV+1

loc_98BF:				
		LDA	#<BRK_handler_8245
		STA	BRKV
		LDA	#>BRK_handler_8245
		STA	BRKV+1		; ???? - $8245 doesn't look meaningful...
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#2
		LDA	(workspace_pointer),Y
		STA	byte_254	; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
		INY
		LDA	(workspace_pointer),Y
		STA	byte_258	; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
		INY
		LDA	(workspace_pointer),Y
		STA	byte_27C	; character destination	status (OSBYTE 236, AUG	p232)
		INY
		LDA	(workspace_pointer),Y
		STA	byte_27D	; cursor editing status	(OSBYTE	237, AUG p233)
		INY
		LDA	(workspace_pointer),Y
		STA	byte_241	; input	source (OSBYTE 177, AUG	p186)
		LDA	workspace_pointer+1
		PHA
		LDA	#loc_8576-loc_8563+workspace.code
		PHA

		LDA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
                
		LDY	#loc_8578+1-loc_8563
		STA	(workspace_code),Y ; fix up ROM	bank containing	routine

		LDA	reg_p
		PHA
		LDY	reg_y
		LDX	reg_x
		LDA	reg_a
		JSR	swap_zp_and_workspaces
		RTI

; ---------------------------------------------------------------------------

loc_9904:				
		JSR	swap_zp_and_workspaces
		JSR	sub_8CA7
		LDA	byte_3D		; copy of ESCAPE/BREAK bits???
		AND	#$3F 
		BEQ	loc_9921
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		LSR	A
		BCS	loc_9921
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BMI	loc_9921
		BVC	loc_9921
		JSR	osrdch
		JSR	sub_9CBA

loc_9921:				
		JSR	update_cursor_pos_2 ; update cursor pos	in cursor_x_2/cursor_y_2
		LDA	sim_temp
		CMP	#$4C 
		BNE	simulated_branch_not_taken
		JMP	simulate_RTS
; ---------------------------------------------------------------------------


simulated_branch_not_taken:		
		LDA	word_B
		STA	reg_pc
		LDA	word_B+1
		STA	reg_pc+1

simulate_execute:			
		CLI
		CLD
		TSX
		STX	reg_s
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BPL	loc_998D
		LDA	byte_E
		LDX	byte_F
		CMP	#word_41+1
		BEQ	loc_995E
		CMP	#word_41
		BEQ	loc_9954
		CMP	#reg_pc
		BEQ	loc_995A
		CPX	reg_y
		BEQ	loc_9969
		BNE	loc_995E

loc_9954:				
		CPX	reg_a
		BEQ	loc_9969
		BNE	loc_995E

loc_995A:				
		CPX	reg_x
		BEQ	loc_9969

loc_995E:				
		LDA	reg_pc+1
		STA	word_1C+1
		LDA	reg_pc
		JSR	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		BCS	loc_998D

loc_9969:				
		LDA	#0
		STA	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
		LDA	#7
		JSR	oswrch
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVC	loc_997D
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	loc_977A
; ---------------------------------------------------------------------------

loc_997D:				
		LDA	#$20 
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVC	loc_998D
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		LSR	A
		BCS	loc_998D
		JSR	sub_9CBA

loc_998D:				
		JMP	loc_9708
; ---------------------------------------------------------------------------

simulate_branch:			
		TYA			; A = opcode
		LDY	#loc_858A-loc_8563
		STA	(workspace_code),Y ; fix up branch opcode at $wwb9
		LDA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		PHA
		LDA	#loc_858A-loc_8563+workspace.code
		PHA
		LDA	reg_p
		PHA
		RTI			; JMP $wwb9+PLP, in effect

; ---------------------------------------------------------------------------

simulated_branch_taken:			
		CLD
		LDY	#loc_8581+1-loc_8563
		LDA	(workspace_code),Y ; read branch offset	from copied instruction
		STA	byte_8		; add8s	boilerplate
		JSR	add8s		; add branch offset to program counter
		STA	reg_pc+1
		LDA	byte_9
		STA	reg_pc
		JMP	simulate_execute

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_99B3:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVS	loc_99C9
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVS	loc_99C9
		JSR	set_command_line_text_window_and_restore_cursor
		JSR	print_register_values
		JSR	print_cr
		LDX	#$17
		JSR	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print

loc_99C9:				
		LDA	reg_pc
		STA	word_B
		LDA	reg_pc+1
		STA	word_B+1
		JSR	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		BIT	byte_3D		; copy of ESCAPE/BREAK bits???
		BVC	loc_99D9

locret_99D8:				
		RTS
; ---------------------------------------------------------------------------

loc_99D9:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVS	locret_99D8
		LDX	#$C

loc_99DF:				
		LDA	line_buffer+$13,X
		STA	line_buffer+4,X
		DEX
		BPL	loc_99DF
		LDA	#$D
		STA	line_buffer+$11
		JSR	print_entire_line_buffer ; print up to 40 chars	from line buffer
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	draw_panel


; ---------------------------------------------------------------------------

cmd_G:
		JSR	sub_8F49
		LDA	reg_pc+1
		STA	word_1C+1
		STA	workspace_pointer+1
		LDA	reg_pc
		JSR	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		BCS	loc_9A18
		LDX	#0
		STX	byte_3D		; copy of ESCAPE/BREAK bits???
		JSR	sub_9CBA
		LDA	reg_pc+1
		STA	word_B+1
		LDA	reg_pc
		STA	word_B
		JSR	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		JMP	loc_9762
; ---------------------------------------------------------------------------

loc_9A18:				
		LDA	reg_pc
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		CMP	#0
		BNE	loc_9A2D
		INC	reg_pc
		BNE	loc_9A27
		INC	reg_pc+1

loc_9A27:				
		JSR	sub_8331
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9A2D:				
		JSR	sub_9CBA


loc_9A30:				
		JSR	sub_9B82
		LDY	#loc_8581-loc_8563
		LDA	#$4C 
		STA	(workspace_code),Y ; ensure +$1e is a JMP
		INY
		LDA	reg_pc
		STA	(workspace_code),Y ; fix up jump target	LSB
		INY
		LDA	reg_pc+1
		STA	(workspace_code),Y ; fix up jump target	MSB


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9A43:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVS	loc_9A4A
		JSR	osnewl

loc_9A4A:				
		BIT	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		BPL	loc_9A53
		LDA	#2
		JSR	nvoswrch

loc_9A53:				
		JSR	reset_WRCHV	; reset	WRCHV to default value
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JMP	loc_98BF


; ---------------------------------------------------------------------------

cmd_J:
		JSR	read_address_qqq
		LDY	#loc_8581+1-loc_8563
		STA	(workspace_code),Y ; fix up jump target	LSB
		INY
		LDA	word_1C+1
		STA	(workspace_code),Y ; fix up jump target	MSB
		DEY
		DEY
		LDA	#$4C 
		STA	(workspace_code),Y ; ensure +$1e is a JMP
		LDA	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		PHA
		LDA	#loc_8592-1-loc_8563+workspace.code
		PHA
		JMP	sub_9CBA
; ---------------------------------------------------------------------------

loc_9A78:				
		JSR	swap_zp_and_workspaces
		JSR	sub_8CA7
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BVC	loc_9A85
		JSR	sub_9CBA

loc_9A85:				
		JMP	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------

; find breakpoint by address
;
; entry: A=address LSB
;	 word_1C?1=address MSB
; exit:	C=1 - not found
;	C=0 - found, Y = index
; preserves: X

find_breakpoint_by_address:		
		STA	byte_14
		LDA	word_1C+1
		STA	byte_15
		LDA	num_breakpoints
		BEQ	loc_9AA7
		LDY	#0

loc_9A94:				
		LDA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		CMP	byte_14
		BNE	loc_9AA2
		LDA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		CMP	byte_15
		BNE	loc_9AA2
		CLC
		RTS
; ---------------------------------------------------------------------------

loc_9AA2:				
					; find_breakpoint_by_address+16j
		INY
		CPY	num_breakpoints
		BCC	loc_9A94

loc_9AA7:				
		SEC
		RTS


; ---------------------------------------------------------------------------

cmd_BS:					
		LDX	num_breakpoints
		CPX	#max_num_breakpoints
		BCC	loc_9AC1
		JSR	oswrch
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
aTooMany:	.text 'Too many'
; ---------------------------------------------------------------------------
		NOP

loc_9ABE:				
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9AC1:				
		JSR	read_address_qqq
		JSR	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		BCC	loc_9ABE	; taken	if breakpoint at that address already
		LDY	num_breakpoints
		INC	num_breakpoints
		LDA	byte_14
		STA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		LDA	byte_15
		STA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		STA	workspace_pointer+1
		LDA	byte_14
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		LDY	num_breakpoints
		DEY
		STA	(word_4E),Y
		JSR	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		BCC	loc_9AF9	; branch taken if valid	opcode
		DEC	num_breakpoints
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
aNotOpcode:	.text 'Not opcode'
; ---------------------------------------------------------------------------
		NOP
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9AF9:				
		JSR	osnewl
		LDA	#11
		JSR	oswrch
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

cmd_B:					; print	char in	A, then	read character
		JSR	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'S'
		BEQ	cmd_BS
		CMP	#'W'
		BEQ	cmd_BW
		CMP	#'C'
		BEQ	cmd_BC
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_BC:					
		JSR	read_address_qqq
		JSR	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		BCC	loc_9B21	; branch taken if breakpoint found
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9B21:				
		INY
		LDA	(word_4E),Y
		DEY
		STA	(word_4E),Y
		INY
		LDA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		DEY
		STA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		INY
		LDA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		DEY
		STA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		INY
		CPY	num_breakpoints
		BCC	loc_9B21
		LDX	#24
		DEC	num_breakpoints
		BEQ	loc_9B7C
		CPY	#6
		BEQ	loc_9B7A
		BNE	loc_9B7F

; --------------- S U B	R O U T	I N E ---------------------------------------

; print	a bunch	of spaces to clear screen line
;
; entry: X = row to clear

clear_line:				
		TXA
		PHA
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		PLA
		TAX
		LDA	#26
		JSR	oswrch		; restore default text windows
		LDA	#31
		JSR	oswrch		; set text cursor position
		LDA	#0
		JSR	oswrch		; text cursor X=0
		TXA
		JSR	oswrch		; text cursor Y=whatever
		JSR	print_39_spaces
		JMP	set_command_line_text_window_and_restore_cursor


; ---------------------------------------------------------------------------

cmd_BW:					
		JSR	oswrch
		LDA	num_breakpoints
		BEQ	loc_9B7F	; branch taken if no breakpoints
		LDX	#24
		JSR	clear_line	; print	a bunch	of spaces to clear screen line
					;
					; entry: X = row to clear
		LDA	num_breakpoints
		LDY	#0
		STY	num_breakpoints
		CMP	#6
		BCC	loc_9B7F

loc_9B7A:				
		LDX	#23

loc_9B7C:				
		JSR	clear_line	; print	a bunch	of spaces to clear screen line
					;
					; entry: X = row to clear

loc_9B7F:				
		JMP	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9B82:				
		LDX	num_breakpoints
		BEQ	locret_9BA3	; taken	if no breakpoints set
		LDX	#0

loc_9B88:				
		TXA			; A = breakpoint index
		TAY			; Y = breakpoint index
		LDA	(word_4C),Y	; fetch	breakpoint address MSB
		STA	workspace_pointer+1
		LDA	(word_4A),Y	; fetch	breakpoint address LSB
		TAY
		LDA	#0
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		INX
		CPX	num_breakpoints
		BCC	loc_9B88

loc_9B9B:				
		JSR	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		LDY	#workspace.flag
		TXA
		STA	(workspace_pointer),Y

locret_9BA3:				
		RTS


; ---------------------------------------------------------------------------

loc_9BA4:				
		LDX	num_breakpoints
		BEQ	locret_9BA3
		LDX	#0

loc_9BAA:				
		TXA
		TAY
		LDA	(word_4C),Y	; pointer to breakpoint	address	MSBs
		STA	workspace_pointer+1
		LDA	(word_4E),Y
		PHA
		LDA	(word_4A),Y	; pointer to breakpoint	address	LSBs
		TAY
		PLA
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		INX
		CPX	num_breakpoints
		BCC	loc_9BAA
		LDX	#0
		BEQ	loc_9B9B

cmd_Z:					; print	char in	A, then	read character
		JSR	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'I'
		BEQ	cmd_ZI
		CMP	#'C'
		BEQ	cmd_ZC
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------


handle_ctrl_z:				
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9BEA
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		ASL	A
		ADC	#0
		TAX
		INX
		CPX	#3
		BNE	loc_9BE2
		LDX	#0

loc_9BE2:				
		TXA
		CLC
		ROR	A
		ROR	A
		ADC	#0
		STA	byte_51		; bit 6	= set when dual	screen mode?

loc_9BEA:				
		JMP	loc_82C2

; ---------------------------------------------------------------------------

cmd_ZC:					
		JSR	oswrch
		STA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_ZI:					
		JSR	sub_8880	; read byte value??
		CPX	#0
		BEQ	invalid_ZI_address
		JSR	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		CMP	#$D5 
		BCS	invalid_ZI_address ; taken if >=$d5 - invalid address
		CMP	#$CE 
		BCC	loc_9C15	; taken	if <$ce	- valid	address
		CPX	#$FD 
		BEQ	loc_9C12	; branch taken if Master 128
		CPX	#$F5 
		BEQ	loc_9C12	; branch taken if Master Compact

invalid_ZI_address:			
		JMP	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_9C12:				
		JMP	loc_9C94
; ---------------------------------------------------------------------------

loc_9C15:				
		CMP	#$BC 
		BCS	invalid_ZI_address
		CMP	#$80 
		BCC	loc_9C4B
		CPX	#$FF
		BNE	loc_9C3A	; branch taken if not OS 1.20
		STA	byte_25
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.text ' RAM ID? '
; ---------------------------------------------------------------------------
		NOP
		JSR	loc_8883
		AND	#$F
		STA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		JMP	loc_9C9A
; ---------------------------------------------------------------------------

loc_9C3A:				
		CPX	#$FB 
		BNE	invalid_ZI_address ; branch taken if not B+
		CMP	#$AC 
		BCS	invalid_ZI_address
		STA	byte_25
		LDA	#$40 
		STA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		JMP	loc_9C9A
; ---------------------------------------------------------------------------

loc_9C4B:				
		CMP	#$78 
		BCS	loc_9C91
		CMP	#$30 
		BCC	loc_9C8D
		CPX	#$FF
		BEQ	loc_9C94	; branch taken if OS 1.20
		JSR	is_shadow_mode	; test if current mode is a shadow mode
					;
					; exit:	C=1 if shadow
					; preserves: A/X/Y
		BCC	loc_9C94
		STA	byte_25
		JSR	print_following_string
; ---------------------------------------------------------------------------
                .text ' IN SHADOW RAM? (Y/N) '
; ---------------------------------------------------------------------------
		NOP

loc_9C78:				
		JSR	flush_input_buffer
		JSR	osrdch
		AND	#$DF 
		CMP	#'N'
		BEQ	loc_9C96
		CMP	#'Y'
		BNE	loc_9C78
		LDA	#$40 
		JMP	loc_9C98
; ---------------------------------------------------------------------------

loc_9C8D:				
		CMP	#$E
		BCS	loc_9C94

loc_9C91:				
		JMP	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_9C94:				
		STA	byte_25

loc_9C96:				
		LDA	#0

loc_9C98:				
		STA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value

loc_9C9A:				
		LDA	#22
		JSR	oswrch
		LDA	#7
		JSR	oswrch
		LDA	#$40 
		STA	byte_51		; bit 6	= set when dual	screen mode?
		JSR	sub_9CC3
		LDA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		ORA	#$80 
		STA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		JMP	loc_8269
; ---------------------------------------------------------------------------
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		JMP	dec_word_B	; decrement word_B
					;
					; preserves: A/X/Y

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9CBA:				
		BIT	byte_51		; bit 6	= set when dual	screen mode?
		BMI	locret_9CC2
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BMI	sub_9CC3

locret_9CC2:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9CC3:				
					
		LDA	word_B
		PHA
		LDA	word_B+1
		PHA
		LDA	byte_51		; bit 6	= set when dual	screen mode?
		EOR	#$40 
		STA	byte_51		; bit 6	= set when dual	screen mode?
		LDA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		PHA
		LDA	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		AND	#$F		; extract ROM slot
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BVC	loc_9CDC	; taken	if not paging in ANDY
		ORA	#$80       ; set ROMSEL bit to page in ANDY

loc_9CDC:				
		STA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		LDX	#0
		STX	byte_10
		STX	word_B
		LDA	byte_25
		STA	word_B+1
		LDA	#$7C 
		STA	byte_11

loc_9CEC:				
		JSR	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		LDY	vduws,X
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9CF9
		STA	vduws,X

loc_9CF9:				
		TYA
		JSR	sub_B000
		INC	word_B
		INX
		BPL	loc_9CEC
		LDX	#$11

loc_9D04:				
		JSR	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		LDY	$D0,X
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9D0F
		STA	$D0,X

loc_9D0F:				
		TYA
		JSR	sub_B000
		INC	word_B
		DEX
		BPL	loc_9D04
		LDA	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
		PHA
		JSR	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9D26
		STA	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)

loc_9D26:				
		PLA
		JSR	sub_B000
		INC	word_B
		LDX	byte_355
		LDA	video_ULA_values,X ; video_ULA_values[i] is video ULA control register setting for mode	i
		TAX
		LDA	#154
		JSR	osbyte		; write	to video ULA register +	OS copy	(AUG p173)
		LDA	vduws_MEMODE	; VDU variable:	memory mode (0=20K, 1=16K, 2=10K, 3=8K,	4=1K) (MasRef E.4-2)
		ASL	A
		ASL	A
		ASL	A
		ASL	A
		TAX
		LDY	#11

loc_9D42:				
		LDA	crtc_values,X	; crtc_values[i*16+j] is CRTC value for	R(11-j)	in MEMODE i
		JSR	sub_9E62
		INX
		DEY
		BPL	loc_9D42
		LDA	byte_DF
		PHA
		LDX	vduws_CSPOSN	; address at which the 6845 is to display the text cursor (MasRef E.4-2)
		LDA	vduws_CSPOSN+1	; address at which the 6845 is to display the text cursor (MasRef E.4-2)
		LDY	#14
		JSR	set_crtc_address ; set CRTC addresses of screen/cursor - R12/R13 or R14/R15
					;
					; entry: Y=base	CRTC register
					;	 X=screen address LSB
					;	 A=screen address MSB
		LDX	vduws_TOPSCN	; address of byte in top left corner of	screen display (MasRef E.4-2)
		LDA	vduws_TOPSCN+1	; address of byte in top left corner of	screen display (MasRef E.4-2)
		LDY	#12
		JSR	set_crtc_address ; set CRTC addresses of screen/cursor - R12/R13 or R14/R15
					;
					; entry: Y=base	CRTC register
					;	 X=screen address LSB
					;	 A=screen address MSB
		PLA
		STA	byte_DF
		LDX	vduws_MEMODE	; VDU variable:	memory mode (0=20K, 1=16K, 2=10K, 3=8K,	4=1K) (MasRef E.4-2)
		PHP
		SEI
		LDA	memode_latch_setting_b4,X ; memode_latch_setting_b4[i] is addressable latch bit	4 setting for MEMODE i
		STA	$FE40
		LDA	memode_latch_setting_b5,X ; memode_latch_setting_b4[i] is addressable latch bit	5 setting for MEMODE i
		STA	$FE40
		PLP

loc_9D7A:				
		JSR	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		PHA
		JSR	sub_9DC7
		JSR	sub_B000
		PLA
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BPL	loc_9D8C
		JSR	sub_9DD5

loc_9D8C:				
		INC	word_B
		BNE	loc_9D92
		INC	word_B+1

loc_9D92:				
		INC	byte_10
		BNE	loc_9D7A
		INC	byte_11
		BPL	loc_9D7A
		PLA
		STA	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		PLA
		STA	word_B+1
		PLA
		STA	word_B
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; read byte from memory
;
; entry: (word_B) = address to read from
; exit:	A = byte read
; preserves: X

read_byte:				
					
		LDA	word_B
		STA	workspace_pointer
		LDA	word_B+1
		STA	workspace_pointer+1
		CMP	#$C0 
		BCS	loc_9DC2	; taken	if reading MOS/IO
		CMP	#$80 
		BCS	loc_9DB8	; taken	if reading ROM
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BVC	loc_9DC2

loc_9DB8:				
		STX	byte_9
		LDY	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		JSR	osrdrm		; read byte from ROM/screen memory
					;
					; entry: ($f6) = address
					;	 Y = ROM number	(if address in ROM)
					; exit:	A = byte read
		LDX	byte_9
		RTS
; ---------------------------------------------------------------------------

loc_9DC2:				
					; read_byte+12j
		LDY	#0
		LDA	(workspace_pointer),Y
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9DC7:				
		LDY	byte_10
		STY	workspace_pointer
		LDY	byte_11
		STY	workspace_pointer+1
		LDY	#0
		JSR	osrdrm		; read byte from ROM/screen memory
					;
					; entry: ($f6) = address
					;	 Y = ROM number	(if address in ROM)
					; exit:	A = byte read
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9DD5:				
		LDY	byte_10
		STY	workspace_pointer
		LDY	byte_11
		STY	workspace_pointer+1
		TAY
		TXA
		JSR	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		CPX	#$FF
		BEQ	loc_9DEB
		TAX
		TYA
		JMP	call_oswrsc	; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
; ---------------------------------------------------------------------------

loc_9DEB:				
		TAX
		TYA
		LDY	#0
		STA	(workspace_pointer),Y
		RTS
; ---------------------------------------------------------------------------

call_oswrsc:				
		TAY			; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
		LDA	byte_D6
		PHA
		LDA	byte_D7
		PHA
		LDA	workspace_pointer
		STA	byte_D6
		LDA	workspace_pointer+1
		STA	byte_D7
		TYA
		LDY	#0
		JSR	oswrsc		; MasRef D.8-1
		PLA
		STA	byte_D7
		PLA
		STA	byte_D6
		RTS


; ---------------------------------------------------------------------------
video_ULA_values:.byte $9C
					; video_ULA_values[i] is video ULA control register setting for	mode i
		.byte $D8
		.byte $F4
		.byte $9C
		.byte $88
		.byte $C4
		.byte $88
		.byte $4B
crtc_values:	.byte 8		
					; crtc_values[i*16+j] is CRTC value for	R(11-j)	in MEMODE i
		.byte $67
		.byte 7
		.byte 1
		.byte $22
		.byte $20
		.byte 0
		.byte $26
		.byte $28
		.byte $62
		.byte $50
		.byte $7F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 9
		.byte $67
		.byte 9
		.byte 1
		.byte $1B
		.byte $19
		.byte 2
		.byte $1E
		.byte $28
		.byte $62
		.byte $50
		.byte $7F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 8
		.byte $67
		.byte 7
		.byte 1
		.byte $22
		.byte $20
		.byte 0
		.byte $26
		.byte $24
		.byte $31
		.byte $28
		.byte $3F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 9
		.byte $67
		.byte 9
		.byte 1
		.byte $1B
		.byte $19
		.byte 2
		.byte $1E
		.byte $24
		.byte $31
		.byte $28
		.byte $3F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte $13
		.byte $72
		.byte $12
		.byte $93
		.byte $1B
		.byte $19
		.byte	2
		.byte $1E
		.byte $24
		.byte $33
		.byte $28
		.byte $3F

; --------------- S U B	R O U T	I N E ---------------------------------------

; see $c95e in OS1.20

sub_9E62:				
		CPY	#7
		BCC	loc_9E8A	; branch taken if Y<7
		BNE	loc_9E6E	; branch taken if Y>7
		ADC	byte_290	; VDU vertical adjust, as set by *TV
		JMP	loc_9E8A
; ---------------------------------------------------------------------------

loc_9E6E:				
		CPY	#$A
		BNE	loc_9E7F
		TAY
		LDA	#$20 
		BIT	byte_D0		; Z=0 if VDU 5
		PHP
		TYA
		LDY	#$A
		PLP
		BEQ	loc_9E8A	; branch taken if not VDU 5
		RTS
; ---------------------------------------------------------------------------

loc_9E7F:				
		CPY	#8
		BNE	loc_9E8A
		ORA	#0
		BMI	loc_9E8A
		EOR	byte_291	; VDU interlace	toggle,	as set by *TV

loc_9E8A:				
		STY	$FE00
		STA	$FE01
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------

; set CRTC addresses of	screen/cursor -	R12/R13	or R14/R15
;
; entry: Y=base	CRTC register
;	 X=screen address LSB
;	 A=screen address MSB

set_crtc_address:			
		PHA
		LDA	byte_355
		CMP	#7
		BCS	loc_9EB4	; taken	if mode	7
		PLA
;handle bitmap calculations - divide address by 8
		STX	byte_DF
		LDX	#3

loc_9E9E:				
		LSR	A
		ROR	byte_DF
		DEX
		BNE	loc_9E9E
		LDX	byte_DF

loc_9EA6:				
		STY	$FE00
		STA	$FE01
		INY
		STY	$FE00
		STX	$FE01
		RTS
; ---------------------------------------------------------------------------
;handle teletext	calculations

loc_9EB4:				
		PLA
		SEC
		SBC	#$74 
		EOR	#$20 
		JMP	loc_9EA6


; ---------------------------------------------------------------------------
memode_latch_setting_b4:.byte	4	
					; memode_latch_setting_b4[i] is	addressable latch bit 4	setting	for MEMODE i
		.byte	4
		.byte $C
		.byte  $C
		.byte	4
memode_latch_setting_b5:.byte  $D	
					; memode_latch_setting_b4[i] is	addressable latch bit 5	setting	for MEMODE i
		.byte	5
		.byte  $D
		.byte	5
		.byte	4
; ---------------------------------------------------------------------------

cmd_M:
		JSR	sub_9F1B
		JSR	sub_9ED0
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9ED0:				
		LSR	byte_F
		BCS	loc_9EEB

loc_9ED4:				
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		BCS	locret_9F1A
		LDY	byte_11
		STY	workspace_pointer+1
		LDY	byte_10
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		INC	byte_10
		BNE	loc_9EE8
		INC	byte_11

loc_9EE8:				
		JMP	loc_9ED4
; ---------------------------------------------------------------------------

loc_9EEB:				
		LDA	byte_35
		STA	byte_10
		LDA	byte_36
		STA	byte_11

loc_9EF3:				
		LDA	byte_17
		STA	workspace_pointer+1
		LDA	byte_16
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		LDY	byte_11
		STY	workspace_pointer+1
		LDY	byte_10
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		LDY	byte_16
		BNE	loc_9F0B
		DEC	byte_17

loc_9F0B:				
		DEC	byte_16
		LDY	byte_10
		BNE	loc_9F13
		DEC	byte_11

loc_9F13:				
		DEC	byte_10
		JSR	check_fetch_address
		BCC	loc_9EF3

locret_9F1A:				
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9F1B:				
		JSR	sub_8817
		CPX	#0
		BNE	loc_9F25

loc_9F22:				
		JMP	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

loc_9F25:				
		LDA	#','
		JSR	oswrch
		JSR	sub_8870
		CPX	#0
		BEQ	loc_9F22
		STA	byte_10
		STA	byte_45
		LDA	word_1C+1
		STA	byte_11
		STA	byte_46
		SEC
		LDA	byte_10
		STA	byte_14
		SBC	word_B
		STA	byte_3D		; copy of ESCAPE/BREAK bits???
		LDA	byte_11
		STA	byte_15
		SBC	word_B+1
		STA	sim_temp
		PHP
		PLA
		STA	byte_F
		LDA	word_B
		STA	byte_38
		LDA	word_B+1
		STA	byte_39
		LDA	byte_16
		STA	byte_3A
		CLC
		ADC	byte_3D		; copy of ESCAPE/BREAK bits???
		STA	byte_35
		LDA	byte_17
		STA	byte_3B
		ADC	sim_temp
		STA	byte_36
		LDA	byte_10
		STA	byte_5E
		LDA	byte_11
		STA	byte_5F
		RTS


; ---------------------------------------------------------------------------

loc_9F72:				
		JSR	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aSplit:		.text 'Split'
; ---------------------------------------------------------------------------
		NOP
		JSR	relocator_at_error

loc_9F7E:				
		LDX	byte_37
		CPX	byte_E
		BCC	loc_9F85
		RTS
; ---------------------------------------------------------------------------

loc_9F85:				
		LDA	unk_2E,X
		STA	word_B
		STA	byte_14
		LDA	unk_32,X
		STA	word_B+1
		STA	byte_15
		LDA	byte_26+1,X
		STA	byte_16
		LDA	basic_IWA+1,X	; (BASIC) IWA
		STA	byte_17
		INC	byte_37
		JMP	loc_A05F
; ---------------------------------------------------------------------------

cmd_R:
		JSR	sub_9F1B
		LDA	#0
		STA	byte_37

loc_9FA5:				
		LDA	#':'
		JSR	oswrch
		JSR	sub_8870
		CPX	#0
		BNE	loc_9FB6
		LDX	byte_37
		JMP	loc_A031
; ---------------------------------------------------------------------------

loc_9FB6:				
		LDX	byte_37
		CLC
		ADC	byte_3D		; copy of ESCAPE/BREAK bits???
		STA	byte_26,X
		LDA	word_1C+1
		ADC	sim_temp
		STA	basic_IWA,X	; (BASIC) IWA
		CMP	byte_46
		STA	byte_46
		BCC	loc_A010
		BNE	loc_9FD1
		LDA	byte_26,X
		CMP	byte_45
		BCC	loc_A010

loc_9FD1:				
		LDA	byte_26,X
		STA	byte_45
		SEC
		SBC	#1
		STA	byte_26,X
		LDA	basic_IWA,X	; (BASIC) IWA
		SBC	#0
		STA	basic_IWA,X	; (BASIC) IWA
		LDA	#']'
		JSR	oswrch

loc_9FE5:				
		JSR	sub_8870
		CPX	#0
		BEQ	loc_9FE5
		LDX	byte_37
		CLC
		ADC	#1
		PHP
		CLC
		ADC	byte_3D		; copy of ESCAPE/BREAK bits???
		STA	unk_2E,X
		LDA	word_1C+1
		ADC	sim_temp
		PLP
		ADC	#0
		STA	unk_32,X
		CMP	byte_46
		STA	byte_46
		BCC	loc_A010
		BNE	loc_A023
		LDA	unk_2E,X
		CMP	byte_45
		BEQ	loc_A010
		BCS	loc_A023

loc_A010:				
		JSR	loc_A016
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A016:				
		JSR	osnewl

loc_A019:				
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
aError:		.text 'Error'
; ---------------------------------------------------------------------------
		NOP
		RTS
; ---------------------------------------------------------------------------

loc_A023:				
		LDA	unk_2E,X
		STA	byte_45
		INX
		STX	byte_37
		CPX	#3
		BCS	loc_A031
		JMP	loc_9FA5
; ---------------------------------------------------------------------------

loc_A031:				
		LDA	byte_35
		STA	byte_26,X
		LDA	byte_36
		STA	basic_IWA,X	; (BASIC) IWA
		LDA	#$FF
		STA	byte_57		; panel	status,	hex/disassembly???
		JSR	loc_A046
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A043:				
		JMP	loc_9F72
; ---------------------------------------------------------------------------

loc_A046:				
		JSR	sub_9ED0
		LDA	byte_26
		STA	byte_16
		LDA	basic_IWA	; (BASIC) IWA
		STA	byte_17
		STX	byte_E
		LDA	byte_14
		STA	word_B
		LDA	byte_15
		STA	word_B+1
		LDA	#0
		STA	byte_37

loc_A05F:				
		JSR	sub_891F
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		BCC	loc_A06A
		JMP	loc_9F7E
; ---------------------------------------------------------------------------

loc_A06A:				
		STA	byte_45
		JSR	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		LDA	#0
		STA	byte_47
		BCS	loc_A0ED	; branch taken if instruction invalid
		LDA	byte_D
		LSR	A
		JSR	shr5_clc
		BEQ	loc_A05F	; branch taken if 0 operand bytes
		STA	byte_F		; ?byte_F = number of operand bytes
		TAY
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		BCS	loc_A043	; effectively a	nop, right? - shr5_clc above cleared C...
		STA	byte_46
		CPY	#2
		BNE	loc_A092
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		BCS	loc_A043
		STA	byte_47

loc_A092:				
		LDA	byte_D
		CMP	#$42 
		BEQ	loc_A05F	; taken	if immediate instruction - 1<<6|2
		CMP	#$67 
		BEQ	loc_A0F8	; taken	if branch instruction -	2<<6|7
		SEC
		LDA	byte_46
		SBC	byte_38
		LDA	byte_47
		SBC	byte_39
		BCC	loc_A05F
		SEC
		LDA	byte_3A
		SBC	byte_46
		LDA	byte_3B
		SBC	byte_47
		BCC	loc_A05F
		CLC
		LDA	byte_46
		ADC	byte_3D		; copy of ESCAPE/BREAK bits???
		STA	byte_46
		LDA	byte_47
		ADC	sim_temp
		STA	byte_47
		LDA	word_B
		STA	workspace_pointer
		LDA	word_B+1
		STA	workspace_pointer+1
		JSR	sub_A139
		DEC	byte_F
		BEQ	loc_A0D4
		LDA	workspace_pointer+1
		PHA
		JSR	sub_A139

loc_A0D4:				
		LDA	byte_46
		LDY	workspace_pointer
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		DEC	byte_F
		BMI	loc_A126
		LDY	workspace_pointer
		INY
		PLA
		STA	workspace_pointer+1
		LDA	byte_47
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write

loc_A0EA:				
		JMP	loc_A05F
; ---------------------------------------------------------------------------

loc_A0ED:				
		JSR	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aData:		.text 'Data'
; ---------------------------------------------------------------------------
		NOP
		JMP	loc_A120
; ---------------------------------------------------------------------------

loc_A0F8:				
		LDA	byte_46
		STA	byte_8
		JSR	add8s		; add 8-bit sign-extended value
					;
					; entry: ?byte_8, A = 8-bit signed value (seems	these must be the same???)
					;	 word_B	= 16-bit value
					; exit:	?byte_9	= LSB of result
					;	A = MSB	of result
					; preserves: X/Y
		STA	byte_D
		SEC
		LDA	byte_9
		SBC	byte_14
		LDA	byte_D
		SBC	byte_15
		BCC	loc_A117
		SEC
		LDA	byte_16
		SBC	byte_9
		LDA	byte_17
		SBC	byte_D
		BCS	loc_A0EA

loc_A117:				
		JSR	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aRange:		.text 'Range'
; ---------------------------------------------------------------------------
		NOP

loc_A120:				
		JSR	relocator_at_error
		JMP	loc_A05F
; ---------------------------------------------------------------------------

loc_A126:				
		LDA	byte_47
		BEQ	loc_A0EA
		JSR	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aOverflow:	.text 'Overflow'
; ---------------------------------------------------------------------------
		NOP
		JMP	loc_A120

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A139:				
		LDA	workspace_pointer
		BNE	loc_A13F
		DEC	workspace_pointer+1

loc_A13F:				
		DEC	workspace_pointer
		RTS



; --------------- S U B	R O U T	I N E ---------------------------------------


relocator_at_error:			
		JSR	print_following_string
; ---------------------------------------------------------------------------
aAt:		.text ' at '
; ---------------------------------------------------------------------------
		NOP
		LDX	#4
		JMP	print_line_buffer ; print CR-terminated	line buffer contents.

					; entry: X = max # chars to print
; ---------------------------------------------------------------------------

cmd_V:
		JSR	sub_9F1B
		LDA	byte_10
		STA	byte_5E
		LDA	byte_11
		STA	byte_5F
		LDA	#0
		STA	byte_E

loc_A15E:				
		JSR	sub_87C8
		LDY	#0
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		STA	byte_F
		LDA	byte_11
		STA	workspace_pointer+1
		LDA	byte_10
		JSR	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		CMP	byte_F
		BEQ	loc_A18C
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		LDX	#0
		LDA	byte_11
		JSR	store_hex_byte_in_line_buffer
		LDA	byte_10
		JSR	store_hex_byte_in_line_buffer
		STX	byte_E
		JSR	loc_A016
		JSR	relocator_at_error

loc_A18C:				
		INC	byte_10
		BNE	loc_A192
		INC	byte_11

loc_A192:				
		JSR	check_fetch_address
		BCC	loc_A15E
		LDA	byte_E
		BNE	loc_A1A1
		JSR	print_following_string_in_red
; ---------------------------------------------------------------------------
aOk:		.text 'OK'
; ---------------------------------------------------------------------------
		NOP

loc_A1A1:				
		JMP	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------


cmd_F:
		JSR	get_S_or_F_args	; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>
		BEQ	loc_A1A1
		LDA	word_B
		STA	byte_5E
		LDA	word_B+1
		STA	byte_5F

loc_A1B1:				
		LDX	#0

loc_A1B3:				
		JSR	check_fetch_address
		BCS	loc_A1A1
		LDA	S_or_F_data,X	; buffer for search/fill data
		LDY	word_B+1
		STY	workspace_pointer+1
		LDY	word_B
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		INX
		CPX	byte_22
		BCC	loc_A1B3
		BCS	loc_A1B1
		BCC	loc_A1A1



; --------------- S U B	R O U T	I N E ---------------------------------------

; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>

get_S_or_F_args:			

; FUNCTION CHUNK AT 8D83 SIZE 00000006 BYTES

		STA	byte_E		; save command type - S	or F
		JSR	echo_and_readch	; print	char in	A, then	read character
					;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'B'
		BEQ	get_SB_or_SS_or_FB_or_FS_args
		CMP	#'S'
		BEQ	get_SB_or_SS_or_FB_or_FS_args
		JMP	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

get_SB_or_SS_or_FB_or_FS_args:		
					; get_S_or_F_args+Bj
		PHA			; save command subtype - B or S
		JSR	sub_8817
		CPX	#0
		BNE	loc_A1ED
		LDA	byte_E
		CMP	#'S'
		BNE	loc_A1A1

loc_A1ED:				
		PLA			; restore command subtype
		CMP	#'B'
		BEQ	get_SB_or_FB_args ; taken if SB	or FB

get_SS_or_FS_args:
		LDA	#'"'
		JSR	oswrch
		LDY	#$19
		JSR	read_line_buffer_n ; read input	into line buffer.
					;
					; entry: Y = max chars
		STY	byte_22		; save input length
		LDA	#'"'
		JSR	oswrch
		CPY	#0
		BEQ	locret_A22F	; bail if no input
		LDX	#24		; max search data size

loc_A209:				
		LDA	line_buffer,X
		STA	S_or_F_data,X	; save search text in search buffer
		DEX
		BPL	loc_A209
		LDA	#15
		JSR	oswrch
		LDX	#0
		STX	S_or_F_num_wildcards ; wildcard	count

loc_A219:				
		LDA	S_or_F_data,X	; buffer for search/fill data
		CMP	#'@'
		BNE	loc_A229	; taken	if not wildcard
		INC	S_or_F_num_wildcards
		LDY	S_or_F_num_wildcards
		CPY	#6
		BCS	too_many_wildcards
		STX	S_or_F_wildcards,Y ; list of indexes of	wildcards in S_or_F_data

loc_A229:				
		INX
		CPX	byte_22
		BCC	loc_A219
		INX

locret_A22F:				
		RTS
; ---------------------------------------------------------------------------

get_SB_or_FB_args:			
		LDX	#0
		STX	byte_22
		DEX
		STX	S_or_F_num_wildcards

loc_A237:				
		LDA	#','
		JSR	oswrch
		LDA	byte_E		; restore command type - S or F
		CMP	#'F'
		BEQ	get_FB_args
		JSR	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		CMP	#'@'
		BNE	loc_A26B
		JSR	oswrch
		INC	S_or_F_num_wildcards
		LDA	byte_22
		LDX	S_or_F_num_wildcards
		CPX	#5
		BCC	loc_A266

too_many_wildcards:			
		JSR	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aWildcards:	.text 'Wildcards'
; ---------------------------------------------------------------------------
		NOP

loc_A263:				
		JMP	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A266:				
		STA	S_or_F_wildcards+1,X ; list of indexes of wildcards in S_or_F_data
		JMP	loc_A27E
; ---------------------------------------------------------------------------

loc_A26B:				
		LDX	#1
		STX	byte_8
		DEX
		DEX
		JSR	loc_888E
		JMP	loc_A27A
; ---------------------------------------------------------------------------

get_FB_args:				
		JSR	loc_8883

loc_A27A:				
		CPX	#0
		BEQ	loc_A289

loc_A27E:				
		LDX	byte_22
		STA	S_or_F_data,X	; buffer for search/fill data
		INX
		STX	byte_22
		CPX	#25
		BCC	loc_A237

loc_A289:				
		INC	S_or_F_num_wildcards
		LDX	byte_22
		RTS


; ---------------------------------------------------------------------------

cmd_S:					; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>
		JSR	get_S_or_F_args
		BEQ	loc_A263
		JSR	osnewl
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		LDX	#0
		STX	basic_IWA	; (BASIC) IWA
		STX	unk_2B
		STX	basic_TOP


loc_A2A1:				
		TXA
		BNE	loc_A2AC
		LDA	word_B
		STA	byte_5E
		LDA	word_B+1
		STA	byte_5F

loc_A2AC:				
		LDY	basic_TOP
		CPY	S_or_F_num_wildcards
		BCS	loc_A2C0
		TXA
		CMP	S_or_F_wildcards+1,Y ; list of indexes of wildcards in S_or_F_data
		BNE	loc_A2C0
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		INY
		STY	basic_TOP
		BPL	loc_A2C7

loc_A2C0:				
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		CMP	S_or_F_data,X	; buffer for search/fill data
		BNE	loc_A318

loc_A2C7:				
		INX
		CPX	byte_22
		BCC	loc_A32A
		INC	basic_IWA	; (BASIC) IWA
		BNE	loc_A2D2
		INC	unk_2B

loc_A2D2:				
		LDA	byte_16
		PHA
		LDA	byte_17
		PHA
		JSR	sub_A35C
		JSR	set_command_line_text_window_and_restore_cursor
		LDX	#0
		LDA	byte_5F
		JSR	store_hex_byte_in_line_buffer
		LDA	byte_5E
		JSR	store_hex_byte_in_line_buffer


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A2EA:

; FUNCTION CHUNK AT A2A1 SIZE 00000049 BYTES

		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte 130
		.text 'Found'
; ---------------------------------------------------------------------------
		NOP
		JSR	relocator_at_error
		JSR	osnewl
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y

loc_A2FD:				
		JSR	getch
		CMP	#9
		BNE	loc_A310
		JSR	sub_832A
		JSR	sub_A35C
		JSR	set_command_line_text_window_and_restore_cursor
		JMP	loc_A2FD
; ---------------------------------------------------------------------------

loc_A310:				
		PLA
		STA	byte_17
		PLA
		STA	byte_16
		LDX	#1

loc_A318:				
		TXA
		BEQ	loc_A32A
		LDX	#0
		STX	basic_TOP
		LDA	byte_5E
		STA	word_B
		LDA	byte_5F
		STA	word_B+1
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C

loc_A32A:				
		JSR	check_fetch_address
		BCS	loc_A332
		JMP	loc_A2A1
; ---------------------------------------------------------------------------

loc_A332:				
		JSR	print_following_string_in_red
		NOP
		JSR	determine_BASIC_version
		CMP	#0
		BEQ	loc_A359	; branch taken if BASIC	not present
		LDX	basic_IWA	; (BASIC) IWA
		DEX
		TXA
		ORA	unk_2B
		PHA
		LDX	#unk_85D7.print_line_number
		JSR	call_BASIC_routine ; entry: X =	index of routine to call
		JSR	print_following_string
; ---------------------------------------------------------------------------
aFinds:		.text ' finds'
; ---------------------------------------------------------------------------
		NOP
		PLA
		BNE	loc_A359
		JSR	print_backspace

loc_A359:				
		JMP	command_line_loop_1



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A35C:				
					
		LDA	byte_5E
		STA	word_B
		LDA	byte_5F
		STA	word_B+1
		LDA	byte_62		; height of panel???
		BEQ	loc_A38B
		JSR	sub_8AB6
		LDA	#30
		JSR	oswrch		; reset	text cursor
		LDA	byte_62		; height of panel???
		STA	byte_F

loc_A374:				
		LDA	byte_57		; panel	status,	hex/disassembly???
		BEQ	loc_A37E
		JSR	disassemble_instruction_and_print
		JMP	loc_A381
; ---------------------------------------------------------------------------

loc_A37E:				
		JSR	sub_A3FA

loc_A381:				
		DEC	byte_F
		BEQ	loc_A38B
		JSR	osnewl
		JMP	loc_A374
; ---------------------------------------------------------------------------

loc_A38B:				
		LDA	word_B
		STA	byte_16
		LDA	word_B+1
		STA	byte_17
		RTS


; ---------------------------------------------------------------------------
		JSR	read_address_qqq
		STA	byte_5E
		LDA	word_1C+1
		STA	byte_5F
		RTS
; ---------------------------------------------------------------------------

cmd_D_or_L:				; save command name
		STA	byte_20
		JSR	sub_8817
		JSR	osnewl
		JSR	sub_8AA9
		JSR	show_cursor
		LDX	byte_62		; height of panel???
		STX	byte_F
		BPL	loc_A3B7

loc_A3B2:				
		LDA	#$A
		JSR	oswrch

loc_A3B7:				
		LDA	word_B+1
		STA	sim_temp
		LDA	byte_20
		CMP	#'D'
		BEQ	loc_A3C7	; taken	if this	was D
;handle L
		JSR	sub_A3FA
		JMP	loc_A3CA
; ---------------------------------------------------------------------------

loc_A3C7:				
		JSR	disassemble_instruction_and_print

loc_A3CA:				
		LDA	word_B+1
		CMP	sim_temp
		BCC	loc_A3F4
		JSR	check_fetch_address
		BCS	loc_A3F4
		JSR	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		BEQ	loc_A3F1
		BIT	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		BMI	loc_A3B2
		DEC	byte_F
		BNE	loc_A3B2
		LDX	byte_62		; height of panel???
		DEX
		STX	byte_F
		JSR	flush_input_buffer
		JSR	osrdch
		CMP	#$1B
		BNE	loc_A3B2

loc_A3F1:				
		JSR	acknowledge_ESCAPE


loc_A3F4:				
		JSR	draw_panel
		JMP	command_line_loop_3


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A3FA:				
					; RAM:A3C1p
		JSR	sub_891F
		LDA	#134
		STA	line_buffer+5
		LDA	#131
		STA	line_buffer+$1E
		LDY	#0
		LDX	#6

loc_A409:				
		JSR	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		PHA
		JSR	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		STA	line_buffer+$1F,Y
		PLA
		JSR	store_hex_byte_in_line_buffer
		INX
		INY
		CPY	#8
		BNE	loc_A409
		LDA	#$D
		STA	line_buffer+$27
		JMP	print_entire_line_buffer ; print up to 40 chars	from line buffer



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A424:				
		JSR	read_address_qqq
		CPX	#0
		BEQ	locret_A431
		STA	byte_5E
		LDA	word_1C+1
		STA	byte_5F

locret_A431:				
		RTS


; ---------------------------------------------------------------------------

cmd_E:
		JSR	sub_A424
		JSR	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		JSR	disable_cursor_editing
		LDA	byte_57		; panel	status,	hex/disassembly???
		BEQ	loc_A442
		JMP	loc_9048
; ---------------------------------------------------------------------------


loc_A442:				
		LDX	#0
		STX	byte_36
		STX	byte_57		; panel	status,	hex/disassembly???
		STX	byte_37
		INX
		STX	byte_26
		LDA	byte_5E
		STA	S_or_F_data	; buffer for search/fill data
		LDA	byte_5F
		STA	unk_2D

loc_A455:				
		JSR	flush_input_buffer
		JSR	sub_A35C
		JSR	show_cursor
		LDY	byte_37
		LDA	byte_26
		BPL	loc_A485
		LDA	#$1F
		CLC
		ADC	byte_36
		TAX
		JSR	gotoxy		; Move cursor to (x,y)
					;
					; entry: X = X coordinate
					;	 Y = Y coordinate
					; preserves: X/Y
		JSR	getch
		PHA
		JSR	sub_A4C8
		PLA
		BCS	loc_A455

loc_A477:				
		LDY	unk_2D
		STY	workspace_pointer+1
		LDY	S_or_F_data	; buffer for search/fill data
		JSR	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		JSR	sub_A52E
		BCS	loc_A455

loc_A485:				
		LDA	byte_36
		ASL	A
		CLC
		ADC	byte_36
		CLC
		ADC	#6
		TAX
		JSR	gotoxy		; Move cursor to (x,y)
					;
					; entry: X = X coordinate
					;	 Y = Y coordinate
					; preserves: X/Y
		JSR	print_following_string
; ---------------------------------------------------------------------------
		.byte	8		; 0
		.byte 131		; 1
		.byte	9		; 2
		.byte	9		; 3
		.byte 134		; 4
		.byte	8		; 5
		.byte	8		; 6
		.byte	8		; 7
; ---------------------------------------------------------------------------
		NOP

loc_A49E:				
		JSR	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		PHP
		PHA
		JSR	sub_A4C8
		PLA
		BCC	loc_A4AC
		PLA
		BCS	loc_A455

loc_A4AC:				
		PLP
		BVS	loc_A49E
		LDX	#1
		STX	byte_8
		LDX	#$FF
		JSR	loc_888E
		JMP	loc_A477


; --------------- S U B	R O U T	I N E ---------------------------------------

; Move cursor to (x,y)
;
; entry: X = X coordinate
;	 Y = Y coordinate
; preserves: X/Y

gotoxy:					
		LDA	#31
		JSR	oswrch
		TXA
		JSR	oswrch
		TYA
		JMP	oswrch



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A4C8:				

; FUNCTION CHUNK AT 9055 SIZE 00000129 BYTES
; FUNCTION CHUNK AT A442 SIZE 00000079 BYTES
; FUNCTION CHUNK AT A544 SIZE 00000059 BYTES
; FUNCTION CHUNK AT A5A8 SIZE 00000049 BYTES

		JSR	poll_SHIFT	; poll for SHIFT key status
					;
					; exit:	X>=$80 and C=1 if shift	was pressed
					; preserves: A
		PHP
		CMP	#key_toggle_mode
		BNE	loc_A4E3
		LDA	S_or_F_data	; buffer for search/fill data
		STA	basic_P		; value	of P%
		LDA	unk_2D
		STA	basic_P+1	; value	of P%
		JSR	sub_9038
		PLA
		PLA
		PLA
		JMP	loc_9055
; ---------------------------------------------------------------------------

loc_A4E3:				
		CMP	#$88 
		BEQ	loc_A504
		CMP	#$89 
		BEQ	loc_A52B
		CMP	#$8A 
		BNE	loc_A4F2
		JMP	loc_A5A8
; ---------------------------------------------------------------------------

loc_A4F2:				
		CMP	#$8B 
		BNE	loc_A4F9
		JMP	loc_A561
; ---------------------------------------------------------------------------

loc_A4F9:				
		CMP	#$87 
		BNE	loc_A500
		JMP	loc_A5E8
; ---------------------------------------------------------------------------

loc_A500:				
		PLP
		CMP	#$7F 
		RTS
; ---------------------------------------------------------------------------

loc_A504:				
		PLP
		BCS	loc_A51B
		LDA	S_or_F_data	; buffer for search/fill data
		BNE	loc_A50D
		DEC	unk_2D

loc_A50D:				
		DEC	S_or_F_data	; buffer for search/fill data
		DEC	byte_36
		BPL	loc_A519
		LDA	#7
		STA	byte_36
		BNE	loc_A56F

loc_A519:				
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A51B:				
		LDA	#0
		STA	byte_36
		STA	byte_37
		LDA	byte_5E
		STA	S_or_F_data	; buffer for search/fill data
		LDA	byte_5F
		STA	unk_2D
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A52B:				
		PLP
		BCS	loc_A544



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A52E:				
		INC	S_or_F_data	; buffer for search/fill data
		BNE	loc_A534
		INC	unk_2D

loc_A534:				
		INC	byte_36
		LDX	byte_36
		CPX	#8
		BCC	loc_A542
		LDA	#0
		STA	byte_36
		BEQ	loc_A5B6

loc_A542:				
		SEC
		RTS


; ---------------------------------------------------------------------------


loc_A544:				
		LDA	#7
		STA	byte_36
		LDX	byte_62		; height of panel???
		DEX
		STX	byte_37
		TXA
		ASL	A
		ASL	A
		ASL	A
		CLC
		ADC	#7
		CLC
		ADC	byte_5E
		STA	S_or_F_data	; buffer for search/fill data
		LDA	#0
		ADC	byte_5F
		STA	unk_2D
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A561:				
		PLP
		BCS	loc_A582
		SEC
		LDA	S_or_F_data	; buffer for search/fill data
		SBC	#8
		STA	S_or_F_data	; buffer for search/fill data
		BCS	loc_A56F
		DEC	unk_2D

loc_A56F:				
		DEC	byte_37
		BPL	loc_A580
		INC	byte_37
		SEC
		LDA	byte_5E
		SBC	#8
		STA	byte_5E
		BCS	loc_A580
		DEC	byte_5F

loc_A580:				
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A582:				
		JSR	sub_A59D
		SEC
		LDA	byte_5E
		SBC	byte_8
		STA	byte_5E
		BCS	loc_A590
		DEC	byte_5F

loc_A590:				
		SEC
		LDA	S_or_F_data	; buffer for search/fill data
		SBC	byte_8
		STA	S_or_F_data	; buffer for search/fill data
		BCS	loc_A59B
		DEC	unk_2D

loc_A59B:				
		SEC
		RTS


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A59D:				
		LDA	byte_62		; height of panel???
		SEC
		SBC	#1
		ASL	A
		ASL	A
		ASL	A
		STA	byte_8
		RTS


; ---------------------------------------------------------------------------


loc_A5A8:				
		PLP
		BCS	loc_A5CD
		CLC
		LDA	S_or_F_data	; buffer for search/fill data
		ADC	#8
		STA	S_or_F_data	; buffer for search/fill data
		BCC	loc_A5B6
		INC	unk_2D

loc_A5B6:				
		INC	byte_37
		LDX	byte_37
		CPX	byte_62		; height of panel???
		BCC	loc_A5CB
		DEC	byte_37
		LDA	byte_5E
		CLC
		ADC	#8
		STA	byte_5E
		BCC	loc_A5CB
		INC	byte_5F

loc_A5CB:				
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A5CD:				
		JSR	sub_A59D
		CLC
		LDA	byte_5E
		ADC	byte_8
		STA	byte_5E
		BCC	loc_A5DB
		INC	byte_5F

loc_A5DB:				
		CLC
		LDA	S_or_F_data	; buffer for search/fill data
		ADC	byte_8
		STA	S_or_F_data	; buffer for search/fill data
		BCC	loc_A5E6
		INC	unk_2D

loc_A5E6:				
		SEC
		RTS
; ---------------------------------------------------------------------------

loc_A5E8:				
		PLP
		LDA	byte_26
		EOR	#$FF
		STA	byte_26
		SEC
		RTS

; ---------------------------------------------------------------------------

*=$b000
                
; --------------- S U B	R O U T	I N E ---------------------------------------


sub_B000:				
		LDY	word_B
		STY	workspace_pointer
		LDY	word_B+1
		STY	workspace_pointer+1
		BMI	loc_B016	; taken	if attempting to write to ROM/OS/IO
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BVC	loc_B011
		JMP	call_oswrsc	; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
; ---------------------------------------------------------------------------

loc_B011:				
		LDY	#0
		STA	(workspace_pointer),Y
		RTS
; ---------------------------------------------------------------------------

loc_B016:				
		CPY	#$C0 
		BCS	loc_B011	; taken	if attempting to write to MOS/IO
		BIT	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		BVC	loc_B011
;write to ANDY
		TAY
		LDA	$f4
		ORA	#$80       ; set the ANDY bit
		STA	$f4
		STA	$FE30
		TYA
		LDY	#0
		STA	(workspace_pointer),Y
		LDA	$f4
		AND	#$7F       ; unset the ANDY bit
		STA	$f4
		STA	$FE30
		RTS


; ---------------------------------------------------------------------------

*=$c000-len(timestamp)-1
		.text timestamp,13
