oswrsc=$ffb3                   ; MasRef D.8-1
osrdrm=$ffb9
unk_FFCB=$ffcb
byte_FFCC=$ffcc
byte_FFCD=$ffcd
osrdch=$ffe0
osasci=$ffe3
osnewl=$ffe7
oswrch=$ffee
osword=$fff1
osbyte=$fff4
oscli=$fff7

timestamp='Sun,04 Mar 1990.14:15:47'

;-------------------------------------------------------------------------

                .if ELECTRON

key_toggle_mode=';'             ; no TAB on Electron

; Routines in OS ROM to select a ROM. There's enough hard-coded
; addresses already. Will one more hurt?

; e39f  txa
; e3a0  sta $f4
; e3a2  jsr $e3a9
; e3a5  sta $fe05
; e3a8  rts
; e3a9  pha
; e3aa  lda #12
; e3ac  sta $fe05
; e3af  pla
; 3eb0  rts

; ff9c  pla
; ff9d  jsr $e3a0
; ffa0  pla
; ffa1  plp
; ffa2  rts

os_select_rom_x=$e39f           ;doesn't preserve A :(
os_select_rom_a=$e3a0

                .else
                
key_toggle_mode=9               ; TAB
romsel=$fe30

                .endif

;-------------------------------------------------------------------------

teletext_code: .function _code
                .cerror !(_code>=128&&_code<160),"Not a teletext control code"
                .if ELECTRON
_value=32
                .else
_value=_code
                .endif
                .endfunction _value
                
;-------------------------------------------------------------------------

                
basic_LOMEM=0   
                                        
basic_VARTOP=2
                
basic_stackptr=4        

basic_HIMEM=6   

byte_8=8;:              

byte_9=9;:              

byte_A=$A;:             

word_B=$B;:             

byte_D=$D;:             

byte_E=$E;              

byte_F=$F;              

byte_10=$10

byte_11=$11

basic_TOP=$12   

byte_14=$14

byte_15=$15

byte_16=$16

byte_17=$17
                
; (BASIC) MSB of PAGE
; (Exmon) flag indicating which text window is active???
;         bit 7 = printer on/off
basic_PAGE=$18

byte_19=$19

byte_1A=$1A

byte_1B=$1B

word_1C=$1C;    

mnemonic=$1f;:  

byte_20=$20

byte_21=$21

byte_22=$22

byte_23=$23

reg_s=$24;:             

byte_25=$25

byte_26=$26

byte_28=$28

basic_IWA=$2a ; (BASIC) IWA

unk_2B=$2b

S_or_F_data=$2c ; buffer for search/fill data

unk_2D=$2D

unk_2E=$2E

unk_30=$30

unk_32=$32

byte_35=$35

byte_36=$36

byte_37=$37

byte_38=$38

byte_39=$39

byte_3A=$3A

byte_3B=$3B

byte_3D=$3D ; copy of ESCAPE/BREAK bits???

sim_temp=$3e

cursor_x_2=$3f;:        

cursor_y_2=$40;:        

word_41=$41;    

unk_43=$43

S_or_F_wildcards=$44 ; list of indexes of wildcards in S_or_F_data

byte_45=$45

byte_46=$46

byte_47=$47

unk_49=$49

word_4A=$4A ; pointer to breakpoint     address LSBs

word_4C=$4C; ; pointer to breakpoint    address MSBs

word_4E=$4E

BASIC_version=$50 ; version number of BASIC, or 0       if unknown/not present

byte_51=$51 ; bit 6     = set when dual screen mode?

byte_52=$52

reg_a=$53

reg_x=$54

reg_y=$55

reg_p=$56

byte_57=$57 ; panel     status, hex/disassembly???

reg_pc=$58

num_breakpoints=$5a
                
; bit 7 set = shadow RAM on???
; bit 6 set = sub_B000 pages in ANDY for $8000...$bfff
; bits 0..3 = ROMSEL value
byte_5B=$5B
                
byte_5C=$5C

byte_5D=$5D

byte_5E=$5E

byte_5F=$5F

byte_60=$60

current_rom=$61;: ; if bit 6 set,       ROM has been explicitly set
                
byte_62=$62 ; height of panel???
                
cursor_x=$63
cursor_y=$64
                
S_or_F_num_wildcards=$65
                
workspace_code=$66 ; points to code region      in workspace, +$92
                
line_buffer=$68
                
byte_D0=$D0
byte_D6=$D6
byte_D7=$D7
byte_DF=$DF
                
word_F2=$F2;
                
workspace_pointer=$f6
                
byte_FD=$FD
byte_FE=$FE
                
BRKV=$202
WRCHV=$20e
                
byte_241=$241 ; input   source (OSBYTE 177, AUG p186)
byte_24A=$24A ; ROM active at   last BRK (OSBYTE 186, AUG p194)
byte_24B=$24B ; ROM socket containing   BASIC (OSBYTE 187, AUG p195)
byte_254=$254 ; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
byte_258=$258 ; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
byte_26A=$26A ; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
byte_27A=$27A ; flag indicating Tube presence   ($00=none, $ff=Tube) (OSBYTE 234, AUG p230)
byte_27C=$27C ; character destination   status (OSBYTE 236, AUG p232)
byte_27D=$27D ; cursor editing status   (OSBYTE 237, AUG p233)
workspace_page_number=$280;: ; set by OSBYTE    240 (AUG p234)
byte_28C=$28C ; current language ROM number (OSBYTE 252, AUG p243; OSBYTE 142, AUG p166)
byte_290=$290 ; VDU vertical adjust, as set by *TV
byte_291=$291 ; VDU interlace   toggle, as set by *TV
vduws=$300
vduws_CSPOSN=$34a ; address at which the 6845 is to display the text cursor (MasRef E.4-2)
vduws_TOPSCN=$350 ; address of byte in top left corner of       screen display (MasRef E.4-2)
byte_355=$355
vduws_MEMODE=$356; VDU variable:        memory mode (0=20K, 1=16K, 2=10K, 3=8K, 4=1K) (MasRef E.4-2)
basic_O=$43c;value of O%
basic_P=$440;value of P%
XWRCHV=$db4

;-------------------------------------------------------------------------

max_num_breakpoints=7
                
workspace: .block

                .virtual 0

unk_flag_1:
                .fill 1
vdu_queue_counter:
                .fill 1
old_0254:
                .fill 1
old_0258:
                .fill 1
old_027c:
                .fill 1
old_027d:
                .fill 1
old_0241:
                .fill 1
unk_flag_2:
                .fill 1
zp:
                .fill $8a
code:
                .fill workspace_code_end-workspace_code_begin

flag:
                .fill 1

breakpoint_lsbs:
                .fill max_num_breakpoints
breakpoint_msbs:
                .fill max_num_breakpoints
breakpoint_contents:
                .fill max_num_breakpoints
rest:
                .cerror *>=$f6,"workspace is too large"
                
                ; there is more stuff here, but I don't yet know what!
                ; At least a copy of $f6/$f7 at +$f6/+$f7, so those
                ; two spots have to be free.
                
                .endv
                
                .bend
                
;-------------------------------------------------------------------------

*=$8000
                
; ---------------------------------------------------------------------------
                jmp     language
; ---------------------------------------------------------------------------
                jmp     service
; ---------------------------------------------------------------------------
                .byte %11000010         ; has service entry; has language entry; bit 1 set
                .byte rom_copyright - $8000             ; expr: rom_copyright&$ff
                .byte   0
rom_title:      .text 'EXMON II'        
rom_version:
                .byte 0
                .text '2.03'
                .if ELECTRON
                .text 'E'
                .endif
rom_copyright:
                .byte 0
                .text '(C)1990 Beebug'
                .byte 0
                
; ---------------------------------------------------------------------------

service:                                
                pha
                txa
                pha
                tya
                pha
                tsx
                lda     $103,x          ; get A
                cmp     #9
                beq     service_help    ; taken if *HELP
                cmp     #4
                beq     service_star    ; taken if * command
                cmp     #$FE 
                beq     service_tube_post_init ; taken if Tube post init

service_done:                           
                pla
                tay
                pla
                tax
                pla
                rts
; ---------------------------------------------------------------------------

service_help:                           
                lda     (word_F2),y
                cmp     #$D
                bne     service_done    ; taken if any *HELP args
                jsr     print_newline_and_rom_title
                jsr     print_one_space ; print one space
                                        ;
                                        ; preserves: X/Y
                jsr     print_rom_title
                jsr     osnewl
                jmp     service_done

; --------------- S U B R O U T I N E ---------------------------------------


print_newline_and_rom_title:            
                jsr     osnewl
                ldx     #$FF



; --------------- S U B R O U T I N E ---------------------------------------


print_rom_title:                        
                inx
                lda     rom_title,x     ; "EXMON II"
                jsr     oswrch
                ora     #0
                bne     print_rom_title
                rts


; ---------------------------------------------------------------------------

service_tube_post_init:                 
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                ldy     #7
                lda     (workspace_pointer),y
                cmp     #$DC 
                bne     loc_8098
                ldy     #0
                lda     (workspace_pointer),y
                bne     loc_808A
                jsr     swap_zp_and_workspaces

loc_808A:                               
                ldy     #$51 
                lda     (workspace_pointer),y
                asl     a
                asl     a
                bcc     loc_8098
                lda     #0
                ldy     #$5B 
                sta     (workspace_pointer),y

loc_8098:                               
                jmp     service_done
; ---------------------------------------------------------------------------

service_star:                           
                ldx     #$FF
                dey

loc_809E:                               
                inx
                iny
                lda     rom_title,x     ; "EXMON II"
                beq     loc_80B5        ; taken if end of command reached
                lda     ($F2),y         ; fetch command line char
                and     #$DF            ; toupper
                cmp     rom_title,x     ; "EXMON II"
                beq     loc_809E        ; taken if char matched
                txa
                beq     service_done
                cpx     #2
                beq     service_done

loc_80B5:                               
                lda     ($F2),y
                cmp     #' '
                beq     match           ; taken if space - so it was a match
                cmp     #$D
                bne     service_done    ; taken if neither CR nor space - so not a match

match:
                bit     byte_27A        ; check for Tube
                bmi     not_over_Tube_brk ; taken if Tube
                cmp     #' '
                beq     skip_spaces     ; taken if char was space - so maybe some args?
                
loc_80C8:                               
                lda     workspace_page_number ; get workspace page
                jsr     check_workspace_page ; check workspace page is valid.
                                        ;
                                        ; entry: A=workspace page
                                        ; exit: C=0 if valid, C=1 if invalid
                bcc     loc_8106        ; taken if workspace page valid
                lda     #5
                sta     workspace_page_number ; reset workspace page to 5 if it was invalid
                bne     loc_8106        ; jmp, in effect

skip_spaces:                            
                iny
                lda     (word_F2),y
                cmp     #' '
                beq     skip_spaces
                cmp     #$D
                beq     loc_80C8        ; taken if command line tail all spaces - so no args
                lda     word_1C
                pha
                lda     word_1C+1
                pha
                lda     word_F2
                sta     workspace_pointer
                lda     word_F2+1
                sta     workspace_pointer+1
                jsr     parse_hex
                tax                     ; X = workspace page
                pla
                sta     word_1C+1
                pla
                sta     word_1C
                txa
                jsr     check_workspace_page ; check workspace page is valid.
                                        ;
                                        ; entry: A=workspace page
                                        ; exit: C=0 if valid, C=1 if invalid
                bcs     loc_8098        ; bail if specified workspace page not valid - will probably end up with a Bad command error
                sta     workspace_page_number ; store new workspace page
                jsr     workspace_setup_qqq

loc_8106:                               
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                lda     #1
                sta     (workspace_pointer),y
                tya
                ldy     #workspace.flag 
                sta     (workspace_pointer),y
                pla
                pla
                tax
                pla
                lda     #142            ; enter language ROM
                                        ; AUG p166, MasRef D.2-44
                jmp     osbyte
; ---------------------------------------------------------------------------
not_over_Tube_brk_data:.text 0,0,'Not over tube',0 
; ---------------------------------------------------------------------------

not_over_Tube_brk:                      
                ldx     #$F

loc_812D:                               
                lda     not_over_Tube_brk_data,x ; "Not over tube"
                sta     $100,x
                dex
                bpl     loc_812D
                jmp     $100

; --------------- S U B R O U T I N E ---------------------------------------

; check workspace page is valid.
;
; entry: A=workspace page
; exit: C=0 if valid, C=1 if invalid

check_workspace_page:                   
                jsr     get_machine_type ; Read machine type, as per OSBYTE $81
                                        ;
                                        ; exit: X=machine type
                                        ; preserves: A/Y
                cmp     #$D9 
                bcs     invalid         ; taken if >=$d9 - never valid
                cmp     #$CE 
                bcc     loc_814F        ; taken if <$ce - never valid
                cpx     #$FD       ; Master 128
                beq     valid           ; taken if $cf-$d8 inclusive and Master-type hardware
                cpx     #$F5       ; Master Compact
                beq     valid           ; taken if $cf-$d8 inclusive and Master-type hardware
                jmp     invalid         ; taken if $cf-$d8 inclusive but not Master - so not valid
; ---------------------------------------------------------------------------

loc_814F:                               
                cmp     #$80 
                bcs     invalid         ; taken if >=$80 - never valid
                cmp     #$7C 
                bcc     loc_8163        ; taken if <$7c - probably valid
                cpx     #$FF
                beq     invalid         ; taken if $7c-$7f inclusive, and OS 1.20 - never valid
                jsr     is_shadow_mode  ; test if current mode is a shadow mode
                                        ;
                                        ; exit: C=1 if shadow
                                        ; preserves: A/X/Y
                bcc     invalid         ; taken if $7c...$7f inclusive, and not a shadow mode - not valid
                jmp     valid
; ---------------------------------------------------------------------------

loc_8163:                               
                cmp     #$D
                beq     invalid         ; taken if workspace is in NMI area - never valid
                cmp     #8
                beq     invalid         ; taken if workspace is in MOS sound workspace - never valid
                cmp     #4
                bcc     invalid         ; taken if workspace is in MOS workspace region - never valid

valid:                                  
                                        
                clc
                rts
; ---------------------------------------------------------------------------

invalid:                                
                                        
                sec
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; test if current mode is a shadow mode
;
; exit: C=1 if shadow
; preserves: A/X/Y

is_shadow_mode:                         
                pha
                lda     byte_D0         ; VDU status byte
                and     #$10            ; bit 4 = shadow status
                cmp     #$10            ; set C if in shadow mode
                pla
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; Read machine type, as per OSBYTE $81
;
; exit: X=machine type
; preserves: A/Y

get_machine_type:                       
                                        
                pha
                tya
                pha
                lda     #129
                ldx     #0
                ldy     #255
                jsr     osbyte          ; read machine type, AUG 152
                pla
                tay
                pla
                rts



; --------------- S U B R O U T I N E ---------------------------------------


workspace_setup_qqq:                    
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                tya                     ; A=0
                ldy     #workspace.flag 
                sta     (workspace_pointer),y
                lda     #$dc
                ldy     #workspace.unk_flag_2
                sta     (workspace_pointer),y
                ldy     #$51    ;TODO - should be #byte_51???
                lda     #0

loc_819E:                               
                sta     (workspace_pointer),y
                iny
                cpy     #$61 
                bcc     loc_819E
                lda     byte_24B        ; ROM socket containing BASIC (OSBYTE 187, AUG p195)
                sta     (workspace_pointer),y
                lda     #$E
                iny
                sta     (workspace_pointer),y
                rts


; ---------------------------------------------------------------------------

language:                               
                ldx     #$FF
                txs
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                lda     (workspace_pointer),y
                beq     workspace_ready
                jsr     swap_zp_and_workspaces
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                tya                     ; A=0
                sta     (workspace_pointer),y ; indicate workspace ready

workspace_ready:                        
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                ldy     #workspace.unk_flag_2
                lda     (workspace_pointer),y
                cmp     #$DC 
                beq     loc_81D7
                jsr     swap_zp_and_workspaces
                jsr     workspace_setup_qqq
                jsr     swap_zp_and_workspaces

loc_81D7:                               
                lda     workspace_pointer+1
                sta     workspace_code+1 ; points to code region in workspace, +$92
                sta     word_4A+1       ; pointer to breakpoint address LSBs
                sta     word_4C+1       ; pointer to breakpoint address MSBs
                sta     word_4E+1
                lda     #workspace.code
                sta     workspace_code  ; points to code region in workspace, +$92
                lda     #workspace.breakpoint_lsbs
                sta     word_4A         ; pointer to breakpoint address LSBs
                lda     #workspace.breakpoint_msbs
                sta     word_4C         ; pointer to breakpoint address MSBs
                lda     #workspace.breakpoint_contents
                sta     word_4E
                ldy     #workspace_code_end-1-workspace_code_begin

loc_81F3:                               
                lda     workspace_code_begin,y
                sta     (workspace_code),y ; points to code region in workspace, +$92
                dey
                bpl     loc_81F3
                ; fix up operands - ROM socket of Exmon
                lda     $f4
                ldy     #loc_8569+1-loc_8563
                sta     (workspace_code),y ; fix up 8569: ldx #$ff
                ldy     #loc_859D+1-loc_8563
                sta     (workspace_code),y ; fix up 859d: lda #$ff
                ; fix up operands - MSB of workspace page
                lda     workspace_code+1 ; get workspace page
                ldy     #loc_8563+2-loc_8563
                sta     (workspace_code),y ; fix up 8563: jsr $059c
                ldy     #loc_8584+2-loc_8563
                sta     (workspace_code),y ; fix up 8584: jsr $05ca
                ldy     #loc_8595+2-loc_8563
                sta     (workspace_code),y ; fix up 8595: jsr $05ca
                ldy     #loc_85A7+2-loc_8563
                sta     (workspace_code),y ; fix up 85a7: jsr $059f
                ldy     #loc_85AC+2-loc_8563
                sta     (workspace_code),y ; fix up 85ac: jmp $0598
                lda     byte_51         ; bit 6 = set when dual screen mode?
                and     #$81 
                sta     byte_51         ; bit 6 = set when dual screen mode?
                ldy     #0
                sty     byte_52
                sty     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                dey
                sty     byte_23
                ldx     reg_x
                ldy     reg_y
                clc
                lda     reg_pc
                adc     #2
                sta     reg_pc
                lda     reg_pc+1
                adc     #0
                pha
                lda     reg_pc
                pha
                lda     reg_p
                pha
                lda     reg_a
                jsr     swap_zp_and_workspaces

BRK_handler_8245:
                jsr     swap_zp_and_workspaces
                plp
                jsr     sub_8CA7
                pla
                sec
                sbc     #2
                sta     reg_pc
                pla
                sbc     #0
                sta     reg_pc+1
                tsx
                stx     reg_s
                jsr     sub_8331
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                ldy     #workspace.flag
                lda     (workspace_pointer),y
                beq     loc_8269
                jsr     loc_9BA4

loc_8269:                               
                bit     byte_51         ; bit 6 = set when dual screen mode?
                bvc     loc_8273
                jsr     sub_9CBA
                jmp     command_line_loop_1
; ---------------------------------------------------------------------------

loc_8273:                               
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte 22
                .byte 7
; ---------------------------------------------------------------------------
                nop


command_line_loop_1:                    
                jsr     print_cr
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y

command_line_loop_2:                    
                jsr     print_cr        ; redraw panel, print ?, do command line input loop
                jsr     draw_panel
                jsr     sub_A35C

command_line_loop_3:                    
                ldx     reg_s
                txs
                lda     #15
                jsr     oswrch          ; disable paged mode
                jsr     command_line_window_osnewl
                lda     #'?'
                jsr     oswrch          ; print prompt

command_line_input_loop:                
                lda     #0              ; also handler for U command
                sta     byte_258        ; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
                sta     byte_3D         ; copy of ESCAPE/BREAK bits???
                jsr     flush_input_buffer_and_readch

loc_82A2:                               
                ldx     #0
                stx     byte_21
                cmp     #key_toggle_mode
                beq     handle_toggle_hex_mcode
                cmp     #'*'
                bne     check_exclamation
                jmp     handle_star
; ---------------------------------------------------------------------------

check_exclamation:                      
                cmp     #'!'
                bne     check_cr
                jmp     handle_exclamation
; ---------------------------------------------------------------------------

check_cr:                               
                cmp     #$D
                bne     check_space

handle_cr:
                jsr     print_cr
                jsr     sub_8331

loc_82C2:                               
                jsr     sub_8910
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

check_space:                            
                cmp     #' '
                bne     check_ctrl_z

handle_space:                           ; copy of ESCAPE/BREAK bits???
                sta     byte_3D
                lda     #$D
                jsr     oswrch
                jmp     loc_96DD
; ---------------------------------------------------------------------------

check_ctrl_z:                           
                cmp     #26
                bne     check_alpha
                jmp     handle_ctrl_z
; ---------------------------------------------------------------------------

check_alpha:                            
                pha
                sec
                sbc     #'?'            ; ?=0, @=1, A=2, etc.
                bmi     command_line_input_loop ; taken if not an alpha char
                cmp     #28
                bcs     command_line_input_loop ; taken if >Z
                asl     a
                tax
                pla
                tay
                lda     command_addrs_BE,x ; big-endian
                pha                     ; push MSB
                lda     command_addrs_BE+1,x ; big-endian
                pha                     ; push LSB
                tya
                rts
; ---------------------------------------------------------------------------

handle_toggle_hex_mcode:
                lda     #118            ; update keyboard LEDs and retrieve CTRL status (AUG p140)
                jsr     osbyte
                txa                     ; A=CTRL status
                asl     a               ; get CTRL status in C
                bcc     loc_8321        ; taken if CTRL not pressed
                bit     byte_5B         ; bit 7 set = shadow RAM on???
                                        ; bit 6 set = sub_B000 pages in ANDY for $8000...$bfff
                                        ; bits 0..3 = ROMSEL value
                bpl     loc_8324
                jsr     sub_9CC3

loc_8308:                               
                jsr     osrdch
                cmp     #27
                beq     loc_8315
                jsr     osasci
                jmp     loc_8308
; ---------------------------------------------------------------------------

loc_8315:                               
                jsr     sub_9CC3
                jsr     acknowledge_ESCAPE
                jsr     sub_8910
                jmp     command_line_loop_1
; ---------------------------------------------------------------------------

loc_8321:                               
                jsr     sub_832A

loc_8324:                               
                jsr     sub_8910
                jmp     command_line_loop_1


; --------------- S U B R O U T I N E ---------------------------------------


sub_832A:                               
                lda     byte_57         ; panel status, hex/disassembly???
                eor     #$FF
                sta     byte_57         ; panel status, hex/disassembly???
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_8331:                               
                lda     byte_5C
                sta     byte_5E
                lda     byte_5D
                sta     byte_5F
                lda     byte_60
                bne     locret_8345
                lda     reg_pc
                sta     byte_5E
                lda     reg_pc+1
                sta     byte_5F

locret_8345:                            
                rts


; ---------------------------------------------------------------------------

command_addr: .macro addr
                .byte >(\addr-1)
                .byte <(\addr-1)
                .endm

command_addrs_BE:
                .command_addr cmd_help
                .command_addr cmd_at
                .command_addr cmd_A
                .command_addr cmd_B
                .command_addr cmd_C
                .command_addr cmd_D_or_L
                .command_addr cmd_E
                .command_addr cmd_F
                .command_addr cmd_G
                .command_addr cmd_H
                .command_addr cmd_I
                .command_addr cmd_J
                .command_addr cmd_K
                .command_addr cmd_D_or_L
                .command_addr cmd_M
                .command_addr cmd_N
                .command_addr cmd_O
                .command_addr cmd_P
                .command_addr cmd_Q
                .command_addr cmd_R
                .command_addr cmd_S
                .command_addr cmd_T
                .command_addr command_line_input_loop ;U = unused
                .command_addr cmd_V
                .command_addr cmd_W
                .command_addr cmd_X
                .command_addr cmd_Y
                .command_addr cmd_Z
                
; ---------------------------------------------------------------------------

cmd_help:
                jsr     oswrch
                jsr     set_output_text_window_and_cls
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .text '      SUMMARY OF MAIN COMMANDS',$D
                .text '@=set PC            A=set accumulator',$D
                .text 'BS/BC=brk set/clear C=calculate',$D
                .text 'D=disassemble       E=edit or assemble',$D
                .text 'FB/FS=fill          G=go',$D
                .text 'I=invert flag       J=JSR',$D
                .text 'L=list memory       M=move block',$D
                .text 'P=set panel start   Q=quit',$D
                .text 'R=relocate          SB/SS=search',$D
                .text 'V=verify blocks     WI=set window size',$D
                .text 'X=set X register    Y=set Y register',$D
                .text '!=change ROM        <cr>=reset panel',$D
                .text '<space>=simulate    /=one level trace',$D
                .if key_toggle_mode==9
                .text '<TAB>'
                .else
                .text key_toggle_mode
                .endif
                .text '=toggle format (hex/disassembly)'
; ---------------------------------------------------------------------------
                nop
                jmp     command_line_loop_3
; ---------------------------------------------------------------------------

workspace_code_begin:
                .logical $500+workspace.code
loc_8563:                               
                jsr     select_BASIC_ROM ;ww9c
loc_8566:
                jsr     0
loc_8569:
                ldx     #$FF
                bpl     loc_8570
select_BASIC_ROM:
                ldx     byte_24B        ; ROM socket containing BASIC (OSBYTE 187, AUG p195)

loc_8570:
                .if ELECTRON
                pha
                jsr os_select_rom_x
                pla
                .else
                stx     $f4
                stx     romsel
                .endif
                rts
; ---------------------------------------------------------------------------
;change ROM and call routine
loc_8576:
                php
                pha
loc_8578:
                lda     #$FF
                .if ELECTRON
                and #$0f        ;don't make a mess...
                jsr os_select_rom_a
                .else
                sta     $f4
                sta     romsel
                .endif
                pla
                plp
loc_8581:
                jmp     basic_LOMEM
; ---------------------------------------------------------------------------
loc_8584:
                jsr     select_exmon2_rom ;wwca
                jmp     loc_9904
; ---------------------------------------------------------------------------
loc_858A:
                beq     loc_858F
                jmp     simulated_branch_not_taken
; ---------------------------------------------------------------------------

loc_858F:                               
                jmp     simulated_branch_taken
; ---------------------------------------------------------------------------
loc_8592:
                jsr     sub_9A43
loc_8595:
                jsr     select_exmon2_rom ;wwca
                jmp     loc_9A78
; ---------------------------------------------------------------------------
select_exmon2_rom:
                php
                pha
loc_859D:
                lda     #$FF
                .if ELECTRON
                jsr os_select_rom_a
                nop
                nop
                .else
                sta     $f4
                sta     romsel
                .endif
                pla
                plp
                rts
; ---------------------------------------------------------------------------
loc_85A7:
                jsr     loc_8570
                sta     (workspace_pointer),y
loc_85AC:
                jmp     loc_8569
                .here
workspace_code_end:

; --------------- S U B R O U T I N E ---------------------------------------

determine_BASIC_version:
                ldy     byte_24B        ; ROM socket containing BASIC (OSBYTE 187, AUG p195)
                bpl     loc_85B9
                ldy     #0
                jmp     loc_85CE
; ---------------------------------------------------------------------------

loc_85B9:                               
                lda     #8
                sta     workspace_pointer
                lda     #$80 
                sta     workspace_pointer+1
                jsr     osrdrm          ; read $8008 from BASIC ROM - version number
                ldy     #5

loc_85C6:                               
                cmp     BASIC_versions-1,y
                beq     loc_85CE
                dey
                bne     loc_85C6

loc_85CE:                               
                                        ; determine_BASIC_version+1Aj
                tya
                sta     BASIC_version   ; version number of BASIC, or 0 if unknown/not present
                rts

BASIC_versions: .byte   0               ; 0
                                        ; type 1: ver $00=BASIC I
                .byte   1               ; type 2: ver $01=BASIC II
                .byte   4               ; type 3: ver $04=BASIC 4
                .byte $40 ; @           ; type 4: ver $40=BASIC 4 from Master Compact
                .byte   7               ; type 5: ver $07=BASIC 4r32

; ---------------------------------------------------------------------------

; BASIC ROM entry points
;
; 0 = assemble instruction
; 1 = get integer result of expression
; 2 = print line number on screen
; 3 = prompt for command line and execute the entered command(s) without reinitialising

num_basic_versions=5
                
basic_entry_points: .macro b1,b2,b4,b480,b4r32
                .byte <\b1
                .byte <\b2
                .byte <\b4
                .byte <\b480
                .byte <\b4r32
                .byte >\b1
                .byte >\b2
                .byte >\b4
                .byte >\b480
                .byte >\b4r32
                .endm
                
; http://8bs.com/basic/basic4-a085.htm
                
unk_85D7: .block

assemble=*-unk_85D7
                ; assemble instruction
                ; http://8bs.com/basic/basic4-89eb.htm
                .basic_entry_points $85a1,$85ba,$89eb,$89c4,$8aa8

eval_expr=*-unk_85D7
                ; get integer result of expression
                ; http://8bs.com/basic/basic4-96af.htm
                .basic_entry_points $928c,$92dd,$96af,$9690,$9774

print_line_number=*-unk_85D7
                ; print line number on screen
                ; http://8bs.com/basic/basic4-a085.htm
                .basic_entry_points $98f1,$991f,$a081,$a004,$a0e8

prompt_and_execute=*-unk_85D7
                ; prompt for command line and execute the entered
                ; command(s) without reinitialising
                ; http://8bs.com/basic/basic4-8f83.htm
                .basic_entry_points $8a99,$8af6,$8f86,$8f67,$904b
                
                .bend
                
                ; BRK vectors
unk_85FF:
                .basic_entry_points $b433,$b402,$b278,$b1ce,$b2b2                
; unk_85FF:
;               .byte $33 
;               .byte   2
;               .byte $78 
;               .byte $CE 
; unk_8603:     .byte $B2 
;               .byte $B4 
;               .byte $B4 
;               .byte $B2 
;               .byte $B1 
;               .byte $B2 

; --------------- S U B R O U T I N E ---------------------------------------

; prepare for a call to a routine in BASIC.
;
; entry: X = index of routine to call

prepare_BASIC_routine_call:             
                pha
                tya
                pha
                txa
                clc
                adc     #<(unk_85D7-1)
                sta     word_41
                lda     #>(unk_85D7-1)
                adc     #0
                sta     word_41+1
                ldy     BASIC_version   ; version number of BASIC, or 0 if unknown/not present
                lda     (word_41),y
                ldy     #loc_8566+1-loc_8563
                sta     (workspace_code),y ; fix up routine address LSB
                lda     BASIC_version   ; version number of BASIC, or 0 if unknown/not present
                clc
                adc     #num_basic_versions
                tay
                lda     (word_41),y
                ldy     #loc_8566+2-loc_8563
                sta     (workspace_code),y ; fix up routine address MSB
                pla
                tay
                pla
                rts


; ---------------------------------------------------------------------------

cmd_C:                                  ; print char in A then print one space
                jsr     print_char_then_one_space ;
                                        ; preserves: X/Y
                jsr     read_and_evaluate_expression
                cmp     #21
                bcc     loc_863D
                jsr     osnewl

loc_863D:                               
                ldx     #0
                ldy     #3

loc_8641:                               
                lda     basic_IWA,y     ; (BASIC) IWA
                jsr     store_hex_byte_in_line_buffer
                dey
                bpl     loc_8641
                jsr     print_one_space ; print one space
                                        ;
                                        ; preserves: X/Y
                jsr     print_one_space ; print one space
                                        ;
                                        ; preserves: X/Y
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print
                jsr     print_one_space ; print one space
                                        ;
                                        ; preserves: X/Y
                jsr     print_one_space ; print one space
                                        ;
                                        ; preserves: X/Y

loc_8659:                               ; print line number on screen
                ldx     #unk_85D7.print_line_number
                jsr     call_BASIC_routine ; entry: X = index of routine to call
                jmp     command_line_loop_1
; ---------------------------------------------------------------------------

read_and_evaluate_expression:           
                jsr     determine_BASIC_version
                cmp     #0
                beq     loc_8682
                jsr     read_line_buffer ; read input into line buffer. Max 40 chars
                                        ;
                                        ; exit: Y = # chars read
                tya
                pha
                lda     #$FF
                sta     byte_28
                lda     #line_buffer
                sta     byte_19
                lda     #0
                sta     byte_1A
                sta     byte_1B
                ldx     #unk_85D7.eval_expr
                                        
                jsr     call_BASIC_routine ; entry: X = index of routine to call
                pla
                rts
; ---------------------------------------------------------------------------


loc_8682:                               
                jsr     print_following_string_in_red

; ---------------------------------------------------------------------------
                .text 'BASIC?'
; ---------------------------------------------------------------------------
                nop
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

cmd_Q:
                jsr     oswrch
                jsr     determine_BASIC_version
                cmp     #0
                beq     loc_8682
                ldx     #$FF
                txs
                lda     byte_24B        ; ROM socket containing BASIC (OSBYTE 187, AUG p195)
                sta     byte_28C        ; current language ROM number (OSBYTE 252, AUG p243; OSBYTE 142, AUG p166)
                jsr     print_following_string
; ---------------------------------------------------------------------------
aBasic:         .text $16,7,'BASIC',$D,$D
; ---------------------------------------------------------------------------
                nop
                ldy     BASIC_version   ; version number of BASIC, or 0 if unknown/not present
                lda     unk_85FF-1,y
                sta     BRKV
                lda     unk_85FF-1+num_basic_versions,y
                sta     BRKV+1
                jsr     reset_WRCHV     ; reset WRCHV to default value
                ldx     #unk_85D7.prompt_and_execute
                jsr     prepare_BASIC_routine_call ; prepare for a call to a routine in BASIC.
                                        ;
                                        ; entry: X = index of routine to call
                lda     workspace_code  ; points to code region in workspace, +$92
                sta     word_F2
                lda     workspace_code+1 ; points to code region in workspace, +$92
                sta     word_F2+1
                jsr     swap_zp_and_workspaces
                ldy     #loc_8566-loc_8563
                lda     #$4C 
                sta     (word_F2),y
                jmp     (word_F2)
; ---------------------------------------------------------------------------

cmd_N:
                pha
                lda     #7
                jsr     oswrch
                pla
                jsr     echo_and_readch ; print char in A, then read character
                                        ;
                                        ; entry: A=char to print
                                        ; exit: A=char read, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y
                cmp     #$D
                beq     loc_86EA
                jmp     backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

loc_86EA:                               
                jsr     init_basic
                jsr     swap_zp_and_workspaces
                jsr     workspace_setup_qqq
                jsr     swap_zp_and_workspaces
                jsr     reset_WRCHV     ; reset WRCHV to default value
                jmp     language

; --------------- S U B R O U T I N E ---------------------------------------


init_basic:                             
                ldx     #$80 
                lda     #0

loc_8700:                               
                sta     $47F,x          ; clear BASIC varptrs
                dex
                bne     loc_8700
                jsr     swap_zp_and_workspaces
                lda     #$83       ; read OSHWM - on exit, YX=OSHWM
                jsr     osbyte
                sty     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                sty     basic_LOMEM+1
                sty     basic_VARTOP+1
                sty     basic_TOP+1
                ldy     #0
                sty     basic_LOMEM
                lda     #$D
                sta     (basic_LOMEM),y
                iny
                lda     #$FF
                sta     (basic_LOMEM),y
                sta     byte_23
                iny
                sty     basic_LOMEM
                sty     basic_VARTOP
                sty     basic_TOP
                lda     #$84       ; read HIMEM - on exit, YX=HIMEM
                jsr     osbyte
                stx     basic_stackptr
                stx     basic_HIMEM
                sty     basic_stackptr+1
                sty     basic_HIMEM+1
                jmp     swap_zp_and_workspaces



; --------------- S U B R O U T I N E ---------------------------------------

; initialize workspace pointer in ($f6)
;
; exit: ($f6) points to workspace
;       Y=0
; preserves: A/X

init_workspace_pointer:                 
                                        
                ldy     workspace_page_number ; read OSBYTE $f0 flag
                bne     loc_8746        ; taken if non-zero
                ldy     #5
                sty     workspace_page_number ; initialize to $05 if not previously set

loc_8746:                               
                sty     workspace_pointer+1
                ldy     #0
                sty     workspace_pointer
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; reset WRCHV to default value

reset_WRCHV:                            
                lda     byte_FFCC       ; read default entry point from NVWRCH+1 and NVWRCH+2.
                                        ; (Since NVWRCH is jmp $xxxx...)
                sta     WRCHV
                lda     byte_FFCD
                sta     WRCHV+1
                rts


; ---------------------------------------------------------------------------

dec_word_B:                             
                pha                     ; decrement word_B
                                        ;
                                        ; preserves: A/X/Y
                lda     word_B
                bne     loc_8761
                dec     word_B+1

loc_8761:                               
                dec     word_B
                pla
                rts

; --------------- S U B R O U T I N E ---------------------------------------

; read input into line buffer. Max 40 chars
;
; exit: Y = # chars read

read_line_buffer:                       
                ldy     #39

read_line_buffer_n:                     
                sty     byte_8          ; read input into line buffer.
                                        ;
                                        ; entry: Y = max chars
                ldy     #0

loc_876B:                               
                                        
                jsr     getch

loc_876E:                               
                cmp     #127
                bne     loc_877C        ; branch taken if not DELETE
                cpy     #0
                beq     loc_876B        ; branch taken if at start of string - nothing to delete
                jsr     oswrch          ; print delete
                dey                     ; move 1 char back
                bpl     loc_876B        ; jmp, in effect

loc_877C:                               
                bcs     loc_876B        ; branch taken if input char >=128
                cmp     #14
                beq     loc_8786        ; branch taken if CTRL+N
                cmp     #15
                bne     loc_8789        ; branch taken if neither CTRL+O nor CTRL+N

loc_8786:                               
                jsr     oswrch          ; print CTRL+O/CTRL+N char verbatim

loc_8789:                               
                sta     line_buffer,y
                cmp     #13
                beq     locret_879E     ; branch taken if done
                cpy     byte_8
                beq     loc_876B        ; branch taken if max line length hit - no more room
                cmp     #32
                bcc     loc_876B        ; branch taken if control char - don't print these
                jsr     oswrch
                iny
                bpl     loc_876B        ; jmp, in effect

locret_879E:                            
                rts



; --------------- S U B R O U T I N E ---------------------------------------


disable_cursor_editing:                 
                lda     #4
                bne     osbyte_x01



; --------------- S U B R O U T I N E ---------------------------------------


flush_input_buffer:                     
                                        
                lda     #15

osbyte_x01:                             
                ldx     #1
                jmp     osbyte



; --------------- S U B R O U T I N E ---------------------------------------


flush_input_buffer_and_readch:          
                jsr     flush_input_buffer
                jmp     readch          ; read character

                                        ; exit: A=char, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y

; --------------- S U B R O U T I N E ---------------------------------------

; poll for SHIFT key status
;
; exit: X>=$80 and C=1 if shift was pressed
; preserves: A

poll_SHIFT:                             
                                        
                pha
                lda     #121
                ldx     #128
                jsr     osbyte          ; Keyboard scan (AUG p144)
                pla
                cpx     #$80 
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; check if ESCAPE is pressed
;
; exit: Z=1 if ESCAPE pressed

poll_ESCAPE:                            
                ldx     #0
                ldy     #0
                lda     #$81       ; read key within time limit (AUG p153)
                jsr     osbyte
                cpy     #$1B
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_87C8:                               
                jsr     poll_ESCAPE     ; check if ESCAPE is pressed
                                        ;
                                        ; exit: Z=1 if ESCAPE pressed
                bne     locret_8816     ; branch taken if ESCAPE not pressed




acknowledge_ESCAPE_and_reset_cursor:    
                jsr     acknowledge_ESCAPE
                lda     #0
                sta     byte_27D        ; reset cursor editing status
                                        ; (OSBYTE 237, AUG p233; OSBYTE 4, AUG p120)
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop


; --------------- S U B R O U T I N E ---------------------------------------


acknowledge_ESCAPE:                     
                                        
                lda     #$7E 
                jmp     osbyte



; --------------- S U B R O U T I N E ---------------------------------------


getch:                                  

                jsr     osrdch
                cmp     #27
                beq     acknowledge_ESCAPE_and_reset_cursor ; branch taken if Escape pressed
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; print char in A, then read character
;
; entry: A=char to print
; exit: A=char read, toupper
;       C=1 when symbol/digit
;       V=0 when symbol/digit/xdigit
; preserves: X/Y

echo_and_readch:                        
                jsr     oswrch



; --------------- S U B R O U T I N E ---------------------------------------

; read character
;
; exit: A=char, toupper
;       C=1 when symbol/digit
;       V=0 when symbol/digit/xdigit
; preserves: X/Y

readch:                                 
                                        

; FUNCTION CHUNK AT 8815 SIZE 00000002 BYTES

                jsr     getch
                cmp     #127
                beq     locret_8816     ; taken if delete
                clv
                cmp     #'0'
                bcc     loc_8807        ; taken if definitely not hex digit
                cmp     #':'
                bcc     is_digit        ; taken if digit
                cmp     #'@'
                bcc     loc_8807        ; taken if definitely not alpha hex digit
                and     #$DF       ; toupper
                cmp     #'A'
                bcc     loc_8807        ; taken if not alpha hex digit
                cmp     #'G'
                bcs     sub_880C        ; taken if not alpha hex digit
                rts                     ; return with carry clear
; ---------------------------------------------------------------------------

loc_8807:                               
                jsr     sub_880C
                sec
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_880C:                               
                                        ; readch:loc_8807p
                pha
                lda     #$40 
                adc     #$40 
                pla
                cmp     #$5B ; '['
                rts


; ---------------------------------------------------------------------------


is_digit:                               
                sec

locret_8816:                            
                rts


; --------------- S U B R O U T I N E ---------------------------------------


sub_8817:                               
                jsr     read_address_qqq
                sta     word_B
                lda     word_1C+1
                sta     word_B+1
                ldx     #0
                stx     basic_TOP+1
                ora     word_B
                beq     loc_882A
                dec     basic_TOP+1

loc_882A:                               
                lda     #']'
                jsr     echo_and_readch ; print char in A, then read character
                                        ;
                                        ; entry: A=char to print
                                        ; exit: A=char read, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y
                cmp     #'+'
                bne     loc_8845
                jsr     oswrch
                jsr     sub_8870
                clc
                adc     word_B
                sta     byte_16
                lda     word_1C+1
                adc     word_B+1
                sta     byte_17
                rts
; ---------------------------------------------------------------------------

loc_8845:                               
                ldx     #3
                stx     byte_8
                ldx     #$FF
                jsr     loc_888E
                sta     byte_16
                lda     word_1C+1
                sta     byte_17
                txa
                bne     locret_885D
                dex
                stx     byte_16
                stx     byte_17
                inx

locret_885D:                            
                rts


; ---------------------------------------------------------------------------


loc_885E:                               
                jsr     oswrch
                jsr     read_and_evaluate_expression
                lda     unk_2B
                sta     word_1C+1
                lda     basic_IWA       ; (BASIC) IWA
                ldx     #1
                rts


; --------------- S U B R O U T I N E ---------------------------------------


read_address_qqq:                       
                jsr     print_char_then_one_space ; print char in A then print one space

                                        ; preserves: X/Y

; --------------- S U B R O U T I N E ---------------------------------------


sub_8870:                               
                ldx     #4
                jsr     loc_8885
                cpx     #0
                bne     locret_8816
                lda     reg_pc+1
                sta     word_1C+1
                lda     reg_pc
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; read byte value??

sub_8880:                               

; FUNCTION CHUNK AT 885E SIZE 0000000F BYTES

                jsr     print_char_then_one_space ; print char in A then print one space
                                        ;
                                        ; preserves: X/Y

loc_8883:                               
                ldx     #2

loc_8885:                               
                dex
                stx     byte_8
                ldx     #0
                dex

loc_888B:                               
                jsr     readch          ; read character
                                        ;
                                        ; exit: A=char, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y

loc_888E:                               
                                        
                cmp     #$D
                beq     loc_88B9
                cmp     #$7F 
                beq     loc_88AE
                bvc     loc_88A2
                cpx     #$FF
                bne     loc_888B
                cmp     #$23 ; '#'
                beq     loc_885E
                bne     loc_888B

loc_88A2:                               
                inx
                sta     line_buffer,x
                jsr     oswrch
                cpx     byte_8
                beq     loc_88B9
                bne     loc_888B

loc_88AE:                               
                cpx     #$FF
                beq     loc_888B
                jsr     oswrch
                dex
                jmp     loc_888B
; ---------------------------------------------------------------------------

loc_88B9:                               
                inx
                beq     loc_88FA
                lda     #$D
                sta     line_buffer,x
                lda     #line_buffer
                sta     workspace_pointer
                lda     #0
                sta     workspace_pointer+1
                ldy     #0

parse_hex:                              
                lda     #0
                sta     word_1C
                sta     word_1C+1

parse_hex_loop:                         
                lda     (workspace_pointer),y
                cmp     #$D
                beq     loc_88F7        ; taken if end of input
                jsr     parse_xdigit    ; parse hex digit
                                        ;
                                        ; entry: A=(hopefully) hex digit
                                        ; exit: C=0, A=value if A was valid
                                        ;       C=1 if A invalid
                bcs     loc_88F7        ; taken if error
;shift word_1C left 4
                asl     word_1C
                rol     word_1C+1
                asl     word_1C
                rol     word_1C+1
                asl     word_1C
                rol     word_1C+1
                asl     word_1C
                rol     word_1C+1
                iny
;add in new digit
                clc
                adc     word_1C
                sta     word_1C
                bcc     parse_hex_loop
                inc     word_1C+1
                bne     parse_hex_loop

loc_88F7:                               
                lda     word_1C
                rts
; ---------------------------------------------------------------------------

loc_88FA:                               
                lda     #0
                sta     word_1C+1
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; print char in A then print one space
;
; preserves: X/Y

print_char_then_one_space:              
                                        
                jsr     oswrch

print_one_space:                        
                lda     #$20 ; ' '      ; print one space
                                        ;
                                        ; preserves: X/Y

loc_8904:                               
                jmp     oswrch



; --------------- S U B R O U T I N E ---------------------------------------


print_backspace:                        
                                        
                lda     #$7F 
                bne     loc_8904



; --------------- S U B R O U T I N E ---------------------------------------


print_cr:                               
                                        
                lda     #$D
                jmp     nvoswrch



; --------------- S U B R O U T I N E ---------------------------------------


sub_8910:                               
                                        
                lda     #$B
                bne     loc_8904

print_39_spaces:                        
                ldx     #38
                lda     #$20 ; ' '

loc_8918:                               
                jsr     nvoswrch
                dex
                bpl     loc_8918
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_891F:                               
                                        
                jsr     clear_line_buffer
                inx
                lda     word_B+1
                jsr     store_hex_byte_in_line_buffer
                lda     word_B



; --------------- S U B R O U T I N E ---------------------------------------


store_hex_byte_in_line_buffer:          
                sta     byte_8
                and     #$F0 
                jsr     shr4_clc
                jsr     store_hex_nibble
                and     #$F



; --------------- S U B R O U T I N E ---------------------------------------


store_hex_nibble:                       
                ora     #$30 
                cmp     #$3A 
                bcc     store
                adc     #6

store:                                  
                sta     line_buffer,x
                inx
                lda     byte_8
                rts



; --------------- S U B R O U T I N E ---------------------------------------


clear_line_buffer:                      
                                        
                ldx     #39
                lda     #32

loc_8948:                               
                sta     line_buffer,x
                dex
                bpl     loc_8948
                rts



; --------------- S U B R O U T I N E ---------------------------------------


shr5_clc:                               
                lsr     a



; --------------- S U B R O U T I N E ---------------------------------------


shr4_clc:                               
                lsr     a
                lsr     a
                lsr     a
                lsr     a
                clc
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; get printable version of byte - use '.' for unprintables
;
; entry: A = byte
; exit: A = printable char

get_printable_char:                     
                                        
                and     #$7F 
                cmp     #32
                bcc     loc_895F
                cmp     #127
                bcc     locret_8961

loc_895F:                               
                lda     #'.'

locret_8961:                            
                rts



; --------------- S U B R O U T I N E ---------------------------------------


swap_zp_and_workspaces:                 
                php
                pha
                txa
                pha
                tya
                pha
                lda     word_F2
                pha
                lda     word_F2+1
                pha
                ldx     #0
                stx     word_F2
                ldx     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                stx     word_F2+1       ; (word_f2) = workspace pointer
;swap $08-$8f ZP        with corresponding values in workspace
                ldy     #$8F 

loc_8979:                               
                ldx     0,y             ; X=ZP value
                lda     (word_F2),y     ; A=workspace value
                sta     0,y             ; store workspace value in ZP
                txa
                sta     (word_F2),y     ; store ZP value in workspace
                dey
                cpy     #7
                bne     loc_8979
                ldx     workspace_pointer
                ldy     #$F6 
                lda     (word_F2),y
                sta     workspace_pointer
                txa
                sta     (word_F2),y
                ldx     workspace_pointer+1
                iny
                lda     (word_F2),y
                sta     workspace_pointer+1
                txa
                sta     (word_F2),y
                ldy     #0
                lda     (word_F2),y
                eor     #$FF
                sta     (word_F2),y
                pla
                sta     word_F2+1
                pla
                sta     word_F2
                pla
                tay
                pla
                tax
                pla
                plp
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; write memory
;
; entry: workspace_pointer?1 = address MSB
;        Y = address LSB
;        A = value to write

write_memory:                           
                sty     workspace_pointer
                bit     workspace_pointer+1 ; query workspace pointer MSB
                bpl     loc_89BE        ; branch taken if <$8000 - in main RAM
                bvc     loc_89DC        ; branch taken if <$C000 - in sideways RAM
                bit     current_rom     ; if bit 6 set, ROM has been explicitly set
                bvs     locret_89DB

loc_89BE:                               
                cpy     #8
                bcc     write           ; branch taken if address <$0008 - not in shadow ZP
                cpy     #$F6 
                beq     write_shadow_zp ; branch taken if address=$00f6 - in shadow ZP
                cpy     #$F7 
                beq     write_shadow_zp ; branch taken if address=$00f7 - in shadow ZP
                cpy     #$90 
                bcs     write           ; branch taken if address>=$90 - not in shadow ZP

write_shadow_zp:                        
                                        ; write_memory+16j
                ldy     workspace_pointer+1
                bne     write           ; branch taken if not ZP - existing address is fine
                ldy     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                sty     workspace_pointer+1 ; fix up address so the write is to shadow ZP

write:                                  
                                        
                ldy     #0
                sta     (workspace_pointer),y

locret_89DB:                            
                rts
; ---------------------------------------------------------------------------

loc_89DC:                               
                tay
                txa
                pha
                lda     current_rom     ; if bit 6 set, ROM has been explicitly set
                and     #$F
                cmp     $f4
                bne     loc_89EC
                pla
                tax
                ldy     #0
                rts
; ---------------------------------------------------------------------------

loc_89EC:                               
                ldx     current_rom     ; if bit 6 set, ROM has been explicitly set
                lda     workspace_code  ; points to code region in workspace, +$92
                pha
                lda     #loc_85A7-loc_8563+workspace.code
                sta     workspace_code  ; points to code region in workspace, +$92
                tya
                ldy     #0
                jsr     sub_8A01
                pla
                sta     workspace_code  ; points to code region in workspace, +$92
                pla
                tax
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_8A01:                               
                jmp     (workspace_code) ; points to code region in workspace, +$92



; --------------- S U B R O U T I N E ---------------------------------------

; read byte from memory
;
; entry: workspace_pointer=address
; exit: A = byte read
; preserves: X

read_memory_workspace_pointer:          
                                        
                lda     workspace_pointer



; --------------- S U B R O U T I N E ---------------------------------------

; read byte from memory
;
; entry: A=LSB
;        workspace_pointer MSB=MSB
; exit: A=byte read
; preserves: X

read_memory:                            
                                        
                sta     workspace_pointer ; store address LSB
                ldy     workspace_pointer+1
                bne     loc_8A29        ; branch taken if not zero page
                cmp     #8
                bcc     loc_8A29        ; branch taken if <$0008 - can read directly
                cmp     #workspace_pointer
                beq     loc_8A1C        ; branch taken if workspace_pointer - must read from workspace
                cmp     #workspace_pointer+1
                beq     loc_8A1C        ; branch taken if workspace_pointer - must read from workspace
                cmp     #$90 
                bcs     loc_8A29        ; branch taken if >=$90 - can read directly

loc_8A1C:                               
                                        ; read_memory+10j
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                tay
                lda     (workspace_pointer),y ; fetch byte from copy of zero page
                sty     workspace_pointer ; update workspace_pointer with full address
                ldy     #0
                sty     workspace_pointer+1 ; MSB is 0 - it's zero page
                rts
; ---------------------------------------------------------------------------

loc_8A29:                               
                                        
                cpy     #$C0 
                bcs     loc_8A3B        ; branch taken if MOS/IO
                cpy     #$80 
                bcc     loc_8A3F        ; branch taken if paged ROM

loc_8A31:                               
                stx     byte_9
                ldy     current_rom     ; if bit 6 set, ROM has been explicitly set
                jsr     osrdrm          ; read byte from ROM/screen memory
                                        ;
                                        ; entry: ($f6) = address
                                        ;        Y = ROM number (if address in ROM)
                                        ; exit: A = byte read
                ldx     byte_9
                rts
; ---------------------------------------------------------------------------

loc_8A3B:                               
                bit     current_rom     ; if bit 6 set, ROM has been explicitly set
                bvs     loc_8A31

loc_8A3F:                               
                ldy     #0
                lda     (workspace_pointer),y
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; fetch byte using read_memory with post-increment.
;
; entry: (word_B) - address to fetch from
; preserves: Y/C

fetch_memory:                           
                                        
                sty     byte_8
                jsr     check_fetch_address
                php
                lda     word_B+1
                sta     workspace_pointer+1
                lda     word_B
                jsr     read_memory     ; read byte from memory
                                        ;
                                        ; entry: A=LSB
                                        ;        workspace_pointer MSB=MSB
                                        ; exit: A=byte read
                                        ; preserves: X
                inc     word_B
                bne     loc_8A59
                inc     word_B+1

loc_8A59:                               
                ldy     byte_8
                plp
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; parse hex digit
;
; entry: A=(hopefully) hex digit
; exit: C=0, A=value if A was valid
;       C=1 if A invalid

parse_xdigit:                           
                cmp     #$47 ; 'G'
                bcs     done_with_carry_set ; taken if >'F'
                cmp     #$30 ; '0'
                bcc     done_with_carry_set ; taken if <'0'
                cmp     #$3A ; ':'
                bcc     is_xdigit       ; taken if <='9'
                cmp     #$41 ; 'A'
                bcc     done_with_carry_set ; taken if <'A'

is_xdigit:                              
                sec
                sbc     #$30 ; '0'      ; get value assuming digit
                cmp     #$A             ; was it actually alpha?
                bcc     done            ; branch taken if digit - exit with C=0
                sbc     #7              ; adjust

done_with_carry_clear:                  
                clc

done:                                   
                rts



; --------------- S U B R O U T I N E ---------------------------------------


check_fetch_address:                    
                lda     word_B
                ora     word_B+1
                bne     loc_8A84        ; branch taken if address non-zero
                bit     basic_TOP+1
                bmi     done_with_carry_set
                dec     basic_TOP+1

loc_8A84:                               
                lda     word_B+1
                cmp     byte_17
                bcc     done_with_carry_clear
                bne     done_with_carry_set
                lda     byte_16
                cmp     word_B
                bcs     done_with_carry_clear

done_with_carry_set:                    
                                        
                sec
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; print up to 40 chars from line buffer

print_entire_line_buffer:               
                                        
                ldx     #40



; --------------- S U B R O U T I N E ---------------------------------------

; print CR-terminated line buffer contents.
;
; entry: X = max # chars to print

print_line_buffer:                      
                stx     byte_8
                ldx     #0

loc_8A9A:                               
                lda     line_buffer,x
                jsr     oswrch
                inx
                cpx     byte_8
                bcs     locret_8AA8
                cmp     #$D
                bne     loc_8A9A

locret_8AA8:                            
                rts



; --------------- S U B R O U T I N E ---------------------------------------


sub_8AA9:                               
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                ora     #1
                sta     basic_PAGE      ; (BASIC) MSB of PAGE

                                        ;         bit 7 = printer on/off

; --------------- S U B R O U T I N E ---------------------------------------


set_output_text_window_and_cls:         
                jsr     set_output_text_window
                lda     #12             ; CLS
                bne     call_NVOSWRCH   ; jmp, in effect



; --------------- S U B R O U T I N E ---------------------------------------


sub_8AB6:                               
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                and     #$80 
                sta     basic_PAGE
                ; (BASIC) MSB of PAGE
                ; (Exmon) flag indicating which text window is active???
                ;         bit 7 = printer on/off

; --------------- S U B R O U T I N E ---------------------------------------


set_output_text_window:                 
                ldx     byte_62         ; height of panel???
                inx
                inx
                inx
                ldy     #4
                jsr     set_text_window ; set text window from (0,y)-(39,x)



; --------------- S U B R O U T I N E ---------------------------------------


hide_cursor:                            
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte 23
                .byte 1
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0


; ---------------------------------------------------------------------------
                nop
                rts

; --------------- S U B R O U T I N E ---------------------------------------


set_command_line_text_window:           
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                ora     #1
                sta     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                ldx     #24
                lda     num_breakpoints
                beq     loc_8AE7
;allocate space for breakpoints display
                dex
                cmp     #6
                bcc     loc_8AE7
                dex

loc_8AE7:                               
                                        ; set_command_line_text_window+Fj
                lda     byte_62         ; height of panel???
                pha
                clc
                adc     #5
                tay
                pla
                bne     set_text_window ; set text window from (0,y)-(39,x)
                dey



; --------------- S U B R O U T I N E ---------------------------------------

; set text window from (0,y)-(39,x)

set_text_window:                        
                                        
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte  28               ; 0
                .byte 0
; ---------------------------------------------------------------------------
                nop
                txa
                jsr     nvoswrch
                lda     #39
                jsr     nvoswrch
                tya

call_NVOSWRCH:                          
                jmp     nvoswrch



; --------------- S U B R O U T I N E ---------------------------------------


print_newline_then_following_string_in_red: 
                                        
                jsr     osnewl



; --------------- S U B R O U T I N E ---------------------------------------


print_following_string_in_red:          
                                        
                lda     #teletext_code(129)
                jsr     oswrch
                jmp     print_following_string


; ---------------------------------------------------------------------------
                jsr     osnewl

; --------------- S U B R O U T I N E ---------------------------------------


print_following_string:                 
                pla
                sta     word_1C
                pla
                sta     word_1C+1
                tya
                pha
                ldy     #0
                tya

loc_8B1E:                               
                jsr     handle_OSWRCH
                cmp     #$D
                bne     loc_8B29
                lda     #$A
                bne     loc_8B1E

loc_8B29:                               
                inc     word_1C
                bne     loc_8B2F
                inc     word_1C+1

loc_8B2F:                               
                lda     (word_1C),y
                cmp     #$EA 
                bne     loc_8B1E
                pla
                tay
                jmp     (word_1C)


; ---------------------------------------------------------------------------
                stx     byte_19
                sty     byte_1A
                lda     #0
                sta     byte_1B
                ldx     #unk_85D7.eval_expr

; --------------- S U B R O U T I N E ---------------------------------------

; entry: X = index of routine to call

call_BASIC_routine:                     
                jsr     prepare_BASIC_routine_call ; prepare for a call to a routine in BASIC.
                                        ;
                                        ; entry: X = index of routine to call
                jmp     (workspace_code) ; points to code region in workspace, +$92



; --------------- S U B R O U T I N E ---------------------------------------

; Print char from BASIC error message.
; Some info about BASIC error message encoding: http://8bs.com/basic/errormess.htm

sub_8B4A:                               
                cmp     #141
                bne     loc_8B65        ; branch taken if not CHR$141
                ldx     byte_24A        ; ROM active at last BRK (OSBYTE 186, AUG p194)
                cpx     byte_24B        ; ROM socket containing BASIC (OSBYTE 187, AUG p195)
                bne     loc_8B65        ; branch taken if not BASIC
                ldx     #0

loc_8B58:                               
                lda     aMissing,x      ; "Missing"
                jsr     oswrch
                inx
                cpx     #7
                bcc     loc_8B58
                lda     #$20 

loc_8B65:                               
                jmp     osasci


; ---------------------------------------------------------------------------
aMissing:       .text 'Missing'         
; ---------------------------------------------------------------------------

BRK_handler:
                lda     byte_FD
                sta     workspace_pointer
                lda     byte_FE
                sta     workspace_pointer+1
                jsr     print_following_string_in_red
; ---------------------------------------------------------------------------
                .text ' '
; ---------------------------------------------------------------------------
                nop

loc_8B7C:                               
                inc     workspace_pointer
                bne     loc_8B82
                inc     workspace_pointer+1

loc_8B82:                               
                ldy     byte_24A        ; ROM active at last BRK (OSBYTE 186, AUG p194)
                jsr     osrdrm          ; read byte following BRK
                ora     #0
                beq     loc_8B92        ; branch taken if end of message
                jsr     sub_8B4A        ; Print char from BASIC error message.
                                        ; Some info about BASIC error message encoding: http://8bs.com/basic/errormess.htm
                jmp     loc_8B7C
; ---------------------------------------------------------------------------

loc_8B92:                               
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                lda     #0
                sta     workspace_pointer
                tay
                lda     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                sta     workspace_pointer+1
                lda     (workspace_pointer),y
                beq     loc_8BA6
                jsr     swap_zp_and_workspaces

loc_8BA6:                               
                lda     byte_21
                beq     loc_8BD9
                jmp     loc_906B
; ---------------------------------------------------------------------------


handle_star:                            
                jsr     oswrch
                jsr     read_line_buffer ; read input into line buffer. Max 40 chars
                                        ;
                                        ; exit: Y = # chars read
                jsr     print_cr
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                jsr     reset_WRCHV     ; reset WRCHV to default value
                jsr     set_output_text_window_and_cls
                jsr     show_cursor
                bit     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                bpl     loc_8BCB
                lda     #2
                jsr     oswrch

loc_8BCB:                               
                jsr     swap_zp_and_workspaces
                ldx     #$68 
                ldy     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                jsr     oscli
                jsr     swap_zp_and_workspaces

loc_8BD9:                               
                lda     #3
                jsr     oswrch
                jsr     install_OSWRCH_handler
                jmp     loc_A3F4


; --------------- S U B R O U T I N E ---------------------------------------


handle_OSWRCH:                          
                pha
                tya
                pha
                txa
                pha
                tsx                     ; $101,x = X
                                        ; $102,x = Y
                                        ; $103,x = A
                lda     $103,x
                pha
                lda     byte_52
                beq     loc_8BF6
                dec     byte_52
                bpl     loc_8C32

loc_8BF6:                               
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                cmp     #$81 
                bne     loc_8C32
                pla
                pha
                cmp     #$7F 
                beq     loc_8C32
                cmp     #$D
                beq     loc_8C17
                cmp     #$11
                bcc     loc_8C32
                cmp     #$20 
                bcs     loc_8C17
                tax
                lda     num_vdu_parameters - $11,x ; # parameters for VDU commands, starting at VDU 17
                sta     byte_52
                jmp     loc_8C32
; ---------------------------------------------------------------------------

loc_8C17:                               
                                        ; handle_OSWRCH+28j
                lda     #3
                ldx     #$A
                jsr     osbyte
                pla
                pha
                cmp     #$80 
                bcc     loc_8C26
                lda     #$20 

loc_8C26:                               
                jsr     nvoswrch
                cmp     #$D
                bne     loc_8C32
                lda     #$A
                jsr     nvoswrch

loc_8C32:                               
                                        
                lda     #3
                ldx     #0
                jsr     osbyte
                pla
                pla
                tax
                pla
                tay
                pla



; --------------- S U B R O U T I N E ---------------------------------------

; Attributes: thunk

nvoswrch:                               
                                        
                jmp     unk_FFCB


; ---------------------------------------------------------------------------

wrch_8c42:
                pha
                tya
                pha
                txa
                pha
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                ldy     #$20 
                lda     (workspace_pointer),y
                bne     loc_8C57
                jsr     set_output_text_window_and_cls
                ldy     #$20 
                sta     (workspace_pointer),y

loc_8C57:                               
                ldy     #1
                lda     (workspace_pointer),y
                beq     loc_8C64        ; taken if not buffering in VDU queue
                sec
                sbc     #1
                sta     (workspace_pointer),y
                bpl     loc_8C92

loc_8C64:                               
                tsx
                lda     $103,x          ; fetch char to print
                cmp     #7
                beq     pass_on_to_OSWRCH
                cmp     #10
                beq     pass_on_to_OSWRCH
                cmp     #13
                beq     pass_on_to_OSWRCH
                cmp     #17
                bcc     loc_8C92        ; taken if <17 - these codes have 0 parameters
                                        ; (except for VDU1! - a bug?)
                cmp     #127
                beq     loc_8C92        ; skip 127s
                cmp     #32
                bcs     pass_on_to_OSWRCH ; print >=32
                tax
                lda     num_vdu_parameters - $11,x ; # parameters for VDU commands, starting at VDU 17
                ldy     #1

loc_8C86:
                sta     (workspace_pointer),y
                bpl     loc_8C92

pass_on_to_OSWRCH:                      
                pla
                tax
                pla
                tay
                pla
                jmp     handle_OSWRCH
; ---------------------------------------------------------------------------

loc_8C92:                               
                pla
                tax
                pla
                tay
                pla
                rts
; ---------------------------------------------------------------------------
num_vdu_parameters:.byte   1,  2,  5,  0,  0,  1,  9,  8; 0 
                                        ; RAM:8C81r
                .byte   5,  0,  0,  4,  4,  0,  2; 8 ; # parameters for VDU commands, starting at VDU 17

; --------------- S U B R O U T I N E ---------------------------------------


sub_8CA7:                               
                sta     reg_a
                stx     reg_x
                sty     reg_y
                php
                pla
                sta     reg_p
                cli
                cld
                jsr     init_workspace_pointer ; initialize workspace pointer in ($f6)
                                        ;
                                        ; exit: ($f6) points to workspace
                                        ;       Y=0
                                        ; preserves: A/X
                ldy     #2
                lda     byte_254        ; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
                sta     (workspace_pointer),y
                lda     byte_258        ; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
                iny
                sta     (workspace_pointer),y
                lda     byte_27C        ; character destination status (OSBYTE 236, AUG p232)
                iny
                sta     (workspace_pointer),y
                lda     byte_27D        ; cursor editing status (OSBYTE 237, AUG p233)
                iny
                sta     (workspace_pointer),y
                lda     byte_241        ; input source (OSBYTE 177, AUG p186)
                iny
                sta     (workspace_pointer),y
                lda     #0
                sta     byte_241        ; input source (OSBYTE 177, AUG p186)
                sta     byte_258        ; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
                sta     byte_27C        ; character destination status (OSBYTE 236, AUG p232)
                lda     #50
                sta     byte_254        ; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
                jsr     install_OSWRCH_handler
                bit     byte_51         ; bit 6 = set when dual screen mode?
                bvs     loc_8CF2
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte 6,3
; ---------------------------------------------------------------------------
                nop

loc_8CF2:                               
                lda     #<BRK_handler
                sta     BRKV
                lda     #>BRK_handler
                sta     BRKV+1
                rts



; --------------- S U B R O U T I N E ---------------------------------------


install_OSWRCH_handler:                 
                lda     #<handle_OSWRCH
                sta     XWRCHV
                lda     #>handle_OSWRCH
                sta     XWRCHV+1
                lda     $f4
                sta     XWRCHV+2
                lda     #$15
                sta     WRCHV
                lda     #$FF
                sta     WRCHV+1
                rts



; --------------- S U B R O U T I N E ---------------------------------------


print_register_values:                  
                jsr     clear_line_buffer
                lda     reg_a
                ldx     #0
                jsr     store_hex_byte_in_line_buffer ; print A
                lda     reg_x
                inx
                jsr     store_hex_byte_in_line_buffer ; print X
                lda     reg_y
                inx
                jsr     store_hex_byte_in_line_buffer ; print Y
                lda     reg_s
                inx
                jsr     store_hex_byte_in_line_buffer ; print S
                lda     reg_p
                inx
                jsr     store_hex_byte_in_line_buffer ; print P (as hex)
                ldx     #6
                sta     byte_8          ; save temp copy of P

loc_8D3D:                               
                cpx     #1
                bne     loc_8D43
                lsr     byte_8

loc_8D43:                               
                lsr     byte_8
                bcc     loc_8D4C
                lda     p_bit_names,x   ; "NVBDIZC"
                sta     line_buffer+$F,x

loc_8D4C:                               
                dex
                bpl     loc_8D3D
                lda     reg_pc+1
                ldx     #23
                jsr     store_hex_byte_in_line_buffer ; print PC MSB
                lda     reg_pc
                jmp     store_hex_byte_in_line_buffer ; print PC LSB


; ---------------------------------------------------------------------------
p_bit_names:    .text 'NVBDIZC'         
; ---------------------------------------------------------------------------

cmd_I:                                  ; print char in A, then read character
                jsr     echo_and_readch ;
                                        ; entry: A=char to print
                                        ; exit: A=char read, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y
                cmp     #'S'
                beq     cmd_IS          ; taken if command is IS - set S
                cmp     #'P'
                beq     cmd_IP          ; taken if command is IP - set P
                ldx     #1
                stx     byte_9
                ldx     #6

loc_8D73:                               
                cpx     #1
                bne     loc_8D79
                asl     byte_9

loc_8D79:                               
                cmp     p_bit_names,x   ; "NVBDIZC"
                beq     loc_8D89
                asl     byte_9
                dex
                bpl     loc_8D73


backspace_then_command_line_input_loop: 
                jsr     print_backspace
                jmp     command_line_input_loop ; also handler for U command

; ---------------------------------------------------------------------------

loc_8D89:                               
                jsr     oswrch
                lda     reg_p
                eor     byte_9
                sta     reg_p
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

cmd_IS:                                 
                jsr     sub_8880        ; read byte value??
                cpx     #0
                bne     loc_8D9E
                lda     #$FF

loc_8D9E:                               
                cmp     #$6F 
                bcs     loc_8DA5
                jmp     error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_8DA5:                               
                sta     reg_s
                bcs     loc_8DAE

cmd_IP:                                 
                jsr     sub_8880        ; read byte value??
                sta     reg_p

loc_8DAE:                               
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop

; --------------- S U B R O U T I N E ---------------------------------------


command_line_window_osnewl:             
                jsr     set_command_line_text_window_and_restore_cursor
                jsr     osnewl



; --------------- S U B R O U T I N E ---------------------------------------

; update cursor pos in cursor_x/cursor_y

update_cursor_pos:                      
                lda     #134
                jsr     osbyte
                stx     cursor_x
                sty     cursor_y
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; update cursor pos in cursor_x_2/cursor_y_2

update_cursor_pos_2:                    
                lda     #134
                jsr     osbyte
                stx     cursor_x_2
                sty     cursor_y_2
                rts



; --------------- S U B R O U T I N E ---------------------------------------


show_cursor:                            
                                        
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte 23
                .byte 1                 ; cursor control
                .byte 1                 ; make cursor reappear
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0
                .byte 0


; ---------------------------------------------------------------------------
                nop
                rts

; --------------- S U B R O U T I N E ---------------------------------------


set_command_line_text_window_and_restore_cursor: ; CODE XREF: command_line_window_osnewlp
                                        
                jsr     set_command_line_text_window
                jsr     show_cursor
                lda     #31
                jsr     oswrch
                lda     cursor_x
                jsr     oswrch
                lda     cursor_y
                jmp     oswrch


; ---------------------------------------------------------------------------

cmd_H:
                jsr     oswrch
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                eor     #$80 
                sta     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                jmp     command_line_loop_1
; ---------------------------------------------------------------------------

draw_panel:                             
                jsr     sub_8AB6
                jsr     print_following_string
; ---------------------------------------------------------------------------
; window (0.0)-(39,3)
                .byte 28
                .byte 0
                .byte 3
                .byte 39
                .byte 0
; yellow
                .byte teletext_code(131)
; ---------------------------------------------------------------------------
                nop
                jsr     hide_cursor
                jsr     clear_line_buffer
                ldx     #0
                lda     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                jsr     store_hex_byte_in_line_buffer
                inx
                inx
                lda     current_rom     ; if bit 6 set, ROM has been explicitly set
                jsr     store_hex_byte_in_line_buffer
                lda     #'!'
                sta     line_buffer+3
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print
                lda     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                and     #$9E 
                sta     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                lda     #' '
                bit     basic_PAGE      ; (BASIC) MSB of PAGE
                                        ; (Exmon) flag indicating which text window is active???
                                        ;         bit 7 = printer on/off
                bpl     loc_8E32
                lda     #teletext_code(136) ; flashing

loc_8E32:                               
                jsr     oswrch
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte teletext_code(130) ; green
                .text 'EXMON II by Beebugsoft '
                .byte teletext_code(137) ; flash off
                .byte teletext_code(131) ; yellow
; ---------------------------------------------------------------------------
                nop
                jsr     clear_line_buffer
                ldx     #1
                bit     byte_5B         ; bit 7 set = shadow RAM on???
                                        ; bit 6 set = sub_B000 pages in ANDY for $8000...$bfff
                                        ; bits 0..3 = ROMSEL value
                bpl     loc_8E72
                lda     byte_25
                jsr     store_hex_byte_in_line_buffer
                lda     byte_51         ; bit 6 = set when dual screen mode?
                lsr     a
                bcs     loc_8E6A
                lda     #'C'
                sta     line_buffer+4

loc_8E6A:                               
                bit     byte_51         ; bit 6 = set when dual screen mode?
                bmi     loc_8E72
                lda     #'P'
                sta     line_buffer+5

loc_8E72:                               
                ldx     #6
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print
                jsr     print_following_string
; ---------------------------------------------------------------------------
aAXYSPFlagsPc:  .text 'A  X  Y  S  P  flags   PC'
                .byte 31
                .byte 29
                .byte 1
aStack:         .text 'stack'
                .byte 13
; ---------------------------------------------------------------------------
                nop
                jsr     print_register_values
                ldy     reg_s
                ldx     #$1D

loc_8EA4:                               
                iny
                beq     loc_8EB2        ; branch taken when out of stack
                lda     $100,y          ; fetch stack byte
                jsr     store_hex_byte_in_line_buffer ; print it
                inx
                cpx     #39             ; 40 columns in Mode 7...
                bcc     loc_8EA4        ; branch taken if line width not exceeded

loc_8EB2:                               
                jsr     print_entire_line_buffer ; print up to 40 chars from line buffer
                ldx     num_breakpoints
                beq     locret_8F12
                ldy     #24
                cpx     #6
                bcc     loc_8EC0
                dey

loc_8EC0:                               
                ldx     #24
                jsr     set_text_window ; set text window from (0,y)-(39,x)
                jsr     print_following_string
; ---------------------------------------------------------------------------
aBrks:          .text 'BRKs :'
                .byte teletext_code(134) ; cyan
; ---------------------------------------------------------------------------
                nop
                ldy     #0
                jsr     clear_line_buffer
                ldx     #0

loc_8ED7:                               
                lda     (word_4C),y     ; pointer to breakpoint address MSBs
                jsr     store_hex_byte_in_line_buffer
                lda     (word_4A),y     ; pointer to breakpoint address LSBs
                jsr     store_hex_byte_in_line_buffer
                inx
                iny
                cpy     num_breakpoints
                bcs     loc_8F13
                cpy     #5
                bcc     loc_8ED7
                ldx     #25
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print
                jsr     clear_line_buffer
                ldx     #6

loc_8EF5:                               
                lda     (word_4C),y     ; pointer to breakpoint address MSBs
                jsr     store_hex_byte_in_line_buffer
                lda     (word_4A),y     ; pointer to breakpoint address LSBs
                jsr     store_hex_byte_in_line_buffer
                inx
                iny
                cpy     num_breakpoints
                bcc     loc_8EF5
                jsr     osnewl
                ldx     #$1F
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .byte teletext_code(134) ; cyan
; ---------------------------------------------------------------------------
                nop

loc_8F0F:                               
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print

locret_8F12:                            
                rts
; ---------------------------------------------------------------------------

loc_8F13:                               
                ldx     #$19
                bne     loc_8F0F


handle_exclamation:                     
                jsr     sub_8880        ; read byte value??
                sta     current_rom     ; if bit 6 set, ROM has been explicitly set
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop


; --------------- S U B R O U T I N E ---------------------------------------


cmd_A:
                jsr     sub_8880        ; read byte value??
                sta     reg_a
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop


; ---------------------------------------------------------------------------

cmd_X:                                  ; read byte value??
                jsr     sub_8880
                sta     reg_x
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

cmd_Y:                                  ; read byte value??
                jsr     sub_8880
                sta     reg_y
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

cmd_at:                                 ; set PC
                jsr     sub_8F49
                cpx     #0
                bne     loc_8F46
                lda     byte_5E
                sta     reg_pc
                lda     byte_5F
                sta     reg_pc+1

loc_8F46:                               
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop

; --------------- S U B R O U T I N E ---------------------------------------


sub_8F49:                               
                jsr     read_address_qqq
                sta     reg_pc
                lda     word_1C+1
                sta     reg_pc+1
                rts


; ---------------------------------------------------------------------------

cmd_P:
                jsr     read_address_qqq
                stx     byte_60
                sta     byte_5C
                sta     byte_5E
                lda     word_1C+1
                sta     byte_5D
                sta     byte_5F
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

cmd_W:                                  ; print char in A, then read character
                jsr     echo_and_readch ;
                                        ; entry: A=char to print
                                        ; exit: A=char read, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y
                cmp     #'I'
                beq     cmd_WI
                cmp     #'S'
                beq     cmd_WS          ; undocumented?
                jmp     backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_WI:                                 
                jsr     sub_8880        ; read byte value??
                cpx     #0
                beq     loc_8F8A
                cmp     #2

loc_8F7C:
                bcc     loc_8F82
                cmp     #18
                bcc     loc_8F85

loc_8F82:                               
                jmp     error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_8F85:                               
                sta     byte_62         ; height of panel???

loc_8F87:                               
                jmp     loc_8269
; ---------------------------------------------------------------------------

loc_8F8A:                               
                lda     #14
                sta     byte_62         ; height of panel???
                bne     loc_8F87

cmd_WS:                                 
                jsr     sub_8880        ; read byte value??
                jsr     check_workspace_page ; check workspace page is valid.
                                        ;
                                        ; entry: A=workspace page
                                        ; exit: C=0 if valid, C=1 if invalid
                bcc     loc_8F9E

error_then_command_line_loop:           
                jsr     loc_A019
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop
; ---------------------------------------------------------------------------

loc_8F9E:                               
                sta     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                sta     workspace_pointer+1
                lda     workspace_code  ; points to code region in workspace, +$92
                pha
                lda     #0
                sta     workspace_pointer
                sta     workspace_code  ; points to code region in workspace, +$92
                ldy     #$FF

loc_8FAE:                               
                lda     (workspace_code),y ; points to code region in workspace, +$92
                sta     (workspace_pointer),y
                dey
                cpy     #$FF
                bne     loc_8FAE
                lda     workspace_pointer+1
                ldy     #loc_8563+2-loc_8563+workspace.code
                sta     (workspace_pointer),y ; update jsr $ww9c
                ldy     #loc_8584+2-loc_8563+workspace.code
                sta     (workspace_pointer),y ; update jsr $wwca
                ldy     #loc_8595+2-loc_8563+workspace.code
                sta     (workspace_pointer),y ; update jsr $wwca
                ldy     #loc_85A7+2-loc_8563+workspace.code
                sta     (workspace_pointer),y ; update jsr $ww9f
                ldy     #loc_85AC+2-loc_8563+workspace.code
                sta     (workspace_pointer),y ; update jmp $ww98
                sta     workspace_code+1 ; points to code region in workspace, +$92
                sta     word_4A+1       ; pointer to breakpoint address LSBs
                sta     word_4C+1       ; pointer to breakpoint address MSBs
                sta     word_4E+1
                pla
                sta     workspace_code  ; points to code region in workspace, +$92

loc_8FD8:                               ; redraw panel, print ?, do command line input loop
                jmp     command_line_loop_2
; ---------------------------------------------------------------------------

cmd_O:                                  ; print char in A, then read character
                jsr     echo_and_readch ;
                                        ; entry: A=char to print
                                        ; exit: A=char read, toupper
                                        ;       C=1 when symbol/digit
                                        ;       V=0 when symbol/digit/xdigit
                                        ; preserves: X/Y
                cmp     #'B'
                beq     CMD_OB_or_OW
                cmp     #'W'
                beq     CMD_OB_or_OW
                jmp     backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

CMD_OB_or_OW:                           
                jsr     oswrch
                jsr     sub_8FF2
                jmp     command_line_loop_1

; --------------- S U B R O U T I N E ---------------------------------------


sub_8FF2:                               
                sta     byte_9          ; save command type
                lda     #0
                jsr     sub_8880        ; read byte value??
                pha
                lda     #0
                jsr     sub_8880        ; read byte value??
                pha
                lda     #0
                jsr     sub_8880        ; read byte value??
                tay
                lda     #$20 
                jsr     print_char_then_one_space ; print char in A then print one space
                                        ;
                                        ; preserves: X/Y
                jsr     clear_line_buffer
                pla
                tax
                lda     byte_9
                cmp     #'B'
                beq     OB_or_OW

cmd_OW:
                pla
                jsr     osword
                jmp     loc_9021
; ---------------------------------------------------------------------------

OB_or_OW:                               
                pla
                jsr     osbyte

loc_9021:                               
                pha
                txa
                ldx     #3
                jsr     store_hex_byte_in_line_buffer
                inx
                tya
                jsr     store_hex_byte_in_line_buffer
                ldx     #0
                pla
                jsr     store_hex_byte_in_line_buffer
                ldx     #8
                jmp     print_line_buffer ; print CR-terminated line buffer contents.

                                        ; entry: X = max # chars to print

; --------------- S U B R O U T I N E ---------------------------------------


sub_9038:                               

; FUNCTION CHUNK AT 8682 SIZE 00000003 BYTES

                sta     byte_21
                jsr     set_command_line_text_window_and_restore_cursor
                jsr     determine_BASIC_version
                cmp     #0
                bne     locret_9047
                jmp     loc_8682
; ---------------------------------------------------------------------------

locret_9047:                            
                rts


; ---------------------------------------------------------------------------

loc_9048:                               
                jsr     sub_9038
                lda     byte_5E
                sta     basic_P         ; value of P%
                lda     byte_5F
                sta     basic_P+1       ; value of P%


loc_9055:                               
                lda     #$FF
                sta     byte_57         ; panel status, hex/disassembly???
                lda     byte_5E
                sta     byte_14
                lda     byte_5F
                sta     byte_15
                lda     basic_P         ; value of P%
                sta     byte_5E
                lda     basic_P+1       ; value of P%
                sta     byte_5F

loc_906B:                               
                jsr     sub_A35C
                jsr     command_line_window_osnewl
                lda     basic_P         ; value of P%
                sta     word_B
                lda     basic_P+1       ; value of P%
                sta     word_B+1
                jsr     sub_891F
                jsr     print_line_buffer ; print CR-terminated line buffer contents.
                                        ;
                                        ; entry: X = max # chars to print
                lda     #$3A ; ':'
                jsr     print_char_then_one_space ; print char in A then print one space
                                        ;
                                        ; preserves: X/Y
                jsr     flush_input_buffer
                jsr     getch
                cmp     #key_toggle_mode
                bne     loc_9093
                jmp     loc_A442
; ---------------------------------------------------------------------------

loc_9093:                               
                cmp     #$87 
                bne     loc_909A
                jmp     loc_9175
; ---------------------------------------------------------------------------

loc_909A:                               
                cmp     #$8A 
                bne     loc_90A1
                jmp     loc_9144
; ---------------------------------------------------------------------------

loc_90A1:                               
                cmp     #$8B 
                bne     loc_90A8
                jmp     loc_9120
; ---------------------------------------------------------------------------

loc_90A8:                               
                ldy     #$27 
                sty     byte_8
                ldy     #0
                jsr     loc_876E
                lda     #$F
                jsr     oswrch
                cpy     #0
                beq     loc_9112
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                lda     #line_buffer
                sta     word_B
                lda     #0
                sta     word_B+1
                lda     #0
                sta     byte_A
                lda     #6
                sta     byte_28
                bit     basic_P+1       ; value of P%
                bpl     loc_90D8
                bvc     loc_90D8
                bit     current_rom     ; if bit 6 set, ROM has been explicitly set
                bvs     loc_910C

loc_90D8:                               
                                        ; sub_A4C8-13F6j
                lda     basic_O         ; value of O%
                pha
                lda     basic_O+1       ; value of O%
                pha
                lda     basic_P         ; value of P%
                sta     basic_O         ; value of O%
                lda     basic_P+1       ; value of P%
                sta     basic_O+1       ; value of O%
                bne     loc_90FF
                lda     basic_P         ; value of P%
                cmp     #8
                bcc     loc_90FF
                cmp     #$90 
                bcs     loc_90FF
                lda     workspace_page_number ; set by OSBYTE 240 (AUG p234)
                sta     basic_O+1       ; value of O%

loc_90FF:                               
                                        
                ldx     #unk_85D7.assemble
                jsr     call_BASIC_routine ; entry: X = index of routine to call
                pla
                sta     basic_O+1       ; value of O%
                pla
                sta     basic_O         ; value of O%

loc_910C:                               
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                jmp     loc_906B
; ---------------------------------------------------------------------------

loc_9112:                               
                inc     basic_P         ; value of P%
                bne     loc_911A
                inc     basic_P+1       ; value of P%

loc_911A:                               
                jsr     sub_8910
                jmp     loc_910C
; ---------------------------------------------------------------------------

loc_9120:                               
                jsr     poll_SHIFT      ; poll for SHIFT key status
                                        ;
                                        ; exit: X>=$80 and C=1 if shift was pressed
                                        ; preserves: A
                bcs     loc_9133
                lda     basic_P         ; value of P%
                bne     loc_912D
                dec     basic_P+1       ; value of P%

loc_912D:                               
                dec     basic_P         ; value of P%
                jmp     loc_9175
; ---------------------------------------------------------------------------

loc_9133:                               
                sec
                lda     basic_P         ; value of P%
                sbc     #$10
                sta     basic_P         ; value of P%
                bcs     loc_9141
                dec     basic_P+1       ; value of P%

loc_9141:                               
                jmp     loc_9175
; ---------------------------------------------------------------------------

loc_9144:                               
                jsr     poll_SHIFT      ; poll for SHIFT key status
                                        ;
                                        ; exit: X>=$80 and C=1 if shift was pressed
                                        ; preserves: A
                bcs     loc_916B
                lda     byte_5F
                sta     workspace_pointer+1
                lda     byte_5E
                jsr     read_memory     ; read byte from memory
                                        ;
                                        ; entry: A=LSB
                                        ;        workspace_pointer MSB=MSB
                                        ; exit: A=byte read
                                        ; preserves: X
                jsr     get_instruction_operand_size ; get size of instruction operand bytes
                                        ;
                                        ; entry: A = opcode
                                        ; exit: C=0 if valid, then A = # bytes
                                        ;       C=1 if invalid
                tay
                iny                     ; increment to include opcode
                tya
                bcc     loc_915C        ; branch taken if instruction was valid
                lda     #1              ; 1 byte for invalid instructions

loc_915C:                               
                clc
                adc     basic_P         ; value of P%
                sta     basic_P         ; value of P%
                bcc     loc_9168
                inc     basic_P+1       ; value of P%

loc_9168:                               
                jmp     loc_9175
; ---------------------------------------------------------------------------

loc_916B:                               
                lda     byte_16
                sta     basic_P         ; value of P%
                lda     byte_17
                sta     basic_P+1       ; value of P%

loc_9175:                               
                                        
                jsr     sub_8910
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                jmp     loc_9055


; --------------- S U B R O U T I N E ---------------------------------------


disassemble_instruction_and_print:      
                jsr     disassemble_instruction ; fill line buffer with disassembly of instruction at (word_B)
                jmp     print_entire_line_buffer ; print up to 40 chars from line buffer



; --------------- S U B R O U T I N E ---------------------------------------

; fill line buffer with disassembly of instruction at (word_B)

disassemble_instruction:                
                                        

; FUNCTION CHUNK AT 91FF SIZE 00000059 BYTES

                jsr     sub_891F
                ldx     #5
                jsr     fetch_memory    ; fetch byte using read_memory with post-increment.
                                        ;
                                        ; entry: (word_B) - address to fetch from
                                        ; preserves: Y/C
                jsr     store_hex_byte_in_line_buffer
                pha
                jsr     get_printable_char ; get printable version of byte - use '.' for unprintables
                                        ;
                                        ; entry: A = byte
                                        ; exit: A = printable char
                sta     line_buffer+$E
                pla
                jsr     get_instruction_info ; entry: A = opcode
                                        ; exit: C=1 if invalid;
                                        ;       C=0 if valid
                                        ;       A = offset into mnemonics table
                                        ;       ?byte_D = instruction addressing mode info
                ldx     #$17
                bcc     loc_91A7        ; branch taken if instruction invalid?
;disassemble invalid instruction        as "???"
                lda     #'?'
                sta     line_buffer+$14
                sta     line_buffer+$15
                sta     line_buffer+$16
                bne     loc_91D5        ; jmp, in effect

loc_91A7:                               
                tay
                lda     mnemonics,y     ; "BVSTYADCLDANDECLCLINXRTSBCSECLVJSROROLD"...
                sta     line_buffer+$14
                lda     mnemonics+1,y
                sta     line_buffer+$15
                lda     mnemonics+2,y
                sta     line_buffer+$16
                ldx     #$18
                lda     byte_D          ; get addressing mode info
                and     #$3F       ; mask out addrmode_strings offset
                tay                     ; Y=addrmode_strings offset

loc_91BE:                               
                                        
                lda     addrmode_strings,y ; "A"
                beq     loc_91D5        ; branch taken if addrmode string done
                iny
                cmp     #' '
                beq     do_byte         ; print hex byte
                cmp     #'!'
                beq     do_word         ; print hex word
                cmp     #'?'
                beq     loc_9230
                sta     line_buffer,x
                inx
                bpl     loc_91BE

loc_91D5:                               
                                        ; disassemble_instruction+3Dj
                lda     #$D
                sta     line_buffer+$27
                lda     #teletext_code(134)
                sta     line_buffer+4
                lda     #teletext_code(131)
                sta     line_buffer+$D
                lda     #teletext_code(130)
                sta     line_buffer+$13
                rts
; ---------------------------------------------------------------------------

do_byte:                                
                lda     #'&'
                sta     line_buffer,x
                inx
                jsr     fetch_memory    ; fetch byte using read_memory with post-increment.
                                        ;
                                        ; entry: (word_B) - address to fetch from
                                        ; preserves: Y/C
                jsr     store_hex_byte_in_line_buffer
                jsr     store_instruction_char_1
                jmp     store_hex_dump_byte_1



; --------------- S U B R O U T I N E ---------------------------------------


store_instruction_char_1:               
                pha
                jsr     get_printable_char ; get printable version of byte - use '.' for unprintables
                                        ;
                                        ; entry: A = byte
                                        ; exit: A = printable char
                sta     line_buffer+$F
                pla
                rts


; ---------------------------------------------------------------------------


do_word:                                
                jsr     fetch_memory    ; fetch LSB
                jsr     store_instruction_char_1
                pha                     ; save LSB
                lda     #'&'
                sta     line_buffer,x
                inx
                jsr     fetch_memory    ; fetch MSB
                jsr     store_hex_byte_in_line_buffer ; print MSB hex as part of instruction
                pha                     ; save MSB
                jsr     get_printable_char ; get printable version of byte - use '.' for unprintables
                                        ;
                                        ; entry: A = byte
                                        ; exit: A = printable char
                sta     line_buffer+$10 ; store MSB char
                pla                     ; restore MSB
                stx     byte_9
                ldx     #11
                jsr     store_hex_byte_in_line_buffer ; print MSB hex as part of hex dump
                ldx     byte_9
                pla                     ; restore LSB
                jsr     store_hex_byte_in_line_buffer ; print LSB hex as part of instruction

store_hex_dump_byte_1:                  
                stx     byte_9
                ldx     #8
                jsr     store_hex_byte_in_line_buffer ; print LSB hex as part of hex dump
                ldx     byte_9
                bpl     loc_91BE        ; jmp, in effect

loc_9230:                               
                lda     #'&'
                sta     line_buffer,x
                inx
                jsr     fetch_memory    ; fetch byte using read_memory with post-increment.
                                        ;
                                        ; entry: (word_B) - address to fetch from
                                        ; preserves: Y/C
                sta     byte_8
                jsr     get_printable_char ; get printable version of byte - use '.' for unprintables
                                        ;
                                        ; entry: A = byte
                                        ; exit: A = printable char
                sta     line_buffer+$F
                lda     byte_8
                stx     byte_9
                ldx     #8
                jsr     store_hex_byte_in_line_buffer
                ldx     byte_9
                jsr     add8s           ; add 8-bit sign-extended value
                                        ;
                                        ; entry: ?byte_8, A = 8-bit signed value (seems these must be the same???)
                                        ;        word_B = 16-bit value
                                        ; exit: ?byte_9 = LSB of result
                                        ;       A = MSB of result
                                        ; preserves: X/Y
                jsr     store_hex_byte_in_line_buffer
                lda     byte_9
                jsr     store_hex_byte_in_line_buffer
                jmp     loc_91BE


; --------------- S U B R O U T I N E ---------------------------------------

; add 8-bit sign-extended value
;
; entry: ?byte_8, A = 8-bit signed value (seems these must be the same???)
;        word_B = 16-bit value
; exit: ?byte_9 = LSB of result
;       A = MSB of result
; preserves: X/Y

add8s:                                  
                                        
                clc
                adc     word_B          ; add LSB
                sta     byte_9          ; store LSB
                lda     byte_8          ; get MSB
                bpl     loc_9265        ; branch taken if +ve
                lda     #$FF            ; decrement MSB
                bmi     loc_9267        ; jmp, in effect

loc_9265:                               
                lda     #0

loc_9267:                               
                adc     word_B+1
                clc
                rts



; --------------- S U B R O U T I N E ---------------------------------------

; get size of instruction operand bytes
;
; entry: A = opcode
; exit: C=0 if valid, then A = # bytes
;       C=1 if invalid

get_instruction_operand_size:           
                jsr     get_instruction_info ; entry: A = opcode
                                        ; exit: C=1 if invalid;
                                        ;       C=0 if valid
                                        ;       A = offset into mnemonics table
                                        ;       ?byte_D = instruction addressing mode info
                bcs     locret_9284     ; branch taken if instruction invalid
                lda     byte_D          ; get addrmode info - %abcdefgh
                lsr     a               ; %0abcdefg
                jmp     shr5_clc        ; %000000ab



; --------------- S U B R O U T I N E ---------------------------------------

; entry: A = opcode
; exit: C=1 if invalid;
;       C=0 if valid
;       A = offset into mnemonics table
;       ?byte_D = instruction addressing mode info

get_instruction_info:                   
                                        
                jsr     get_instruction_info_2
                tay
                lda     addrmode_info_table,y ; addrmode_info_table[i] is info about addrmode i
                                        ;
                                        ; bits 0-5 are offset into addrmode_strings
                sta     byte_D          ; store instruction addressing mode info
                ldy     mnemonic
                lda     mnemonic_offsets,y ; mnemonic_offsets[i] is offset into mnemonics for mnemonic i

locret_9284:                            
                rts



; --------------- S U B R O U T I N E ---------------------------------------


get_instruction_info_2:                 
                tay                     ; Y = opcode
                lda     instruction_mnemonics,y ; instruction_mnemonics[i] holds the mnemonic index for opcode i.
                                        ; if $ff, this opcode is invalid.
                                        ; if bit 7 set otherwise, CMOS opcode.
                                        ; bits 0-6 are the mnemonic index.

                bpl     loc_92A5        ; taken if bit 7 clear - instruction is valid
                cmp     #$FF
                bne     maybe_cmos      ; taken if bit 7 set, but not $ff - instruction is maybe CMOS

not_valid:                              
                sec
                rts
; ---------------------------------------------------------------------------

maybe_cmos:                             
                jsr     get_machine_type ; Read machine type, as per OSBYTE $81
                                        ;
                                        ; exit: X=machine type
                                        ; preserves: A/Y
                cpx     #$FD       ; Master 128 MOS 3.20/3.50
                beq     is_master
                cpx     #$F5       ; Master Compact MOS 5.10
                beq     is_master
                
                ldx     #$FF
                .cpu '65c02'
                phx             ;$da - a NOP on NMOS 6502
                inx
                plx             ;$fa - a NOP on NMOS 6502
                .cpu 'default'
                beq     not_valid       ; jmp, in effect

is_master:
                                        ; get_instruction_info_2+15j
                and     #$7F       ; clear cmos/invalid flag

loc_92A5:                               
                sta     mnemonic
                lda     instruction_addrmodes,y ; instruction_addrmodes[i] is addressing mode index for opcode i
                clc
                rts


; ---------------------------------------------------------------------------

cmd_K:
                jsr     sub_8817
                jsr     print_following_string
; ---------------------------------------------------------------------------
                .text ' File?'
; ---------------------------------------------------------------------------
                nop
                ldy     #$A             ; Bug? - Y was max input length at some point?
                jsr     read_line_buffer ; read input into line buffer. Max 40 chars
                                        ;
                                        ; exit: Y = # chars read
                jsr     osnewl
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                ldx     #9

loc_92C6:                               
                lda     line_buffer,x
                sta     line_buffer+3,x
                dex
                bpl     loc_92C6
                jsr     star_spool      ; does *SPOOL with file name at line_buffer+3 onwards
                jsr     print_following_string
; ---------------------------------------------------------------------------
aAu_P:          .text 'AU.',$D,'P%=&'
; ---------------------------------------------------------------------------
                nop
                jsr     sub_891F
                lda     #$D
                sta     line_buffer+4
                jsr     print_entire_line_buffer ; print up to 40 chars from line buffer
                lda     #'['
                jsr     oswrch
                jsr     osnewl

loc_92EE:                               
                jsr     poll_ESCAPE     ; check if ESCAPE is pressed
                                        ;
                                        ; exit: Z=1 if ESCAPE pressed
                bne     loc_92F9
                jsr     acknowledge_ESCAPE
                jmp     loc_9357
; ---------------------------------------------------------------------------

loc_92F9:                               
                lda     word_B+1
                sta     workspace_pointer+1
                lda     word_B
                jsr     read_memory     ; read byte from memory
                                        ;
                                        ; entry: A=LSB
                                        ;        workspace_pointer MSB=MSB
                                        ; exit: A=byte read
                                        ; preserves: X
                and     #$1F
                cmp     #$10
                php
                inc     workspace_pointer
                bne     loc_930D
                inc     workspace_pointer+1

loc_930D:                               
                lda     workspace_pointer
                jsr     read_memory     ; read byte from memory
                                        ;
                                        ; entry: A=LSB
                                        ;        workspace_pointer MSB=MSB
                                        ; exit: A=byte read
                                        ; preserves: X
                sta     byte_E
                jsr     check_fetch_address
                bcs     loc_9357
                jsr     disassemble_instruction ; fill line buffer with disassembly of instruction at (word_B)
                plp
                bne     loc_9348
                lda     #'P'
                sta     line_buffer+$18
                lda     #'%'
                sta     line_buffer+$19
                lda     #'+'
                sta     line_buffer+$1A
                lda     #'&'
                sta     line_buffer+$1B
                lda     byte_E
                bpl     loc_9340
                eor     #$FF
                sec
                sbc     #1
                pha
                lda     #'-'
                sta     line_buffer+$1A
                pla
                bpl     loc_9343

loc_9340:                               
                clc
                adc     #2

loc_9343:                               
                ldx     #$1C
                jsr     store_hex_byte_in_line_buffer

loc_9348:                               
                ldx     #$1F
                stx     byte_8
                ldx     #$14
                jsr     loc_8A9A
                jsr     osnewl
                jmp     loc_92EE
; ---------------------------------------------------------------------------

loc_9357:                               
                lda     #']'
                jsr     oswrch
                jsr     osnewl
                lda     #$D
                sta     line_buffer+3   ; store empty file name for *SPOOL
                jsr     star_spool      ; does *SPOOL with file name at line_buffer+3 onwards
                jsr     update_cursor_pos ; update cursor pos in cursor_x/cursor_y
                jmp     command_line_loop_2 ; redraw panel, print ?, do command line input loop

; --------------- S U B R O U T I N E ---------------------------------------

; does *SPOOL with file name at line_buffer+3 onwards

star_spool:                             
                lda     #'s'
                sta     line_buffer
                lda     #'p'
                sta     line_buffer+1
                lda     #'.'
                sta     line_buffer+2
                ldx     #line_buffer
                ldy     #0
                jmp     oscli


; ---------------------------------------------------------------------------
mnemonics: .block
bvs:
                .text 'BV'
sty:
                .text 'S'
tya:
                .text 'TY'
adc:
                .text 'AD'
cld:
                .text 'C'
lda:
                .text 'LD'
and:
                .text 'AN'
dec:
                .text 'DE'
clc:
                .text 'CL'
cli:
                .text 'CL'
inx:
                .text 'INX'
rts:
                .text 'R'
tsb:
                .text 'T'
sbc:
                .text 'S'
bcs:
                .text 'BC'
sec:
                .text 'SE'
clv:
                .text 'CLV'
jsr:
                .text 'JS'
ror:
                .text 'RO'
rol:
                .text 'RO'
ldx:
                .text 'LDX'
sta:
                .text 'S'
tax:
                .text 'TAX'
bit:
                .text 'BI'
txs:
                .text 'TX'
sei:
                .text 'SE'
iny:
                .text 'INY'
bpl:
                .text 'B'
pla:
                .text 'PLA'
bne:                                    
                .text 'BN'
eor:
                .text 'E'
ora:
                .text 'ORA'
lsr:
                .text 'LS'
rti:
                .text 'RT'
inc:
                .text 'IN'
cmp:
                .text 'CM'
php:
                .text 'PH'
plp:
                .text 'PL'
pha:
                .text 'PH'
asl:
                .text 'AS'
ldy:
                .text 'LDY'
bcc:
                .text 'BC'
cpx:
                .text 'CPX'
stx:
                .text 'S'
txa:
                .text 'TXA'
sed:
                .text 'SE'
dex:
                .text 'DEX'
bvc:
                .text 'BV'
cpy:
                .text 'CPY'
beq:
                .text 'BEQ'
bmi:
                .text 'BMI'
brk:
                .text 'BRK'
dey:
                .text 'DEY'
jmp:
                .text 'JMP'
nop:
                .text 'NOP'
tay:
                .text 'TAY'
tsx:
                .text 'TSX'
trb:
                .text 'TR'
bra:
                .text 'BRA'
stz:
                .text 'STZ'
phx:
                .text 'PHX'
phy:
                .text 'PHY'
plx:
                .text 'PLX'
ply:
                .text 'PLY'
                .bend
                
addrmode_strings: .block
a_offset=*-addrmode_strings
                .text 'A'
imp_offset=*-addrmode_strings
                .text 0
imm_offset=*-addrmode_strings
		.text '#'
zp_offset=*-addrmode_strings
               .text ' ',0
zpx_offset=*-addrmode_strings
		.text ' ,X',0
zpy_offset=*-addrmode_strings
		.text ' ,Y',0
zxi_offset=*-addrmode_strings
		.text '( ,X)',0
ziy_offset=*-addrmode_strings             
		.text '( ),Y',0
abs_offset=*-addrmode_strings
		.text '!',0
abx_offset=*-addrmode_strings
		.text '!,X',0
aby_offset=*-addrmode_strings
		.text '!,Y',0
ain_offset=*-addrmode_strings
		.text '(!)',0
unk_offset=*-addrmode_strings
		.text '?',0
zin_offset=*-addrmode_strings
		.text '( )',0
axi_offset=*-addrmode_strings
		.text '(!,X)',0
                .bend
                
mnemonic_offsets:
; mnemonic_offsets[i] is offset	into mnemonics for mnemonic i
mnemonic_ORA=*-mnemonic_offsets
                .byte mnemonics.ora-mnemonics
mnemonic_AND=*-mnemonic_offsets
                .byte mnemonics.and-mnemonics
mnemonic_EOR=*-mnemonic_offsets
                .byte mnemonics.eor-mnemonics
mnemonic_ADC=*-mnemonic_offsets
                .byte mnemonics.adc-mnemonics
mnemonic_STA=*-mnemonic_offsets
                .byte mnemonics.sta-mnemonics
mnemonic_LDA=*-mnemonic_offsets
                .byte mnemonics.lda-mnemonics
mnemonic_CMP=*-mnemonic_offsets
                .byte mnemonics.cmp-mnemonics
mnemonic_SBC=*-mnemonic_offsets
                .byte mnemonics.sbc-mnemonics
mnemonic_ASL=*-mnemonic_offsets
                .byte mnemonics.asl-mnemonics
mnemonic_ROL=*-mnemonic_offsets
                .byte mnemonics.rol-mnemonics
mnemonic_LSR=*-mnemonic_offsets
                .byte mnemonics.lsr-mnemonics
mnemonic_ROR=*-mnemonic_offsets
                .byte mnemonics.ror-mnemonics
mnemonic_STX=*-mnemonic_offsets
                .byte mnemonics.stx-mnemonics
mnemonic_LDX=*-mnemonic_offsets
                .byte mnemonics.ldx-mnemonics
mnemonic_DEC=*-mnemonic_offsets
                .byte mnemonics.dec-mnemonics
mnemonic_INC=*-mnemonic_offsets
                .byte mnemonics.inc-mnemonics
mnemonic_TXA=*-mnemonic_offsets
                .byte mnemonics.txa-mnemonics
mnemonic_TXS=*-mnemonic_offsets
                .byte mnemonics.txs-mnemonics
mnemonic_TAX=*-mnemonic_offsets
                .byte mnemonics.tax-mnemonics
mnemonic_TSX=*-mnemonic_offsets
                .byte mnemonics.tsx-mnemonics
mnemonic_DEX=*-mnemonic_offsets
                .byte mnemonics.dex-mnemonics
mnemonic_BIT=*-mnemonic_offsets
                .byte mnemonics.bit-mnemonics
mnemonic_NOP=*-mnemonic_offsets
                .byte mnemonics.nop-mnemonics
mnemonic_jmp=*-mnemonic_offsets
                .byte mnemonics.jmp-mnemonics
mnemonic_STY=*-mnemonic_offsets
                .byte mnemonics.sty-mnemonics
mnemonic_LDY=*-mnemonic_offsets
                .byte mnemonics.ldy-mnemonics
mnemonic_CPY=*-mnemonic_offsets
                .byte mnemonics.cpy-mnemonics
mnemonic_CPX=*-mnemonic_offsets
                .byte mnemonics.cpx-mnemonics
mnemonic_BPL=*-mnemonic_offsets
                .byte mnemonics.bpl-mnemonics
mnemonic_BMI=*-mnemonic_offsets
                .byte mnemonics.bmi-mnemonics
mnemonic_BVC=*-mnemonic_offsets
                .byte mnemonics.bvc-mnemonics
mnemonic_BVS=*-mnemonic_offsets
                .byte mnemonics.bvs-mnemonics
mnemonic_BCC=*-mnemonic_offsets
                .byte mnemonics.bcc-mnemonics
mnemonic_BCS=*-mnemonic_offsets
                .byte mnemonics.bcs-mnemonics
mnemonic_BNE=*-mnemonic_offsets
                .byte mnemonics.bne-mnemonics
mnemonic_BEQ=*-mnemonic_offsets
                .byte mnemonics.beq-mnemonics
mnemonic_BRK=*-mnemonic_offsets
                .byte mnemonics.brk-mnemonics
mnemonic_JSR=*-mnemonic_offsets
                .byte mnemonics.jsr-mnemonics
mnemonic_RTI=*-mnemonic_offsets
                .byte mnemonics.rti-mnemonics
mnemonic_RTS=*-mnemonic_offsets
                .byte mnemonics.rts-mnemonics
mnemonic_PHP=*-mnemonic_offsets
                .byte mnemonics.php-mnemonics
mnemonic_CLC=*-mnemonic_offsets
                .byte mnemonics.clc-mnemonics
mnemonic_PLP=*-mnemonic_offsets
                .byte mnemonics.plp-mnemonics
mnemonic_SEC=*-mnemonic_offsets
                .byte mnemonics.sec-mnemonics
mnemonic_PHA=*-mnemonic_offsets
                .byte mnemonics.pha-mnemonics
mnemonic_CLI=*-mnemonic_offsets
                .byte mnemonics.cli-mnemonics
mnemonic_PLA=*-mnemonic_offsets
                .byte mnemonics.pla-mnemonics
mnemonic_SEI=*-mnemonic_offsets
                .byte mnemonics.sei-mnemonics
mnemonic_DEY=*-mnemonic_offsets
                .byte mnemonics.dey-mnemonics
mnemonic_TYA=*-mnemonic_offsets
                .byte mnemonics.tya-mnemonics
mnemonic_TAY=*-mnemonic_offsets
                .byte mnemonics.tay-mnemonics
mnemonic_CLV=*-mnemonic_offsets
                .byte mnemonics.clv-mnemonics
mnemonic_INY=*-mnemonic_offsets
                .byte mnemonics.iny-mnemonics
mnemonic_CLD=*-mnemonic_offsets
                .byte mnemonics.cld-mnemonics
mnemonic_INX=*-mnemonic_offsets
                .byte mnemonics.inx-mnemonics
mnemonic_SED=*-mnemonic_offsets
                .byte mnemonics.sed-mnemonics
mnemonic_TSB=*-mnemonic_offsets
                .byte mnemonics.tsb-mnemonics
mnemonic_TRB=*-mnemonic_offsets
                .byte mnemonics.trb-mnemonics
mnemonic_BRA=*-mnemonic_offsets
                .byte mnemonics.bra-mnemonics
mnemonic_STZ=*-mnemonic_offsets
                .byte mnemonics.stz-mnemonics
mnemonic_PHX=*-mnemonic_offsets
                .byte mnemonics.phx-mnemonics
mnemonic_PHY=*-mnemonic_offsets
                .byte mnemonics.phy-mnemonics
mnemonic_PLX=*-mnemonic_offsets
                .byte mnemonics.plx-mnemonics
mnemonic_PLY=*-mnemonic_offsets
                .byte mnemonics.ply-mnemonics
mnemonic_INVALID=$ff
                
addrmode_info_table:
                ; addrmode_info_table[i] is info about addrmode	i
                ;
                ; bits 0-5 are offset into addrmode_strings
                ; bits 6-7 are count of operand bytes
addrmode_zxi=*-addrmode_info_table ;0
                .byte 1<<6|addrmode_strings.zxi_offset
addrmode_ziy=*-addrmode_info_table ;1
		.byte 1<<6|addrmode_strings.ziy_offset
addrmode_zp=*-addrmode_info_table ;2
		.byte 1<<6|addrmode_strings.zp_offset
addrmode_zpx=*-addrmode_info_table ;3
		.byte 1<<6|addrmode_strings.zpx_offset
addrmode_imm=*-addrmode_info_table ;4
		.byte 1<<6|addrmode_strings.imm_offset
addrmode_aby=*-addrmode_info_table ;5
		.byte 2<<6|addrmode_strings.aby_offset
addrmode_abs=*-addrmode_info_table ;6
		.byte 2<<6|addrmode_strings.abs_offset
addrmode_abx=*-addrmode_info_table ;7
		.byte 2<<6|addrmode_strings.abx_offset
addrmode_a=*-addrmode_info_table ;8
		.byte 0<<6|addrmode_strings.a_offset
addrmode_imp=*-addrmode_info_table ;9
		.byte 0<<6|addrmode_strings.imp_offset
addrmode_ain=*-addrmode_info_table ;10
		.byte 2<<6|addrmode_strings.ain_offset
addrmode_zpy=*-addrmode_info_table ;11
		.byte 1<<6|addrmode_strings.zpy_offset
addrmode_unk=*-addrmode_info_table ;12
		.byte 1<<6|addrmode_strings.unk_offset
addrmode_zin=*-addrmode_info_table ;13
		.byte 1<<6|addrmode_strings.zin_offset
addrmode_axi=*-addrmode_info_table ;14
		.byte 2<<6|addrmode_strings.axi_offset
addrmode_invalid=$ff
                
instruction_addrmodes:
                ; instruction_addrmodes[i] is addressing mode index
                ; for opcode i
                .byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_a
		.byte addrmode_invalid
		.byte addrmode_ain
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_axi
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpy
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_imm
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_zpy
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_aby
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
		.byte addrmode_imm
		.byte addrmode_zxi
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_zp
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_imm
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_abs
		.byte addrmode_invalid
		.byte addrmode_unk
		.byte addrmode_ziy
		.byte addrmode_zin
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_zpx
		.byte addrmode_zpx
		.byte addrmode_invalid
		.byte addrmode_imp
		.byte addrmode_aby
		.byte addrmode_imp
		.byte addrmode_invalid
		.byte addrmode_invalid
		.byte addrmode_abx
		.byte addrmode_abx
		.byte addrmode_invalid
                
instruction_mnemonics:
		; instruction_mnemonics[i] holds the mnemonic index	for opcode i.
		; if $ff, this opcode is invalid.
		; if bit 7 set otherwise, CMOS opcode.
		; bits 0-6 are the mnemonic index.
                .byte mnemonic_BRK       ;	0 
		.byte mnemonic_ORA		; 1
		.byte mnemonic_INVALID		; 2
		.byte mnemonic_INVALID		; 3
		.byte $80|mnemonic_TSB		; 4
		.byte mnemonic_ORA		; 5
		.byte mnemonic_ASL		; 6
		.byte mnemonic_INVALID		; 7
		.byte mnemonic_PHP		; 8
		.byte mnemonic_ORA		; 9
		.byte mnemonic_ASL		; 10
		.byte mnemonic_INVALID		; 11
		.byte $80|mnemonic_TSB		; 12
		.byte mnemonic_ORA		; 13
		.byte mnemonic_ASL		; 14
		.byte mnemonic_INVALID		; 15
		.byte mnemonic_BPL		; 16
		.byte mnemonic_ORA		; 17
		.byte $80|mnemonic_ORA		; 18
		.byte mnemonic_INVALID		; 19
		.byte $80|mnemonic_TRB		; 20
		.byte mnemonic_ORA		; 21
		.byte mnemonic_ASL		; 22
		.byte mnemonic_INVALID		; 23
		.byte mnemonic_CLC		; 24
		.byte mnemonic_ORA		; 25
		.byte $80|mnemonic_INC		; 26
		.byte mnemonic_INVALID		; 27
		.byte $80|mnemonic_TRB		; 28
		.byte mnemonic_ORA		; 29
		.byte mnemonic_ASL		; 30
		.byte mnemonic_INVALID		; 31
		.byte mnemonic_JSR		; 32
		.byte mnemonic_AND		; 33
		.byte mnemonic_INVALID		; 34
		.byte mnemonic_INVALID		; 35
		.byte mnemonic_BIT		; 36
		.byte mnemonic_AND		; 37
		.byte mnemonic_ROL		; 38
		.byte mnemonic_INVALID		; 39
		.byte mnemonic_PLP		; 40
		.byte mnemonic_AND		; 41
		.byte mnemonic_ROL		; 42
		.byte mnemonic_INVALID		; 43
		.byte mnemonic_BIT		; 44
		.byte mnemonic_AND		; 45
		.byte mnemonic_ROL		; 46
		.byte mnemonic_INVALID		; 47
		.byte mnemonic_BMI		; 48
		.byte mnemonic_AND		; 49
		.byte $80|mnemonic_AND		; 50
		.byte mnemonic_INVALID		; 51
		.byte $80|mnemonic_BIT		; 52
		.byte mnemonic_AND		; 53
		.byte mnemonic_ROL		; 54
		.byte mnemonic_INVALID		; 55
		.byte mnemonic_SEC		; 56
		.byte mnemonic_AND		; 57
		.byte $80|mnemonic_DEC		; 58
		.byte mnemonic_INVALID		; 59
		.byte $80|mnemonic_BIT		; 60
		.byte mnemonic_AND		; 61
		.byte mnemonic_ROL		; 62
		.byte mnemonic_INVALID		; 63
		.byte mnemonic_RTI		; 64
		.byte mnemonic_EOR		; 65
		.byte mnemonic_INVALID		; 66
		.byte mnemonic_INVALID		; 67
		.byte mnemonic_INVALID		; 68
		.byte mnemonic_EOR		; 69
		.byte mnemonic_LSR		; 70
		.byte mnemonic_INVALID		; 71
		.byte mnemonic_PHA		; 72
		.byte mnemonic_EOR		; 73
		.byte mnemonic_LSR		; 74
		.byte mnemonic_INVALID		; 75
		.byte mnemonic_jmp		; 76
		.byte mnemonic_EOR		; 77
		.byte mnemonic_LSR		; 78
		.byte mnemonic_INVALID		; 79
		.byte mnemonic_BVC		; 80
		.byte mnemonic_EOR		; 81
		.byte $80|mnemonic_EOR		; 82
		.byte mnemonic_INVALID		; 83
		.byte mnemonic_INVALID		; 84
		.byte mnemonic_EOR		; 85
		.byte mnemonic_LSR		; 86
		.byte mnemonic_INVALID		; 87
		.byte mnemonic_CLI		; 88
		.byte mnemonic_EOR		; 89
		.byte $80|mnemonic_PHY		; 90
		.byte mnemonic_INVALID		; 91
		.byte mnemonic_INVALID		; 92
		.byte mnemonic_EOR		; 93
		.byte mnemonic_LSR		; 94
		.byte mnemonic_INVALID		; 95
		.byte mnemonic_RTS		; 96
		.byte mnemonic_ADC		; 97
		.byte mnemonic_INVALID		; 98
		.byte mnemonic_INVALID		; 99
		.byte $80|mnemonic_STZ		; 100
		.byte mnemonic_ADC		; 101
		.byte mnemonic_ROR		; 102
		.byte mnemonic_INVALID		; 103
		.byte mnemonic_PLA		; 104
		.byte mnemonic_ADC		; 105
		.byte mnemonic_ROR		; 106
		.byte mnemonic_INVALID		; 107
		.byte mnemonic_jmp		; 108
		.byte mnemonic_ADC		; 109
		.byte mnemonic_ROR		; 110
		.byte mnemonic_INVALID		; 111
		.byte mnemonic_BVS		; 112
		.byte mnemonic_ADC		; 113
		.byte $80|mnemonic_ADC		; 114
		.byte mnemonic_INVALID		; 115
		.byte $80|mnemonic_STZ		; 116
		.byte mnemonic_ADC		; 117
		.byte mnemonic_ROR		; 118
		.byte mnemonic_INVALID		; 119
		.byte mnemonic_SEI		; 120
		.byte mnemonic_ADC		; 121
		.byte $80|mnemonic_PLY		; 122
		.byte mnemonic_INVALID		; 123
		.byte $80|mnemonic_jmp		; 124
		.byte mnemonic_ADC		; 125
		.byte mnemonic_ROR		; 126
		.byte mnemonic_INVALID		; 127
		.byte $80|mnemonic_BRA		; 128
		.byte mnemonic_STA		; 129
		.byte mnemonic_INVALID		; 130
		.byte mnemonic_INVALID		; 131
		.byte mnemonic_STY		; 132
		.byte mnemonic_STA		; 133
		.byte mnemonic_STX		; 134
		.byte mnemonic_INVALID		; 135
		.byte mnemonic_DEY		; 136
		.byte $80|mnemonic_BIT		; 137
		.byte mnemonic_TXA		; 138
		.byte mnemonic_INVALID		; 139
		.byte mnemonic_STY		; 140
		.byte mnemonic_STA		; 141
		.byte mnemonic_STX		; 142
		.byte mnemonic_INVALID		; 143
		.byte mnemonic_BCC		; 144
		.byte mnemonic_STA		; 145
		.byte $80|mnemonic_STA		; 146
		.byte mnemonic_INVALID		; 147
		.byte mnemonic_STY		; 148
		.byte mnemonic_STA		; 149
		.byte mnemonic_STX		; 150
		.byte mnemonic_INVALID		; 151
		.byte mnemonic_TYA		; 152
		.byte mnemonic_STA		; 153
		.byte mnemonic_TXS		; 154
		.byte mnemonic_INVALID		; 155
		.byte $80|mnemonic_STZ		; 156
		.byte mnemonic_STA		; 157
		.byte $80|mnemonic_STZ		; 158
		.byte mnemonic_INVALID		; 159
		.byte mnemonic_LDY		; 160
		.byte mnemonic_LDA		; 161
		.byte mnemonic_LDX		; 162
		.byte mnemonic_INVALID		; 163
		.byte mnemonic_LDY		; 164
		.byte mnemonic_LDA		; 165
		.byte mnemonic_LDX		; 166
		.byte mnemonic_INVALID		; 167
		.byte mnemonic_TAY		; 168
		.byte mnemonic_LDA		; 169
		.byte mnemonic_TAX		; 170
		.byte mnemonic_INVALID		; 171
		.byte mnemonic_LDY		; 172
		.byte mnemonic_LDA		; 173
		.byte mnemonic_LDX		; 174
		.byte mnemonic_INVALID		; 175
		.byte mnemonic_BCS		; 176
		.byte mnemonic_LDA		; 177
		.byte $80|mnemonic_LDA		; 178
		.byte mnemonic_INVALID		; 179
		.byte mnemonic_LDY		; 180
		.byte mnemonic_LDA		; 181
		.byte mnemonic_LDX		; 182
		.byte mnemonic_INVALID		; 183
		.byte mnemonic_CLV		; 184
		.byte mnemonic_LDA		; 185
		.byte mnemonic_TSX		; 186
		.byte mnemonic_INVALID		; 187
		.byte mnemonic_LDY		; 188
		.byte mnemonic_LDA		; 189
		.byte mnemonic_LDX		; 190
		.byte mnemonic_INVALID		; 191
		.byte mnemonic_CPY		; 192
		.byte mnemonic_CMP		; 193
		.byte mnemonic_INVALID		; 194
		.byte mnemonic_INVALID		; 195
		.byte mnemonic_CPY		; 196
		.byte mnemonic_CMP		; 197
		.byte mnemonic_DEC		; 198
		.byte mnemonic_INVALID		; 199
		.byte mnemonic_INY		; 200
		.byte mnemonic_CMP		; 201
		.byte mnemonic_DEX		; 202
		.byte mnemonic_INVALID		; 203
		.byte mnemonic_CPY		; 204
		.byte mnemonic_CMP		; 205
		.byte mnemonic_DEC		; 206
		.byte mnemonic_INVALID		; 207
		.byte mnemonic_BNE              ; 208
		.byte mnemonic_CMP		; 209
		.byte $80|mnemonic_CMP		; 210
		.byte mnemonic_INVALID		; 211
		.byte mnemonic_INVALID		; 212
		.byte mnemonic_CMP		; 213
		.byte mnemonic_DEC		; 214
		.byte mnemonic_INVALID		; 215
		.byte mnemonic_CLD              ; 216
		.byte mnemonic_CMP		; 217
		.byte $80|mnemonic_PHX		; 218
		.byte mnemonic_INVALID		; 219
		.byte mnemonic_INVALID		; 220
		.byte mnemonic_CMP		; 221
		.byte mnemonic_DEC		; 222
		.byte mnemonic_INVALID		; 223
		.byte mnemonic_CPX		; 224
		.byte mnemonic_SBC		; 225
		.byte mnemonic_INVALID		; 226
		.byte mnemonic_INVALID		; 227
		.byte mnemonic_CPX		; 228
		.byte mnemonic_SBC		; 229
		.byte mnemonic_INC		; 230
		.byte mnemonic_INVALID		; 231
		.byte mnemonic_INX		; 232
		.byte mnemonic_SBC		; 233
		.byte mnemonic_NOP		; 234
		.byte mnemonic_INVALID		; 235
		.byte mnemonic_CPX		; 236
		.byte mnemonic_SBC		; 237
		.byte mnemonic_INC		; 238
		.byte mnemonic_INVALID		; 239
		.byte mnemonic_BEQ		; 240
		.byte mnemonic_SBC		; 241
		.byte $80|mnemonic_SBC		; 242
		.byte mnemonic_INVALID		; 243
		.byte mnemonic_INVALID		; 244
		.byte mnemonic_SBC		; 245
		.byte mnemonic_INC		; 246
		.byte mnemonic_INVALID		; 247
		.byte mnemonic_SED		; 248
		.byte mnemonic_SBC		; 249
		.byte $80|mnemonic_PLX		; 250
		.byte mnemonic_INVALID		; 251
		.byte mnemonic_INVALID		; 252
		.byte mnemonic_SBC		; 253
		.byte mnemonic_INC		; 254
		.byte mnemonic_INVALID		; 255
; ---------------------------------------------------------------------------


loc_9692:				
		jmp	loc_9A30

; ---------------------------------------------------------------------------

cmd_T:
		jsr	oswrch
		lda	#$80 
		sta	byte_3D		; copy of ESCAPE/BREAK bits???
		sta	byte_20
		jsr	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		cmp	#$53 
		bne	loc_96B1
		jsr	oswrch
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		ora	#$40 
		sta	byte_3D		; copy of ESCAPE/BREAK bits???
		jsr	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y

loc_96B1:				
		sta	byte_E
		cmp	#'B'
		beq	cmd_TB
		cmp	#'A'
		beq	cmd_TA_or_TX_or_TY
		cmp	#'X'
		beq	cmd_TA_or_TX_or_TY
		cmp	#'Y'
		beq	cmd_TA_or_TX_or_TY
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvc	loc_96CA
		jsr	print_backspace

loc_96CA:				
		jmp	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_TA_or_TX_or_TY:			
		jsr	sub_8880	; read byte value??
		sta	byte_F
		lda	#0

cmd_TB:					
		jsr	sub_8F49
		jsr	osnewl
		jsr	update_cursor_pos_2 ; update cursor pos	in cursor_x_2/cursor_y_2


loc_96DD:				
		jsr	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		tya
		ldy	#1
		sta	(workspace_pointer),y
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvs	loc_96FA
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bmi	loc_9700
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9700
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bmi	loc_96FA
		lda	byte_51		; bit 6	= set when dual	screen mode?
		lsr	a
		bcc	loc_9708

loc_96FA:				
		jsr	sub_9CBA
		jmp	loc_9708
; ---------------------------------------------------------------------------

loc_9700:				
		lda	#0
		sta	cursor_x_2
		sta	cursor_y_2
		sta	byte_20

loc_9708:				
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		beq	loc_9692
		jsr	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		beq	loc_977A
		jsr	sub_99B3
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bmi	loc_9762
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvc	loc_9729

loc_971C:				
		jsr	osrdch
		cmp	#$1B
		beq	loc_977A
		cmp	#$20 
		bne	loc_971C
		beq	loc_9762

loc_9729:				
		lda	byte_20
		bne	loc_973F
		lda	word_B
		pha
		lda	word_B+1
		pha
		jsr	sub_8331
		jsr	sub_A35C
		pla
		sta	word_B+1
		pla
		sta	word_B

loc_973F:				
		jsr	set_command_line_text_window_and_restore_cursor
		jsr	flush_input_buffer_and_readch
		cmp	#$7F 
		bne	loc_9758
		jsr	print_following_string_in_red
; ---------------------------------------------------------------------------
aSkip:		.text 'SKIP',$D
; ---------------------------------------------------------------------------
		nop
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		jmp	simulated_branch_not_taken
; ---------------------------------------------------------------------------

loc_9758:				
		cmp	#$2F 
		sta	byte_3D		; copy of ESCAPE/BREAK bits???
		beq	loc_9762
		cmp	#$20 
		bne	loc_9787

loc_9762:				
		lda	#$EA       ; NOP
		ldy	#loc_8581+1-loc_8563
		sta	(workspace_code),y ; $wwb0 = EQUB ???:NOP:???
		iny
		sta	(workspace_code),y ; $wwb0 = EQUB ???:NOP:NOP
		lda	reg_pc+1
		sta	workspace_pointer+1
		lda	reg_pc
		jsr	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		pha			; save opcode
		jsr	get_instruction_operand_size ; get size	of instruction operand bytes
					;
					; entry: A = opcode
					; exit:	C=0 if valid, then A = # bytes
					;	C=1 if invalid
		bcc	copy_instruction ; branch taken	if instruction valid

loc_977A:				
		jsr	sub_8331
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvs	loc_9784
		jmp	acknowledge_ESCAPE_and_reset_cursor
; ---------------------------------------------------------------------------

loc_9784:				
		jmp	loc_8315
; ---------------------------------------------------------------------------

loc_9787:				
		pha
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		pla
		jmp	loc_82A2
; ---------------------------------------------------------------------------

copy_instruction:			
		tax			; X = instruction operand size
		ldy	#loc_8581-loc_8563

copy_instruction_loop:			
		sty	sim_temp	; save offset
		jsr	read_memory_workspace_pointer ;	read opcode/operand byte
		ldy	sim_temp	; restore offset
		inc	workspace_pointer
		bne	loc_979F
		inc	workspace_pointer+1

loc_979F:				
		sta	(workspace_code),y ; copy to $wwb0
		sta	basic_TOP	; store	copy of	last byte fetched
		iny
		dex
		bpl	copy_instruction_loop
		pla			; restore opcode
		tay			; Y=opcode
		sty	sim_temp	; ?sim_temp=opcode
		cpy	#0
		beq	simulate_BRK
		cpy	#$20 
		beq	simulate_JSR_abs
		cpy	#$4C 
		beq	simulate_jmp_abs
		cpy	#$60 
		beq	simulate_RTS
		cpy	#$40 
		beq	simulate_RTI
		cpy	#$6C 
		beq	simulate_jmp_ind
		cpy	#$7C 
		beq	simulate_jmp_indX
		jmp	simulate_branch_or_ordinary
; ---------------------------------------------------------------------------

simulate_BRK:				
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bpl	loc_97D1
		jmp	loc_9969
; ---------------------------------------------------------------------------

loc_97D1:				
		lda	#$EA 
		ldy	#loc_8581-loc_8563
		sta	(workspace_code),y ; $wwb0 = NOP:NOP:NOP
		jmp	simulate_ordinary
; ---------------------------------------------------------------------------

simulate_RTI:				
		pla
		sta	reg_p
		pla
		sta	reg_pc
		clc			; no increment - RTI pops exact	address
		bcc	loc_97E9	; jmp, in effect

simulate_RTS:				
		pla
		clc
		adc	#1		; increment PC,	usual RTS thing
		sta	reg_pc

loc_97E9:				
		pla
		adc	#0
		sta	reg_pc+1
		jmp	simulate_execute
; ---------------------------------------------------------------------------

simulate_JSR_abs:			
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		cmp	#47
		bne	loc_97FA
		jmp	simulate_ordinary
; ---------------------------------------------------------------------------

loc_97FA:				
		ldx	basic_TOP	; X = last byte	fetched	- MSB of dest address
		inx			; X=$00	if target is $FFxx
		beq	simulate_jmp_abs ; taken if target is $FFxx
		clc
		lda	reg_pc
		adc	#2
		sta	byte_D
		lda	reg_pc+1
		adc	#0
		pha
		lda	byte_D
		pha

simulate_jmp_abs:			
		ldy	#loc_8581-loc_8563
		lda	#$20 
		sta	(workspace_code),y ; $wwb0 = jsr $xxxx
		lda	basic_TOP
		cmp	#$FF
		beq	simulate_ordinary ; taken if jump target is $FFxx
		sta	reg_pc+1
		iny
		lda	(workspace_code),y ; points to code region in workspace, +$92
		sta	reg_pc
		jmp	simulate_execute
; ---------------------------------------------------------------------------

simulate_jmp_ind:			
		jsr	reset_WRCHV	; reset	WRCHV to default value
		ldy	#loc_8581+1-loc_8563
		lda	basic_TOP	; last byte fetched - MSB of indirect address
		sta	workspace_pointer+1
		lda	(workspace_code),y ; fetch LSB of indirect address
		jsr	read_memory	; read LSB of jump target
		sta	reg_pc		; update PC
		inc	workspace_pointer
		bne	loc_983A
		inc	workspace_pointer+1

loc_983A:				
		jsr	read_memory_workspace_pointer ;	read MSB of jump target
		sta	reg_pc+1
		jsr	install_OSWRCH_handler
		jmp	simulate_execute
; ---------------------------------------------------------------------------

simulate_jmp_indX:			
		jsr	reset_WRCHV	; reset	WRCHV to default value
		ldy	#loc_8581+1-loc_8563
		lda	(workspace_code),y ; last byte fetched - MSB of	indirect address
		clc
		adc	reg_x
		pha
		lda	basic_TOP
		adc	#0
		sta	workspace_pointer+1
		pla
		jsr	read_memory	; read LSB of jump target
		sta	reg_pc
		inc	workspace_pointer
		bne	loc_9862
		inc	workspace_pointer+1

loc_9862:				
		jsr	read_memory_workspace_pointer ;	read MSB of jump target
		sta	reg_pc+1
		jsr	install_OSWRCH_handler
		jmp	simulate_execute
; ---------------------------------------------------------------------------

simulate_branch_or_ordinary:		
		tya
		cmp	#$80       ; $80 = BRA (CMOS)
		beq	loc_9878
		and	#$1F
		cmp	#$10		; $00 =	BRK/JSR	abs/RTI/RTS/BRA	(CMOS) (handled	above)/LDY imm/CPY imm/CPX imm
					; $10 =	BPL/BMI/BVC/BVS/BCC/BCS/BNE/BEQ
		bne	simulate_ordinary

loc_9878:				
		jmp	simulate_branch
; ---------------------------------------------------------------------------

simulate_ordinary:			
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		and	#$3F 
		beq	loc_988D
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bmi	loc_988D
		lda	byte_51		; bit 6	= set when dual	screen mode?
		lsr	a
		bcs	loc_988D
		jsr	sub_9CBA

loc_988D:				
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvc	loc_9896
		jsr	reset_WRCHV	; reset	WRCHV to default value
		bvs	loc_98BF

loc_9896:				
		bpl	loc_989B
		jsr	nvoswrch

loc_989B:				
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		beq	loc_98A6
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvs	loc_98A6
		jsr	set_output_text_window

loc_98A6:				
		lda	#$1F
		jsr	nvoswrch
		lda	cursor_x_2
		jsr	nvoswrch
		lda	cursor_y_2
		jsr	nvoswrch
		lda	#<wrch_8c42
		sta	XWRCHV
		lda	#>wrch_8c42
		sta	XWRCHV+1

loc_98BF:				
		lda	#<BRK_handler_8245
		sta	BRKV
		lda	#>BRK_handler_8245
		sta	BRKV+1		; ???? - $8245 doesn't look meaningful...
		jsr	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		ldy	#2
		lda	(workspace_pointer),y
		sta	byte_254	; keyboard auto-repeat delay (OSBYTE 196, AUG p202)
		iny
		lda	(workspace_pointer),y
		sta	byte_258	; ESCAPE/BREAK effect (OSBYTE 200, AUG p205)
		iny
		lda	(workspace_pointer),y
		sta	byte_27C	; character destination	status (OSBYTE 236, AUG	p232)
		iny
		lda	(workspace_pointer),y
		sta	byte_27D	; cursor editing status	(OSBYTE	237, AUG p233)
		iny
		lda	(workspace_pointer),y
		sta	byte_241	; input	source (OSBYTE 177, AUG	p186)
		lda	workspace_pointer+1
		pha
		lda	#loc_8576-loc_8563+workspace.code
		pha

		lda	current_rom	; if bit 6 set,	ROM has	been explicitly	set
                
		ldy	#loc_8578+1-loc_8563
		sta	(workspace_code),y ; fix up ROM	bank containing	routine

		lda	reg_p
		pha
		ldy	reg_y
		ldx	reg_x
		lda	reg_a
		jsr	swap_zp_and_workspaces
		rti

; ---------------------------------------------------------------------------

loc_9904:				
		jsr	swap_zp_and_workspaces
		jsr	sub_8CA7
		lda	byte_3D		; copy of ESCAPE/BREAK bits???
		and	#$3F 
		beq	loc_9921
		lda	byte_51		; bit 6	= set when dual	screen mode?
		lsr	a
		bcs	loc_9921
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bmi	loc_9921
		bvc	loc_9921
		jsr	osrdch
		jsr	sub_9CBA

loc_9921:				
		jsr	update_cursor_pos_2 ; update cursor pos	in cursor_x_2/cursor_y_2
		lda	sim_temp
		cmp	#$4C 
		bne	simulated_branch_not_taken
		jmp	simulate_RTS
; ---------------------------------------------------------------------------


simulated_branch_not_taken:		
		lda	word_B
		sta	reg_pc
		lda	word_B+1
		sta	reg_pc+1

simulate_execute:			
		cli
		cld
		tsx
		stx	reg_s
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bpl	loc_998D
		lda	byte_E
		ldx	byte_F
		cmp	#word_41+1
		beq	loc_995E
		cmp	#word_41
		beq	loc_9954
		cmp	#reg_pc
		beq	loc_995A
		cpx	reg_y
		beq	loc_9969
		bne	loc_995E

loc_9954:				
		cpx	reg_a
		beq	loc_9969
		bne	loc_995E

loc_995A:				
		cpx	reg_x
		beq	loc_9969

loc_995E:				
		lda	reg_pc+1
		sta	word_1C+1
		lda	reg_pc
		jsr	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		bcs	loc_998D

loc_9969:				
		lda	#0
		sta	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
		lda	#7
		jsr	oswrch
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvc	loc_997D
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		jmp	loc_977A
; ---------------------------------------------------------------------------

loc_997D:				
		lda	#$20 
		sta	byte_3D		; copy of ESCAPE/BREAK bits???
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvc	loc_998D
		lda	byte_51		; bit 6	= set when dual	screen mode?
		lsr	a
		bcs	loc_998D
		jsr	sub_9CBA

loc_998D:				
		jmp	loc_9708
; ---------------------------------------------------------------------------

simulate_branch:			
		tya			; A = opcode
		ldy	#loc_858A-loc_8563
		sta	(workspace_code),y ; fix up branch opcode at $wwb9
		lda	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		pha
		lda	#loc_858A-loc_8563+workspace.code
		pha
		lda	reg_p
		pha
		rti			; jmp $wwb9+PLP, in effect

; ---------------------------------------------------------------------------

simulated_branch_taken:			
		cld
		ldy	#loc_8581+1-loc_8563
		lda	(workspace_code),y ; read branch offset	from copied instruction
		sta	byte_8		; add8s	boilerplate
		jsr	add8s		; add branch offset to program counter
		sta	reg_pc+1
		lda	byte_9
		sta	reg_pc
		jmp	simulate_execute

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_99B3:				
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvs	loc_99C9
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvs	loc_99C9
		jsr	set_command_line_text_window_and_restore_cursor
		jsr	print_register_values
		jsr	print_cr
		ldx	#$17
		jsr	print_line_buffer ; print CR-terminated	line buffer contents.
					;
					; entry: X = max # chars to print

loc_99C9:				
		lda	reg_pc
		sta	word_B
		lda	reg_pc+1
		sta	word_B+1
		jsr	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		bit	byte_3D		; copy of ESCAPE/BREAK bits???
		bvc	loc_99D9

locret_99D8:				
		rts
; ---------------------------------------------------------------------------

loc_99D9:				
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvs	locret_99D8
		ldx	#$C

loc_99DF:				
		lda	line_buffer+$13,x
		sta	line_buffer+4,x
		dex
		bpl	loc_99DF
		lda	#$D
		sta	line_buffer+$11
		jsr	print_entire_line_buffer ; print up to 40 chars	from line buffer
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		jmp	draw_panel


; ---------------------------------------------------------------------------

cmd_G:
		jsr	sub_8F49
		lda	reg_pc+1
		sta	word_1C+1
		sta	workspace_pointer+1
		lda	reg_pc
		jsr	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		bcs	loc_9A18
		ldx	#0
		stx	byte_3D		; copy of ESCAPE/BREAK bits???
		jsr	sub_9CBA
		lda	reg_pc+1
		sta	word_B+1
		lda	reg_pc
		sta	word_B
		jsr	disassemble_instruction	; fill line buffer with	disassembly of instruction at (word_B)
		jmp	loc_9762
; ---------------------------------------------------------------------------

loc_9A18:				
		lda	reg_pc
		jsr	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		cmp	#0
		bne	loc_9A2D
		inc	reg_pc
		bne	loc_9A27
		inc	reg_pc+1

loc_9A27:				
		jsr	sub_8331
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9A2D:				
		jsr	sub_9CBA


loc_9A30:				
		jsr	sub_9B82
		ldy	#loc_8581-loc_8563
		lda	#$4C 
		sta	(workspace_code),y ; ensure +$1e is a jmp
		iny
		lda	reg_pc
		sta	(workspace_code),y ; fix up jump target	LSB
		iny
		lda	reg_pc+1
		sta	(workspace_code),y ; fix up jump target	MSB


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9A43:				
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvs	loc_9A4A
		jsr	osnewl

loc_9A4A:				
		bit	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		bpl	loc_9A53
		lda	#2
		jsr	nvoswrch

loc_9A53:				
		jsr	reset_WRCHV	; reset	WRCHV to default value
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		jmp	loc_98BF


; ---------------------------------------------------------------------------

cmd_J:
		jsr	read_address_qqq
		ldy	#loc_8581+1-loc_8563
		sta	(workspace_code),y ; fix up jump target	LSB
		iny
		lda	word_1C+1
		sta	(workspace_code),y ; fix up jump target	MSB
		dey
		dey
		lda	#$4C 
		sta	(workspace_code),y ; ensure +$1e is a jmp
		lda	workspace_page_number ;	set by OSBYTE 240 (AUG p234)
		pha
		lda	#loc_8592-1-loc_8563+workspace.code
		pha
		jmp	sub_9CBA
; ---------------------------------------------------------------------------

loc_9A78:				
		jsr	swap_zp_and_workspaces
		jsr	sub_8CA7
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bvc	loc_9A85
		jsr	sub_9CBA

loc_9A85:				
		jmp	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------

; find breakpoint by address
;
; entry: A=address LSB
;	 word_1C?1=address MSB
; exit:	C=1 - not found
;	C=0 - found, Y = index
; preserves: X

find_breakpoint_by_address:		
		sta	byte_14
		lda	word_1C+1
		sta	byte_15
		lda	num_breakpoints
		beq	loc_9AA7
		ldy	#0

loc_9A94:				
		lda	(word_4A),y	; pointer to breakpoint	address	LSBs
		cmp	byte_14
		bne	loc_9AA2
		lda	(word_4C),y	; pointer to breakpoint	address	MSBs
		cmp	byte_15
		bne	loc_9AA2
		clc
		rts
; ---------------------------------------------------------------------------

loc_9AA2:				
					; find_breakpoint_by_address+16j
		iny
		cpy	num_breakpoints
		bcc	loc_9A94

loc_9AA7:				
		sec
		rts


; ---------------------------------------------------------------------------

cmd_BS:					
		ldx	num_breakpoints
		cpx	#max_num_breakpoints
		bcc	loc_9AC1
		jsr	oswrch
		jsr	print_following_string_in_red
; ---------------------------------------------------------------------------
aTooMany:	.text 'Too many'
; ---------------------------------------------------------------------------
		nop

loc_9ABE:				
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9AC1:				
		jsr	read_address_qqq
		jsr	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		bcc	loc_9ABE	; taken	if breakpoint at that address already
		ldy	num_breakpoints
		inc	num_breakpoints
		lda	byte_14
		sta	(word_4A),y	; pointer to breakpoint	address	LSBs
		lda	byte_15
		sta	(word_4C),y	; pointer to breakpoint	address	MSBs
		sta	workspace_pointer+1
		lda	byte_14
		jsr	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		ldy	num_breakpoints
		dey
		sta	(word_4E),y
		jsr	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		bcc	loc_9AF9	; branch taken if valid	opcode
		dec	num_breakpoints
		jsr	print_following_string_in_red
; ---------------------------------------------------------------------------
aNotOpcode:	.text 'Not opcode'
; ---------------------------------------------------------------------------
		nop
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9AF9:				
		jsr	osnewl
		lda	#11
		jsr	oswrch
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

cmd_B:					; print	char in	A, then	read character
		jsr	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		cmp	#'S'
		beq	cmd_BS
		cmp	#'W'
		beq	cmd_BW
		cmp	#'C'
		beq	cmd_BC
		jmp	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

cmd_BC:					
		jsr	read_address_qqq
		jsr	find_breakpoint_by_address ; find breakpoint by	address
					;
					; entry: A=address LSB
					;	 word_1C?1=address MSB
					; exit:	C=1 - not found
					;	C=0 - found, Y = index
					; preserves: X
		bcc	loc_9B21	; branch taken if breakpoint found
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_9B21:				
		iny
		lda	(word_4E),y
		dey
		sta	(word_4E),y
		iny
		lda	(word_4A),y	; pointer to breakpoint	address	LSBs
		dey
		sta	(word_4A),y	; pointer to breakpoint	address	LSBs
		iny
		lda	(word_4C),y	; pointer to breakpoint	address	MSBs
		dey
		sta	(word_4C),y	; pointer to breakpoint	address	MSBs
		iny
		cpy	num_breakpoints
		bcc	loc_9B21
		ldx	#24
		dec	num_breakpoints
		beq	loc_9B7C
		cpy	#6
		beq	loc_9B7A
		bne	loc_9B7F

; --------------- S U B	R O U T	I N E ---------------------------------------

; print	a bunch	of spaces to clear screen line
;
; entry: X = row to clear

clear_line:				
		txa
		pha
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		pla
		tax
		lda	#26
		jsr	oswrch		; restore default text windows
		lda	#31
		jsr	oswrch		; set text cursor position
		lda	#0
		jsr	oswrch		; text cursor X=0
		txa
		jsr	oswrch		; text cursor Y=whatever
		jsr	print_39_spaces
		jmp	set_command_line_text_window_and_restore_cursor


; ---------------------------------------------------------------------------

cmd_BW:					
		jsr	oswrch
		lda	num_breakpoints
		beq	loc_9B7F	; branch taken if no breakpoints
		ldx	#24
		jsr	clear_line	; print	a bunch	of spaces to clear screen line
					;
					; entry: X = row to clear
		lda	num_breakpoints
		ldy	#0
		sty	num_breakpoints
		cmp	#6
		bcc	loc_9B7F

loc_9B7A:				
		ldx	#23

loc_9B7C:				
		jsr	clear_line	; print	a bunch	of spaces to clear screen line
					;
					; entry: X = row to clear

loc_9B7F:				
		jmp	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9B82:				
		ldx	num_breakpoints
		beq	locret_9BA3	; taken	if no breakpoints set
		ldx	#0

loc_9B88:				
		txa			; A = breakpoint index
		tay			; Y = breakpoint index
		lda	(word_4C),y	; fetch	breakpoint address MSB
		sta	workspace_pointer+1
		lda	(word_4A),y	; fetch	breakpoint address LSB
		tay
		lda	#0
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		inx
		cpx	num_breakpoints
		bcc	loc_9B88

loc_9B9B:				
		jsr	init_workspace_pointer ; initialize workspace pointer in ($f6)
					;
					; exit:	($f6) points to	workspace
					;	Y=0
					; preserves: A/X
		ldy	#workspace.flag
		txa
		sta	(workspace_pointer),y

locret_9BA3:				
		rts


; ---------------------------------------------------------------------------

loc_9BA4:				
		ldx	num_breakpoints
		beq	locret_9BA3
		ldx	#0

loc_9BAA:				
		txa
		tay
		lda	(word_4C),y	; pointer to breakpoint	address	MSBs
		sta	workspace_pointer+1
		lda	(word_4E),y
		pha
		lda	(word_4A),y	; pointer to breakpoint	address	LSBs
		tay
		pla
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		inx
		cpx	num_breakpoints
		bcc	loc_9BAA
		ldx	#0
		beq	loc_9B9B

cmd_Z:					; print	char in	A, then	read character
		jsr	echo_and_readch	;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		cmp	#'I'
		beq	cmd_ZI
		cmp	#'C'
		beq	cmd_ZC
		jmp	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------


handle_ctrl_z:				
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9BEA
		lda	byte_51		; bit 6	= set when dual	screen mode?
		asl	a
		adc	#0
		tax
		inx
		cpx	#3
		bne	loc_9BE2
		ldx	#0

loc_9BE2:				
		txa
		clc
		ror	a
		ror	a
		adc	#0
		sta	byte_51		; bit 6	= set when dual	screen mode?

loc_9BEA:				
		jmp	loc_82C2

; ---------------------------------------------------------------------------

cmd_ZC:					
		jsr	oswrch
		sta	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		jmp	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

cmd_ZI:					
		jsr	sub_8880	; read byte value??
		cpx	#0
		beq	invalid_ZI_address
		jsr	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		cmp	#$D5 
		bcs	invalid_ZI_address ; taken if >=$d5 - invalid address
		cmp	#$CE 
		bcc	loc_9C15	; taken	if <$ce	- valid	address
		cpx	#$FD 
		beq	loc_9C12	; branch taken if Master 128
		cpx	#$F5 
		beq	loc_9C12	; branch taken if Master Compact

invalid_ZI_address:			
		jmp	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_9C12:				
		jmp	loc_9C94
; ---------------------------------------------------------------------------

loc_9C15:				
		cmp	#$BC 
		bcs	invalid_ZI_address
		cmp	#$80 
		bcc	loc_9C4B
		cpx	#$FF
		bne	loc_9C3A	; branch taken if not OS 1.20
		sta	byte_25
		jsr	print_following_string
; ---------------------------------------------------------------------------
		.text ' RAM ID? '
; ---------------------------------------------------------------------------
		nop
		jsr	loc_8883
		and	#$F
		sta	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		jmp	loc_9C9A
; ---------------------------------------------------------------------------

loc_9C3A:				
		cpx	#$FB 
		bne	invalid_ZI_address ; branch taken if not B+
		cmp	#$AC 
		bcs	invalid_ZI_address
		sta	byte_25
		lda	#$40 
		sta	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		jmp	loc_9C9A
; ---------------------------------------------------------------------------

loc_9C4B:				
		cmp	#$78 
		bcs	loc_9C91
		cmp	#$30 
		bcc	loc_9C8D
		cpx	#$FF
		beq	loc_9C94	; branch taken if OS 1.20
		jsr	is_shadow_mode	; test if current mode is a shadow mode
					;
					; exit:	C=1 if shadow
					; preserves: A/X/Y
		bcc	loc_9C94
		sta	byte_25
		jsr	print_following_string
; ---------------------------------------------------------------------------
                .text ' IN SHADOW RAM? (Y/N) '
; ---------------------------------------------------------------------------
		nop

loc_9C78:				
		jsr	flush_input_buffer
		jsr	osrdch
		and	#$DF 
		cmp	#'N'
		beq	loc_9C96
		cmp	#'Y'
		bne	loc_9C78
		lda	#$40 
		jmp	loc_9C98
; ---------------------------------------------------------------------------

loc_9C8D:				
		cmp	#$E
		bcs	loc_9C94

loc_9C91:				
		jmp	error_then_command_line_loop
; ---------------------------------------------------------------------------

loc_9C94:				
		sta	byte_25

loc_9C96:				
		lda	#0

loc_9C98:				
		sta	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value

loc_9C9A:				
		lda	#22
		jsr	oswrch
		lda	#7
		jsr	oswrch
		lda	#$40 
		sta	byte_51		; bit 6	= set when dual	screen mode?
		jsr	sub_9CC3
		lda	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		ora	#$80 
		sta	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		jmp	loc_8269
; ---------------------------------------------------------------------------
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		jmp	dec_word_B	; decrement word_B
					;
					; preserves: A/X/Y

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9CBA:				
		bit	byte_51		; bit 6	= set when dual	screen mode?
		bmi	locret_9CC2
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bmi	sub_9CC3

locret_9CC2:				
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9CC3:				
					
		lda	word_B
		pha
		lda	word_B+1
		pha
		lda	byte_51		; bit 6	= set when dual	screen mode?
		eor	#$40 
		sta	byte_51		; bit 6	= set when dual	screen mode?
		lda	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		pha
		lda	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		and	#$F		; extract ROM slot
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bvc	loc_9CDC	; taken	if not paging in ANDY
		ora	#$80       ; set ROMSEL bit to page in ANDY

loc_9CDC:				
		sta	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		ldx	#0
		stx	byte_10
		stx	word_B
		lda	byte_25
		sta	word_B+1
		lda	#$7C 
		sta	byte_11

loc_9CEC:				
		jsr	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		ldy	vduws,x
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9CF9
		sta	vduws,x

loc_9CF9:				
		tya
		jsr	sub_B000
		inc	word_B
		inx
		bpl	loc_9CEC
		ldx	#$11

loc_9D04:				
		jsr	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		ldy	$D0,x
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9D0F
		sta	$D0,x

loc_9D0F:				
		tya
		jsr	sub_B000
		inc	word_B
		dex
		bpl	loc_9D04
		lda	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)
		pha
		jsr	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9D26
		sta	byte_26A	; negative count of bytes left in VDU queue (OSBYTE 218, AUG p221)

loc_9D26:				
		pla
		jsr	sub_B000
		inc	word_B
		ldx	byte_355
		lda	video_ULA_values,x ; video_ULA_values[i] is video ULA control register setting for mode	i
		tax
		lda	#154
		jsr	osbyte		; write	to video ULA register +	OS copy	(AUG p173)
		lda	vduws_MEMODE	; VDU variable:	memory mode (0=20K, 1=16K, 2=10K, 3=8K,	4=1K) (MasRef E.4-2)
		asl	a
		asl	a
		asl	a
		asl	a
		tax
		ldy	#11

loc_9D42:				
		lda	crtc_values,x	; crtc_values[i*16+j] is CRTC value for	R(11-j)	in MEMODE i
		jsr	sub_9E62
		inx
		dey
		bpl	loc_9D42
		lda	byte_DF
		pha
		ldx	vduws_CSPOSN	; address at which the 6845 is to display the text cursor (MasRef E.4-2)
		lda	vduws_CSPOSN+1	; address at which the 6845 is to display the text cursor (MasRef E.4-2)
		ldy	#14
		jsr	set_crtc_address ; set CRTC addresses of screen/cursor - R12/R13 or R14/R15
					;
					; entry: Y=base	CRTC register
					;	 X=screen address LSB
					;	 A=screen address MSB
		ldx	vduws_TOPSCN	; address of byte in top left corner of	screen display (MasRef E.4-2)
		lda	vduws_TOPSCN+1	; address of byte in top left corner of	screen display (MasRef E.4-2)
		ldy	#12
		jsr	set_crtc_address ; set CRTC addresses of screen/cursor - R12/R13 or R14/R15
					;
					; entry: Y=base	CRTC register
					;	 X=screen address LSB
					;	 A=screen address MSB
		pla
		sta	byte_DF
		ldx	vduws_MEMODE	; VDU variable:	memory mode (0=20K, 1=16K, 2=10K, 3=8K,	4=1K) (MasRef E.4-2)
		php
		sei
		lda	memode_latch_setting_b4,x ; memode_latch_setting_b4[i] is addressable latch bit	4 setting for MEMODE i
		sta	$FE40
		lda	memode_latch_setting_b5,x ; memode_latch_setting_b4[i] is addressable latch bit	5 setting for MEMODE i
		sta	$FE40
		plp

loc_9D7A:				
		jsr	read_byte	; read byte from memory
					;
					; entry: (word_B) = address to read from
					; exit:	A = byte read
					; preserves: X
		pha
		jsr	sub_9DC7
		jsr	sub_B000
		pla
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bpl	loc_9D8C
		jsr	sub_9DD5

loc_9D8C:				
		inc	word_B
		bne	loc_9D92
		inc	word_B+1

loc_9D92:				
		inc	byte_10
		bne	loc_9D7A
		inc	byte_11
		bpl	loc_9D7A
		pla
		sta	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		pla
		sta	word_B+1
		pla
		sta	word_B
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------

; read byte from memory
;
; entry: (word_B) = address to read from
; exit:	A = byte read
; preserves: X

read_byte:				
					
		lda	word_B
		sta	workspace_pointer
		lda	word_B+1
		sta	workspace_pointer+1
		cmp	#$C0 
		bcs	loc_9DC2	; taken	if reading MOS/IO
		cmp	#$80 
		bcs	loc_9DB8	; taken	if reading ROM
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bvc	loc_9DC2

loc_9DB8:				
		stx	byte_9
		ldy	current_rom	; if bit 6 set,	ROM has	been explicitly	set
		jsr	osrdrm		; read byte from ROM/screen memory
					;
					; entry: ($f6) = address
					;	 Y = ROM number	(if address in ROM)
					; exit:	A = byte read
		ldx	byte_9
		rts
; ---------------------------------------------------------------------------

loc_9DC2:				
					; read_byte+12j
		ldy	#0
		lda	(workspace_pointer),y
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9DC7:				
		ldy	byte_10
		sty	workspace_pointer
		ldy	byte_11
		sty	workspace_pointer+1
		ldy	#0
		jsr	osrdrm		; read byte from ROM/screen memory
					;
					; entry: ($f6) = address
					;	 Y = ROM number	(if address in ROM)
					; exit:	A = byte read
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9DD5:				
		ldy	byte_10
		sty	workspace_pointer
		ldy	byte_11
		sty	workspace_pointer+1
		tay
		txa
		jsr	get_machine_type ; Read	machine	type, as per OSBYTE $81
					;
					; exit:	X=machine type
					; preserves: A/Y
		cpx	#$FF
		beq	loc_9DEB
		tax
		tya
		jmp	call_oswrsc	; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
; ---------------------------------------------------------------------------

loc_9DEB:				
		tax
		tya
		ldy	#0
		sta	(workspace_pointer),y
		rts
; ---------------------------------------------------------------------------

call_oswrsc:				
		tay			; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
		lda	byte_D6
		pha
		lda	byte_D7
		pha
		lda	workspace_pointer
		sta	byte_D6
		lda	workspace_pointer+1
		sta	byte_D7
		tya
		ldy	#0
		jsr	oswrsc		; MasRef D.8-1
		pla
		sta	byte_D7
		pla
		sta	byte_D6
		rts


; ---------------------------------------------------------------------------
video_ULA_values:.byte $9C
					; video_ULA_values[i] is video ULA control register setting for	mode i
		.byte $D8
		.byte $F4
		.byte $9C
		.byte $88
		.byte $C4
		.byte $88
		.byte $4B
crtc_values:	.byte 8		
					; crtc_values[i*16+j] is CRTC value for	R(11-j)	in MEMODE i
		.byte $67
		.byte 7
		.byte 1
		.byte $22
		.byte $20
		.byte 0
		.byte $26
		.byte $28
		.byte $62
		.byte $50
		.byte $7F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 9
		.byte $67
		.byte 9
		.byte 1
		.byte $1B
		.byte $19
		.byte 2
		.byte $1E
		.byte $28
		.byte $62
		.byte $50
		.byte $7F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 8
		.byte $67
		.byte 7
		.byte 1
		.byte $22
		.byte $20
		.byte 0
		.byte $26
		.byte $24
		.byte $31
		.byte $28
		.byte $3F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte 9
		.byte $67
		.byte 9
		.byte 1
		.byte $1B
		.byte $19
		.byte 2
		.byte $1E
		.byte $24
		.byte $31
		.byte $28
		.byte $3F
		.byte 0
		.byte 0
		.byte 0
		.byte 0
		.byte $13
		.byte $72
		.byte $12
		.byte $93
		.byte $1B
		.byte $19
		.byte	2
		.byte $1E
		.byte $24
		.byte $33
		.byte $28
		.byte $3F

; --------------- S U B	R O U T	I N E ---------------------------------------

; see $c95e in OS1.20

sub_9E62:				
		cpy	#7
		bcc	loc_9E8A	; branch taken if Y<7
		bne	loc_9E6E	; branch taken if Y>7
		adc	byte_290	; VDU vertical adjust, as set by *TV
		jmp	loc_9E8A
; ---------------------------------------------------------------------------

loc_9E6E:				
		cpy	#$A
		bne	loc_9E7F
		tay
		lda	#$20 
		bit	byte_D0		; Z=0 if VDU 5
		php
		tya
		ldy	#$A
		plp
		beq	loc_9E8A	; branch taken if not VDU 5
		rts
; ---------------------------------------------------------------------------

loc_9E7F:				
		cpy	#8
		bne	loc_9E8A
		ora	#0
		bmi	loc_9E8A
		eor	byte_291	; VDU interlace	toggle,	as set by *TV

loc_9E8A:				
		sty	$FE00
		sta	$FE01
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------

; set CRTC addresses of	screen/cursor -	R12/R13	or R14/R15
;
; entry: Y=base	CRTC register
;	 X=screen address LSB
;	 A=screen address MSB

set_crtc_address:			
		pha
		lda	byte_355
		cmp	#7
		bcs	loc_9EB4	; taken	if mode	7
		pla
;handle bitmap calculations - divide address by 8
		stx	byte_DF
		ldx	#3

loc_9E9E:				
		lsr	a
		ror	byte_DF
		dex
		bne	loc_9E9E
		ldx	byte_DF

loc_9EA6:				
		sty	$FE00
		sta	$FE01
		iny
		sty	$FE00
		stx	$FE01
		rts
; ---------------------------------------------------------------------------
;handle teletext	calculations

loc_9EB4:				
		pla
		sec
		sbc	#$74 
		eor	#$20 
		jmp	loc_9EA6


; ---------------------------------------------------------------------------
memode_latch_setting_b4:.byte	4	
					; memode_latch_setting_b4[i] is	addressable latch bit 4	setting	for MEMODE i
		.byte	4
		.byte $C
		.byte  $C
		.byte	4
memode_latch_setting_b5:.byte  $D	
					; memode_latch_setting_b4[i] is	addressable latch bit 5	setting	for MEMODE i
		.byte	5
		.byte  $D
		.byte	5
		.byte	4
; ---------------------------------------------------------------------------

cmd_M:
		jsr	sub_9F1B
		jsr	sub_9ED0
		jmp	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9ED0:				
		lsr	byte_F
		bcs	loc_9EEB

loc_9ED4:				
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		bcs	locret_9F1A
		ldy	byte_11
		sty	workspace_pointer+1
		ldy	byte_10
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		inc	byte_10
		bne	loc_9EE8
		inc	byte_11

loc_9EE8:				
		jmp	loc_9ED4
; ---------------------------------------------------------------------------

loc_9EEB:				
		lda	byte_35
		sta	byte_10
		lda	byte_36
		sta	byte_11

loc_9EF3:				
		lda	byte_17
		sta	workspace_pointer+1
		lda	byte_16
		jsr	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		ldy	byte_11
		sty	workspace_pointer+1
		ldy	byte_10
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		ldy	byte_16
		bne	loc_9F0B
		dec	byte_17

loc_9F0B:				
		dec	byte_16
		ldy	byte_10
		bne	loc_9F13
		dec	byte_11

loc_9F13:				
		dec	byte_10
		jsr	check_fetch_address
		bcc	loc_9EF3

locret_9F1A:				
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_9F1B:				
		jsr	sub_8817
		cpx	#0
		bne	loc_9F25

loc_9F22:				
		jmp	command_line_loop_2 ; redraw panel, print ?, do	command	line input loop
; ---------------------------------------------------------------------------

loc_9F25:				
		lda	#','
		jsr	oswrch
		jsr	sub_8870
		cpx	#0
		beq	loc_9F22
		sta	byte_10
		sta	byte_45
		lda	word_1C+1
		sta	byte_11
		sta	byte_46
		sec
		lda	byte_10
		sta	byte_14
		sbc	word_B
		sta	byte_3D		; copy of ESCAPE/BREAK bits???
		lda	byte_11
		sta	byte_15
		sbc	word_B+1
		sta	sim_temp
		php
		pla
		sta	byte_F
		lda	word_B
		sta	byte_38
		lda	word_B+1
		sta	byte_39
		lda	byte_16
		sta	byte_3A
		clc
		adc	byte_3D		; copy of ESCAPE/BREAK bits???
		sta	byte_35
		lda	byte_17
		sta	byte_3B
		adc	sim_temp
		sta	byte_36
		lda	byte_10
		sta	byte_5E
		lda	byte_11
		sta	byte_5F
		rts


; ---------------------------------------------------------------------------

loc_9F72:				
		jsr	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aSplit:		.text 'Split'
; ---------------------------------------------------------------------------
		nop
		jsr	relocator_at_error

loc_9F7E:				
		ldx	byte_37
		cpx	byte_E
		bcc	loc_9F85
		rts
; ---------------------------------------------------------------------------

loc_9F85:				
		lda	unk_2E,x
		sta	word_B
		sta	byte_14
		lda	unk_32,x
		sta	word_B+1
		sta	byte_15
		lda	byte_26+1,x
		sta	byte_16
		lda	basic_IWA+1,x	; (BASIC) IWA
		sta	byte_17
		inc	byte_37
		jmp	loc_A05F
; ---------------------------------------------------------------------------

cmd_R:
		jsr	sub_9F1B
		lda	#0
		sta	byte_37

loc_9FA5:				
		lda	#':'
		jsr	oswrch
		jsr	sub_8870
		cpx	#0
		bne	loc_9FB6
		ldx	byte_37
		jmp	loc_A031
; ---------------------------------------------------------------------------

loc_9FB6:				
		ldx	byte_37
		clc
		adc	byte_3D		; copy of ESCAPE/BREAK bits???
		sta	byte_26,x
		lda	word_1C+1
		adc	sim_temp
		sta	basic_IWA,x	; (BASIC) IWA
		cmp	byte_46
		sta	byte_46
		bcc	loc_A010
		bne	loc_9FD1
		lda	byte_26,x
		cmp	byte_45
		bcc	loc_A010

loc_9FD1:				
		lda	byte_26,x
		sta	byte_45
		sec
		sbc	#1
		sta	byte_26,x
		lda	basic_IWA,x	; (BASIC) IWA
		sbc	#0
		sta	basic_IWA,x	; (BASIC) IWA
		lda	#']'
		jsr	oswrch

loc_9FE5:				
		jsr	sub_8870
		cpx	#0
		beq	loc_9FE5
		ldx	byte_37
		clc
		adc	#1
		php
		clc
		adc	byte_3D		; copy of ESCAPE/BREAK bits???
		sta	unk_2E,x
		lda	word_1C+1
		adc	sim_temp
		plp
		adc	#0
		sta	unk_32,x
		cmp	byte_46
		sta	byte_46
		bcc	loc_A010
		bne	loc_A023
		lda	unk_2E,x
		cmp	byte_45
		beq	loc_A010
		bcs	loc_A023

loc_A010:				
		jsr	loc_A016
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A016:				
		jsr	osnewl

loc_A019:				
		jsr	print_following_string_in_red
; ---------------------------------------------------------------------------
aError:		.text 'Error'
; ---------------------------------------------------------------------------
		nop
		rts
; ---------------------------------------------------------------------------

loc_A023:				
		lda	unk_2E,x
		sta	byte_45
		inx
		stx	byte_37
		cpx	#3
		bcs	loc_A031
		jmp	loc_9FA5
; ---------------------------------------------------------------------------

loc_A031:				
		lda	byte_35
		sta	byte_26,x
		lda	byte_36
		sta	basic_IWA,x	; (BASIC) IWA
		lda	#$FF
		sta	byte_57		; panel	status,	hex/disassembly???
		jsr	loc_A046
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A043:				
		jmp	loc_9F72
; ---------------------------------------------------------------------------

loc_A046:				
		jsr	sub_9ED0
		lda	byte_26
		sta	byte_16
		lda	basic_IWA	; (BASIC) IWA
		sta	byte_17
		stx	byte_E
		lda	byte_14
		sta	word_B
		lda	byte_15
		sta	word_B+1
		lda	#0
		sta	byte_37

loc_A05F:				
		jsr	sub_891F
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		bcc	loc_A06A
		jmp	loc_9F7E
; ---------------------------------------------------------------------------

loc_A06A:				
		sta	byte_45
		jsr	get_instruction_info ; entry: A	= opcode
					; exit:	C=1 if invalid;
					;	C=0 if valid
					;	A = offset into	mnemonics table
					;	?byte_D	= instruction addressing mode info
		lda	#0
		sta	byte_47
		bcs	loc_A0ED	; branch taken if instruction invalid
		lda	byte_D
		lsr	a
		jsr	shr5_clc
		beq	loc_A05F	; branch taken if 0 operand bytes
		sta	byte_F		; ?byte_F = number of operand bytes
		tay
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		bcs	loc_A043	; effectively a	nop, right? - shr5_clc above cleared C...
		sta	byte_46
		cpy	#2
		bne	loc_A092
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		bcs	loc_A043
		sta	byte_47

loc_A092:				
		lda	byte_D
		cmp	#$42 
		beq	loc_A05F	; taken	if immediate instruction - 1<<6|2
		cmp	#$67 
		beq	loc_A0F8	; taken	if branch instruction -	2<<6|7
		sec
		lda	byte_46
		sbc	byte_38
		lda	byte_47
		sbc	byte_39
		bcc	loc_A05F
		sec
		lda	byte_3A
		sbc	byte_46
		lda	byte_3B
		sbc	byte_47
		bcc	loc_A05F
		clc
		lda	byte_46
		adc	byte_3D		; copy of ESCAPE/BREAK bits???
		sta	byte_46
		lda	byte_47
		adc	sim_temp
		sta	byte_47
		lda	word_B
		sta	workspace_pointer
		lda	word_B+1
		sta	workspace_pointer+1
		jsr	sub_A139
		dec	byte_F
		beq	loc_A0D4
		lda	workspace_pointer+1
		pha
		jsr	sub_A139

loc_A0D4:				
		lda	byte_46
		ldy	workspace_pointer
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		dec	byte_F
		bmi	loc_A126
		ldy	workspace_pointer
		iny
		pla
		sta	workspace_pointer+1
		lda	byte_47
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write

loc_A0EA:				
		jmp	loc_A05F
; ---------------------------------------------------------------------------

loc_A0ED:				
		jsr	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aData:		.text 'Data'
; ---------------------------------------------------------------------------
		nop
		jmp	loc_A120
; ---------------------------------------------------------------------------

loc_A0F8:				
		lda	byte_46
		sta	byte_8
		jsr	add8s		; add 8-bit sign-extended value
					;
					; entry: ?byte_8, A = 8-bit signed value (seems	these must be the same???)
					;	 word_B	= 16-bit value
					; exit:	?byte_9	= LSB of result
					;	A = MSB	of result
					; preserves: X/Y
		sta	byte_D
		sec
		lda	byte_9
		sbc	byte_14
		lda	byte_D
		sbc	byte_15
		bcc	loc_A117
		sec
		lda	byte_16
		sbc	byte_9
		lda	byte_17
		sbc	byte_D
		bcs	loc_A0EA

loc_A117:				
		jsr	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aRange:		.text 'Range'
; ---------------------------------------------------------------------------
		nop

loc_A120:				
		jsr	relocator_at_error
		jmp	loc_A05F
; ---------------------------------------------------------------------------

loc_A126:				
		lda	byte_47
		beq	loc_A0EA
		jsr	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aOverflow:	.text 'Overflow'
; ---------------------------------------------------------------------------
		nop
		jmp	loc_A120

; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A139:				
		lda	workspace_pointer
		bne	loc_A13F
		dec	workspace_pointer+1

loc_A13F:				
		dec	workspace_pointer
		rts



; --------------- S U B	R O U T	I N E ---------------------------------------


relocator_at_error:			
		jsr	print_following_string
; ---------------------------------------------------------------------------
aAt:		.text ' at '
; ---------------------------------------------------------------------------
		nop
		ldx	#4
		jmp	print_line_buffer ; print CR-terminated	line buffer contents.

					; entry: X = max # chars to print
; ---------------------------------------------------------------------------

cmd_V:
		jsr	sub_9F1B
		lda	byte_10
		sta	byte_5E
		lda	byte_11
		sta	byte_5F
		lda	#0
		sta	byte_E

loc_A15E:				
		jsr	sub_87C8
		ldy	#0
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		sta	byte_F
		lda	byte_11
		sta	workspace_pointer+1
		lda	byte_10
		jsr	read_memory	; read byte from memory
					;
					; entry: A=LSB
					;	 workspace_pointer MSB=MSB
					; exit:	A=byte read
					; preserves: X
		cmp	byte_F
		beq	loc_A18C
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		ldx	#0
		lda	byte_11
		jsr	store_hex_byte_in_line_buffer
		lda	byte_10
		jsr	store_hex_byte_in_line_buffer
		stx	byte_E
		jsr	loc_A016
		jsr	relocator_at_error

loc_A18C:				
		inc	byte_10
		bne	loc_A192
		inc	byte_11

loc_A192:				
		jsr	check_fetch_address
		bcc	loc_A15E
		lda	byte_E
		bne	loc_A1A1
		jsr	print_following_string_in_red
; ---------------------------------------------------------------------------
aOk:		.text 'OK'
; ---------------------------------------------------------------------------
		nop

loc_A1A1:				
		jmp	command_line_loop_1

; --------------- S U B	R O U T	I N E ---------------------------------------


cmd_F:
		jsr	get_S_or_F_args	; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>
		beq	loc_A1A1
		lda	word_B
		sta	byte_5E
		lda	word_B+1
		sta	byte_5F

loc_A1B1:				
		ldx	#0

loc_A1B3:				
		jsr	check_fetch_address
		bcs	loc_A1A1
		lda	S_or_F_data,x	; buffer for search/fill data
		ldy	word_B+1
		sty	workspace_pointer+1
		ldy	word_B
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		inx
		cpx	byte_22
		bcc	loc_A1B3
		bcs	loc_A1B1
		bcc	loc_A1A1



; --------------- S U B	R O U T	I N E ---------------------------------------

; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>

get_S_or_F_args:			

; FUNCTION CHUNK AT 8D83 SIZE 00000006 BYTES

		sta	byte_E		; save command type - S	or F
		jsr	echo_and_readch	; print	char in	A, then	read character
					;
					; entry: A=char	to print
					; exit:	A=char read, toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		cmp	#'B'
		beq	get_SB_or_SS_or_FB_or_FS_args
		cmp	#'S'
		beq	get_SB_or_SS_or_FB_or_FS_args
		jmp	backspace_then_command_line_input_loop
; ---------------------------------------------------------------------------

get_SB_or_SS_or_FB_or_FS_args:		
					; get_S_or_F_args+Bj
		pha			; save command subtype - B or S
		jsr	sub_8817
		cpx	#0
		bne	loc_A1ED
		lda	byte_E
		cmp	#'S'
		bne	loc_A1A1

loc_A1ED:				
		pla			; restore command subtype
		cmp	#'B'
		beq	get_SB_or_FB_args ; taken if SB	or FB

get_SS_or_FS_args:
		lda	#'"'
		jsr	oswrch
		ldy	#$19
		jsr	read_line_buffer_n ; read input	into line buffer.
					;
					; entry: Y = max chars
		sty	byte_22		; save input length
		lda	#'"'
		jsr	oswrch
		cpy	#0
		beq	locret_A22F	; bail if no input
		ldx	#24		; max search data size

loc_A209:				
		lda	line_buffer,x
		sta	S_or_F_data,x	; save search text in search buffer
		dex
		bpl	loc_A209
		lda	#15
		jsr	oswrch
		ldx	#0
		stx	S_or_F_num_wildcards ; wildcard	count

loc_A219:				
		lda	S_or_F_data,x	; buffer for search/fill data
		cmp	#'@'
		bne	loc_A229	; taken	if not wildcard
		inc	S_or_F_num_wildcards
		ldy	S_or_F_num_wildcards
		cpy	#6
		bcs	too_many_wildcards
		stx	S_or_F_wildcards,y ; list of indexes of	wildcards in S_or_F_data

loc_A229:				
		inx
		cpx	byte_22
		bcc	loc_A219
		inx

locret_A22F:				
		rts
; ---------------------------------------------------------------------------

get_SB_or_FB_args:			
		ldx	#0
		stx	byte_22
		dex
		stx	S_or_F_num_wildcards

loc_A237:				
		lda	#','
		jsr	oswrch
		lda	byte_E		; restore command type - S or F
		cmp	#'F'
		beq	get_FB_args
		jsr	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		cmp	#'@'
		bne	loc_A26B
		jsr	oswrch
		inc	S_or_F_num_wildcards
		lda	byte_22
		ldx	S_or_F_num_wildcards
		cpx	#5
		bcc	loc_A266

too_many_wildcards:			
		jsr	print_newline_then_following_string_in_red
; ---------------------------------------------------------------------------
aWildcards:	.text 'Wildcards'
; ---------------------------------------------------------------------------
		nop

loc_A263:				
		jmp	command_line_loop_1
; ---------------------------------------------------------------------------

loc_A266:				
		sta	S_or_F_wildcards+1,x ; list of indexes of wildcards in S_or_F_data
		jmp	loc_A27E
; ---------------------------------------------------------------------------

loc_A26B:				
		ldx	#1
		stx	byte_8
		dex
		dex
		jsr	loc_888E
		jmp	loc_A27A
; ---------------------------------------------------------------------------

get_FB_args:				
		jsr	loc_8883

loc_A27A:				
		cpx	#0
		beq	loc_A289

loc_A27E:				
		ldx	byte_22
		sta	S_or_F_data,x	; buffer for search/fill data
		inx
		stx	byte_22
		cpx	#25
		bcc	loc_A237

loc_A289:				
		inc	S_or_F_num_wildcards
		ldx	byte_22
		rts


; ---------------------------------------------------------------------------

cmd_S:					; get args for S (search) or F (fill): S <range> <string>/F <range > <bytes>
		jsr	get_S_or_F_args
		beq	loc_A263
		jsr	osnewl
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		ldx	#0
		stx	basic_IWA	; (BASIC) IWA
		stx	unk_2B
		stx	basic_TOP


loc_A2A1:				
		txa
		bne	loc_A2AC
		lda	word_B
		sta	byte_5E
		lda	word_B+1
		sta	byte_5F

loc_A2AC:				
		ldy	basic_TOP
		cpy	S_or_F_num_wildcards
		bcs	loc_A2C0
		txa
		cmp	S_or_F_wildcards+1,y ; list of indexes of wildcards in S_or_F_data
		bne	loc_A2C0
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		iny
		sty	basic_TOP
		bpl	loc_A2C7

loc_A2C0:				
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		cmp	S_or_F_data,x	; buffer for search/fill data
		bne	loc_A318

loc_A2C7:				
		inx
		cpx	byte_22
		bcc	loc_A32A
		inc	basic_IWA	; (BASIC) IWA
		bne	loc_A2D2
		inc	unk_2B

loc_A2D2:				
		lda	byte_16
		pha
		lda	byte_17
		pha
		jsr	sub_A35C
		jsr	set_command_line_text_window_and_restore_cursor
		ldx	#0
		lda	byte_5F
		jsr	store_hex_byte_in_line_buffer
		lda	byte_5E
		jsr	store_hex_byte_in_line_buffer


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A2EA:

; FUNCTION CHUNK AT A2A1 SIZE 00000049 BYTES

		jsr	print_following_string
; ---------------------------------------------------------------------------
		.byte teletext_code(130)
		.text 'Found'
; ---------------------------------------------------------------------------
		nop
		jsr	relocator_at_error
		jsr	osnewl
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y

loc_A2FD:				
		jsr	getch
		cmp	#9
		bne	loc_A310
		jsr	sub_832A
		jsr	sub_A35C
		jsr	set_command_line_text_window_and_restore_cursor
		jmp	loc_A2FD
; ---------------------------------------------------------------------------

loc_A310:				
		pla
		sta	byte_17
		pla
		sta	byte_16
		ldx	#1

loc_A318:				
		txa
		beq	loc_A32A
		ldx	#0
		stx	basic_TOP
		lda	byte_5E
		sta	word_B
		lda	byte_5F
		sta	word_B+1
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C

loc_A32A:				
		jsr	check_fetch_address
		bcs	loc_A332
		jmp	loc_A2A1
; ---------------------------------------------------------------------------

loc_A332:				
		jsr	print_following_string_in_red
		nop
		jsr	determine_BASIC_version
		cmp	#0
		beq	loc_A359	; branch taken if BASIC	not present
		ldx	basic_IWA	; (BASIC) IWA
		dex
		txa
		ora	unk_2B
		pha
		ldx	#unk_85D7.print_line_number
		jsr	call_BASIC_routine ; entry: X =	index of routine to call
		jsr	print_following_string
; ---------------------------------------------------------------------------
aFinds:		.text ' finds'
; ---------------------------------------------------------------------------
		nop
		pla
		bne	loc_A359
		jsr	print_backspace

loc_A359:				
		jmp	command_line_loop_1



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A35C:				
					
		lda	byte_5E
		sta	word_B
		lda	byte_5F
		sta	word_B+1
		lda	byte_62		; height of panel???
		beq	loc_A38B
		jsr	sub_8AB6
		lda	#30
		jsr	oswrch		; reset	text cursor
		lda	byte_62		; height of panel???
		sta	byte_F

loc_A374:				
		lda	byte_57		; panel	status,	hex/disassembly???
		beq	loc_A37E
		jsr	disassemble_instruction_and_print
		jmp	loc_A381
; ---------------------------------------------------------------------------

loc_A37E:				
		jsr	sub_A3FA

loc_A381:				
		dec	byte_F
		beq	loc_A38B
		jsr	osnewl
		jmp	loc_A374
; ---------------------------------------------------------------------------

loc_A38B:				
		lda	word_B
		sta	byte_16
		lda	word_B+1
		sta	byte_17
		rts


; ---------------------------------------------------------------------------
		jsr	read_address_qqq
		sta	byte_5E
		lda	word_1C+1
		sta	byte_5F
		rts
; ---------------------------------------------------------------------------

cmd_D_or_L:				; save command name
		sta	byte_20
		jsr	sub_8817
		jsr	osnewl
		jsr	sub_8AA9
		jsr	show_cursor
		ldx	byte_62		; height of panel???
		stx	byte_F
		bpl	loc_A3B7

loc_A3B2:				
		lda	#$A
		jsr	oswrch

loc_A3B7:				
		lda	word_B+1
		sta	sim_temp
		lda	byte_20
		cmp	#'D'
		beq	loc_A3C7	; taken	if this	was D
;handle L
		jsr	sub_A3FA
		jmp	loc_A3CA
; ---------------------------------------------------------------------------

loc_A3C7:				
		jsr	disassemble_instruction_and_print

loc_A3CA:				
		lda	word_B+1
		cmp	sim_temp
		bcc	loc_A3F4
		jsr	check_fetch_address
		bcs	loc_A3F4
		jsr	poll_ESCAPE	; check	if ESCAPE is pressed
					;
					; exit:	Z=1 if ESCAPE pressed
		beq	loc_A3F1
		bit	basic_PAGE	; (BASIC) MSB of PAGE
					; (Exmon) flag indicating which	text window is active???
					;	  bit 7	= printer on/off
		bmi	loc_A3B2
		dec	byte_F
		bne	loc_A3B2
		ldx	byte_62		; height of panel???
		dex
		stx	byte_F
		jsr	flush_input_buffer
		jsr	osrdch
		cmp	#$1B
		bne	loc_A3B2

loc_A3F1:				
		jsr	acknowledge_ESCAPE


loc_A3F4:				
		jsr	draw_panel
		jmp	command_line_loop_3


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A3FA:				
					; RAM:A3C1p
		jsr	sub_891F
		lda	#teletext_code(134)
		sta	line_buffer+5
		lda	#teletext_code(131)
		sta	line_buffer+$1E
		ldy	#0
		ldx	#6

loc_A409:				
		jsr	fetch_memory	; fetch	byte using read_memory with post-increment.
					;
					; entry: (word_B) - address to fetch from
					; preserves: Y/C
		pha
		jsr	get_printable_char ; get printable version of byte - use '.' for unprintables
					;
					; entry: A = byte
					; exit:	A = printable char
		sta	line_buffer+$1F,y
		pla
		jsr	store_hex_byte_in_line_buffer
		inx
		iny
		cpy	#8
		bne	loc_A409
		lda	#$D
		sta	line_buffer+$27
		jmp	print_entire_line_buffer ; print up to 40 chars	from line buffer



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A424:				
		jsr	read_address_qqq
		cpx	#0
		beq	locret_A431
		sta	byte_5E
		lda	word_1C+1
		sta	byte_5F

locret_A431:				
		rts


; ---------------------------------------------------------------------------

cmd_E:
		jsr	sub_A424
		jsr	update_cursor_pos ; update cursor pos in cursor_x/cursor_y
		jsr	disable_cursor_editing
		lda	byte_57		; panel	status,	hex/disassembly???
		beq	loc_A442
		jmp	loc_9048
; ---------------------------------------------------------------------------


loc_A442:				
		ldx	#0
		stx	byte_36
		stx	byte_57		; panel	status,	hex/disassembly???
		stx	byte_37
		inx
		stx	byte_26
		lda	byte_5E
		sta	S_or_F_data	; buffer for search/fill data
		lda	byte_5F
		sta	unk_2D

loc_A455:				
		jsr	flush_input_buffer
		jsr	sub_A35C
		jsr	show_cursor
		ldy	byte_37
		lda	byte_26
		bpl	loc_A485
		lda	#$1F
		clc
		adc	byte_36
		tax
		jsr	gotoxy		; Move cursor to (x,y)
					;
					; entry: X = X coordinate
					;	 Y = Y coordinate
					; preserves: X/Y
		jsr	getch
		pha
		jsr	sub_A4C8
		pla
		bcs	loc_A455

loc_A477:				
		ldy	unk_2D
		sty	workspace_pointer+1
		ldy	S_or_F_data	; buffer for search/fill data
		jsr	write_memory	; write	memory
					;
					; entry: workspace_pointer?1 = address MSB
					;	 Y = address LSB
					;	 A = value to write
		jsr	sub_A52E
		bcs	loc_A455

loc_A485:				
		lda	byte_36
		asl	a
		clc
		adc	byte_36
		clc
		adc	#6
		tax
		jsr	gotoxy		; Move cursor to (x,y)
					;
					; entry: X = X coordinate
					;	 Y = Y coordinate
					; preserves: X/Y
		jsr	print_following_string
; ---------------------------------------------------------------------------
		.byte	8		; 0
		.byte teletext_code(131) ; 1
		.byte	9		; 2
		.byte	9		; 3
		.byte teletext_code(134) ; 4
		.byte	8		; 5
		.byte	8		; 6
		.byte	8		; 7
; ---------------------------------------------------------------------------
		nop

loc_A49E:				
		jsr	readch		; read character
					;
					; exit:	A=char,	toupper
					;	C=1 when symbol/digit
					;	V=0 when symbol/digit/xdigit
					; preserves: X/Y
		php
		pha
		jsr	sub_A4C8
		pla
		bcc	loc_A4AC
		pla
		bcs	loc_A455

loc_A4AC:				
		plp
		bvs	loc_A49E
		ldx	#1
		stx	byte_8
		ldx	#$FF
		jsr	loc_888E
		jmp	loc_A477


; --------------- S U B	R O U T	I N E ---------------------------------------

; Move cursor to (x,y)
;
; entry: X = X coordinate
;	 Y = Y coordinate
; preserves: X/Y

gotoxy:					
		lda	#31
		jsr	oswrch
		txa
		jsr	oswrch
		tya
		jmp	oswrch



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A4C8:				

; FUNCTION CHUNK AT 9055 SIZE 00000129 BYTES
; FUNCTION CHUNK AT A442 SIZE 00000079 BYTES
; FUNCTION CHUNK AT A544 SIZE 00000059 BYTES
; FUNCTION CHUNK AT A5A8 SIZE 00000049 BYTES

		jsr	poll_SHIFT	; poll for SHIFT key status
					;
					; exit:	X>=$80 and C=1 if shift	was pressed
					; preserves: A
		php
		cmp	#key_toggle_mode
		bne	loc_A4E3
		lda	S_or_F_data	; buffer for search/fill data
		sta	basic_P		; value	of P%
		lda	unk_2D
		sta	basic_P+1	; value	of P%
		jsr	sub_9038
		pla
		pla
		pla
		jmp	loc_9055
; ---------------------------------------------------------------------------

loc_A4E3:				
		cmp	#$88 
		beq	loc_A504
		cmp	#$89 
		beq	loc_A52B
		cmp	#$8A 
		bne	loc_A4F2
		jmp	loc_A5A8
; ---------------------------------------------------------------------------

loc_A4F2:				
		cmp	#$8B 
		bne	loc_A4F9
		jmp	loc_A561
; ---------------------------------------------------------------------------

loc_A4F9:				
		cmp	#$87 
		bne	loc_A500
		jmp	loc_A5E8
; ---------------------------------------------------------------------------

loc_A500:				
		plp
		cmp	#$7F 
		rts
; ---------------------------------------------------------------------------

loc_A504:				
		plp
		bcs	loc_A51B
		lda	S_or_F_data	; buffer for search/fill data
		bne	loc_A50D
		dec	unk_2D

loc_A50D:				
		dec	S_or_F_data	; buffer for search/fill data
		dec	byte_36
		bpl	loc_A519
		lda	#7
		sta	byte_36
		bne	loc_A56F

loc_A519:				
		sec
		rts
; ---------------------------------------------------------------------------

loc_A51B:				
		lda	#0
		sta	byte_36
		sta	byte_37
		lda	byte_5E
		sta	S_or_F_data	; buffer for search/fill data
		lda	byte_5F
		sta	unk_2D
		sec
		rts
; ---------------------------------------------------------------------------

loc_A52B:				
		plp
		bcs	loc_A544



; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A52E:				
		inc	S_or_F_data	; buffer for search/fill data
		bne	loc_A534
		inc	unk_2D

loc_A534:				
		inc	byte_36
		ldx	byte_36
		cpx	#8
		bcc	loc_A542
		lda	#0
		sta	byte_36
		beq	loc_A5B6

loc_A542:				
		sec
		rts


; ---------------------------------------------------------------------------


loc_A544:				
		lda	#7
		sta	byte_36
		ldx	byte_62		; height of panel???
		dex
		stx	byte_37
		txa
		asl	a
		asl	a
		asl	a
		clc
		adc	#7
		clc
		adc	byte_5E
		sta	S_or_F_data	; buffer for search/fill data
		lda	#0
		adc	byte_5F
		sta	unk_2D
		sec
		rts
; ---------------------------------------------------------------------------

loc_A561:				
		plp
		bcs	loc_A582
		sec
		lda	S_or_F_data	; buffer for search/fill data
		sbc	#8
		sta	S_or_F_data	; buffer for search/fill data
		bcs	loc_A56F
		dec	unk_2D

loc_A56F:				
		dec	byte_37
		bpl	loc_A580
		inc	byte_37
		sec
		lda	byte_5E
		sbc	#8
		sta	byte_5E
		bcs	loc_A580
		dec	byte_5F

loc_A580:				
		sec
		rts
; ---------------------------------------------------------------------------

loc_A582:				
		jsr	sub_A59D
		sec
		lda	byte_5E
		sbc	byte_8
		sta	byte_5E
		bcs	loc_A590
		dec	byte_5F

loc_A590:				
		sec
		lda	S_or_F_data	; buffer for search/fill data
		sbc	byte_8
		sta	S_or_F_data	; buffer for search/fill data
		bcs	loc_A59B
		dec	unk_2D

loc_A59B:				
		sec
		rts


; --------------- S U B	R O U T	I N E ---------------------------------------


sub_A59D:				
		lda	byte_62		; height of panel???
		sec
		sbc	#1
		asl	a
		asl	a
		asl	a
		sta	byte_8
		rts


; ---------------------------------------------------------------------------


loc_A5A8:				
		plp
		bcs	loc_A5CD
		clc
		lda	S_or_F_data	; buffer for search/fill data
		adc	#8
		sta	S_or_F_data	; buffer for search/fill data
		bcc	loc_A5B6
		inc	unk_2D

loc_A5B6:				
		inc	byte_37
		ldx	byte_37
		cpx	byte_62		; height of panel???
		bcc	loc_A5CB
		dec	byte_37
		lda	byte_5E
		clc
		adc	#8
		sta	byte_5E
		bcc	loc_A5CB
		inc	byte_5F

loc_A5CB:				
		sec
		rts
; ---------------------------------------------------------------------------

loc_A5CD:				
		jsr	sub_A59D
		clc
		lda	byte_5E
		adc	byte_8
		sta	byte_5E
		bcc	loc_A5DB
		inc	byte_5F

loc_A5DB:				
		clc
		lda	S_or_F_data	; buffer for search/fill data
		adc	byte_8
		sta	S_or_F_data	; buffer for search/fill data
		bcc	loc_A5E6
		inc	unk_2D

loc_A5E6:				
		sec
		rts
; ---------------------------------------------------------------------------

loc_A5E8:				
		plp
		lda	byte_26
		eor	#$FF
		sta	byte_26
		sec
		rts

; ---------------------------------------------------------------------------

*=$b000
                
; --------------- S U B	R O U T	I N E ---------------------------------------

; TODO haven't put much effort into figuring out when this routine
; gets called - but presumably it's gated by a B+-or-better check of
; some kind, somewhere, as it calls OSWRSC. So maybe it'll never get
; called on the Electron?
;
; Anyway, if it ever does, it'll fall through to the default write
; routine.

sub_B000:				
		ldy	word_B
		sty	workspace_pointer
		ldy	word_B+1
		sty	workspace_pointer+1
                .if !ELECTRON
		bmi	loc_B016	; taken	if attempting to write to ROM/OS/IO
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bvc	loc_B011
		jmp	call_oswrsc	; call OSWRSC with address in (workspace_pointer)
					;
					; entry: A = byte to write
					;	 (workspace_pointer) = address
					; exit:	Y=0
					; preserves: X
                .endif
; ---------------------------------------------------------------------------

loc_B011:				
		ldy	#0
		sta	(workspace_pointer),y
		rts
; ---------------------------------------------------------------------------

                .if !ELECTRON
loc_B016:				
		cpy	#$C0 
		bcs	loc_B011	; taken	if attempting to write to MOS/IO
		bit	byte_5B		; bit 7	set = shadow RAM on???
					; bit 6	set = sub_B000 pages in	ANDY for $8000...$bfff
					; bits 0..3 = ROMSEL value
		bvc	loc_B011
;write to ANDY
		tay
		lda	$f4
		ora	#$80       ; set the ANDY bit
		sta	$f4
		sta	romsel
		tya
		ldy	#0
		sta	(workspace_pointer),y
		lda	$f4
		and	#$7F       ; unset the ANDY bit
		sta	$f4
		sta	romsel
		rts
                .endif

; ---------------------------------------------------------------------------

*=$c000-len(timestamp)-1
		.text timestamp,13
